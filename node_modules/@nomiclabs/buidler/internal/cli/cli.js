#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const semver_1 = __importDefault(require("semver"));
require("source-map-support/register");
const task_names_1 = require("../../builtin-tasks/task-names");
const constants_1 = require("../constants");
const context_1 = require("../context");
const config_loading_1 = require("../core/config/config-loading");
const errors_1 = require("../core/errors");
const errors_list_1 = require("../core/errors-list");
const buidler_params_1 = require("../core/params/buidler-params");
const env_variables_1 = require("../core/params/env-variables");
const project_structure_1 = require("../core/project-structure");
const runtime_environment_1 = require("../core/runtime-environment");
const typescript_support_1 = require("../core/typescript-support");
const packageInfo_1 = require("../util/packageInfo");
const analytics_1 = require("./analytics");
const ArgumentsParser_1 = require("./ArgumentsParser");
const emoji_1 = require("./emoji");
const project_creation_1 = require("./project-creation");
const log = debug_1.default("buidler:core:cli");
const ANALYTICS_SLOW_TASK_THRESHOLD = 300;
async function printVersionMessage(packageJson) {
    console.log(packageJson.version);
}
function ensureValidNodeVersion(packageJson) {
    const requirement = packageJson.engines.node;
    if (!semver_1.default.satisfies(process.version, requirement)) {
        throw new errors_1.BuidlerError(errors_list_1.ERRORS.GENERAL.INVALID_NODE_VERSION, {
            requirement,
        });
    }
}
async function main() {
    // We first accept this argument anywhere, so we know if the user wants
    // stack traces before really parsing the arguments.
    let showStackTraces = process.argv.includes("--show-stack-traces");
    try {
        const packageJson = await packageInfo_1.getPackageJson();
        ensureValidNodeVersion(packageJson);
        const envVariableArguments = env_variables_1.getEnvBuidlerArguments(buidler_params_1.BUIDLER_PARAM_DEFINITIONS, process.env);
        const argumentsParser = new ArgumentsParser_1.ArgumentsParser();
        const { buidlerArguments, taskName: parsedTaskName, unparsedCLAs, } = argumentsParser.parseBuidlerArguments(buidler_params_1.BUIDLER_PARAM_DEFINITIONS, envVariableArguments, process.argv.slice(2));
        if (buidlerArguments.verbose) {
            debug_1.default.enable("buidler*");
        }
        if (buidlerArguments.emoji) {
            emoji_1.enableEmoji();
        }
        showStackTraces = buidlerArguments.showStackTraces;
        if (buidlerArguments.config === undefined &&
            !project_structure_1.isCwdInsideProject() &&
            process.stdout.isTTY === true) {
            await project_creation_1.createProject();
            return;
        }
        // --version is a special case
        if (buidlerArguments.version) {
            await printVersionMessage(packageJson);
            return;
        }
        typescript_support_1.loadTsNodeIfPresent();
        const ctx = context_1.BuidlerContext.createBuidlerContext();
        const config = config_loading_1.loadConfigAndTasks(buidlerArguments);
        const analytics = await analytics_1.Analytics.getInstance(config.paths.root, config.analytics.enabled);
        const envExtenders = ctx.extendersManager.getExtenders();
        const taskDefinitions = ctx.tasksDSL.getTaskDefinitions();
        let taskName = parsedTaskName !== undefined ? parsedTaskName : "help";
        // tslint:disable-next-line: prefer-const
        let [abortAnalytics, hitPromise] = await analytics.sendTaskHit(taskName);
        let taskArguments;
        // --help is a also special case
        if (buidlerArguments.help && taskName !== task_names_1.TASK_HELP) {
            taskArguments = { task: taskName };
            taskName = task_names_1.TASK_HELP;
        }
        else {
            const taskDefinition = taskDefinitions[taskName];
            if (taskDefinition === undefined) {
                throw new errors_1.BuidlerError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {
                    task: taskName,
                });
            }
            taskArguments = argumentsParser.parseTaskArguments(taskDefinition, unparsedCLAs);
        }
        // TODO: This is here for backwards compatibility
        // There are very few projects using this.
        if (buidlerArguments.network === undefined) {
            buidlerArguments.network = config.defaultNetwork;
        }
        const env = new runtime_environment_1.Environment(config, buidlerArguments, taskDefinitions, envExtenders);
        ctx.setBuidlerRuntimeEnvironment(env);
        const timestampBeforeRun = new Date().getTime();
        await env.run(taskName, taskArguments);
        const timestampAfterRun = new Date().getTime();
        if (timestampAfterRun - timestampBeforeRun >
            ANALYTICS_SLOW_TASK_THRESHOLD) {
            await hitPromise;
        }
        else {
            abortAnalytics();
        }
        log(`Killing Buidler after successfully running task ${taskName}`);
    }
    catch (error) {
        let isBuidlerError = false;
        if (errors_1.BuidlerError.isBuidlerError(error)) {
            isBuidlerError = true;
            console.error(chalk_1.default.red(`Error ${error.message}`));
        }
        else if (errors_1.BuidlerPluginError.isBuidlerPluginError(error)) {
            isBuidlerError = true;
            console.error(chalk_1.default.red(`Error in plugin ${error.pluginName}: ${error.message}`));
        }
        else if (error instanceof Error) {
            console.error(chalk_1.default.red("An unexpected error occurred:"));
            showStackTraces = true;
        }
        else {
            console.error(chalk_1.default.red("An unexpected error occurred."));
            showStackTraces = true;
        }
        console.log("");
        if (showStackTraces) {
            console.error(error.stack);
        }
        else {
            if (!isBuidlerError) {
                console.error(`If you think this is a bug in Buidler, please report it here: https://buidler.dev/reportbug`);
            }
            if (errors_1.BuidlerError.isBuidlerError(error)) {
                const link = `https://buidler.dev/${errors_list_1.getErrorCode(error.errorDescriptor)}`;
                console.error(`For more info go to ${link} or run ${constants_1.BUIDLER_NAME} with --show-stack-traces`);
            }
            else {
                console.error(`For more info run ${constants_1.BUIDLER_NAME} with --show-stack-traces`);
            }
        }
        process.exit(1);
    }
}
main()
    .then(() => process.exit(process.exitCode))
    .catch((error) => {
    console.error(error);
    process.exit(1);
});
//# sourceMappingURL=cli.js.map