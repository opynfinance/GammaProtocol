{"version":3,"file":"index.memory.node.cjs.js","sources":["../src/core/version.ts","../src/platform/platform.ts","../src/util/log.ts","../src/util/assert.ts","../src/util/misc.ts","../src/core/database_info.ts","../src/auth/user.ts","../src/core/listen_sequence.ts","../src/util/sorted_map.ts","../src/util/sorted_set.ts","../src/util/error.ts","../src/model/path.ts","../src/model/document_key.ts","../src/model/collections.ts","../src/util/types.ts","../src/local/shared_client_state.ts","../src/api/timestamp.ts","../src/core/snapshot_version.ts","../src/util/obj.ts","../src/util/byte_string.ts","../src/model/server_timestamps.ts","../src/model/values.ts","../src/model/document.ts","../src/model/object_value.ts","../src/model/mutation.ts","../src/model/mutation_batch.ts","../src/util/obj_map.ts","../src/local/persistence_promise.ts","../src/local/local_documents_view.ts","../src/local/persistence.ts","../src/local/target_data.ts","../src/util/promise.ts","../src/local/memory_index_manager.ts","../src/local/remote_document_change_buffer.ts","../src/core/target_id_generator.ts","../src/local/lru_garbage_collector.ts","../src/local/simple_db.ts","../src/local/local_store.ts","../src/local/local_view_changes.ts","../src/local/reference_set.ts","../src/remote/remote_event.ts","../src/core/target.ts","../src/core/query.ts","../src/model/document_set.ts","../src/core/view_snapshot.ts","../src/core/view.ts","../src/remote/backoff.ts","../src/util/async_queue.ts","../src/remote/persistent_stream.ts","../src/remote/datastore.ts","../src/core/transaction.ts","../src/remote/rpc_error.ts","../src/core/transaction_runner.ts","../src/core/sync_engine.ts","../src/remote/online_state_tracker.ts","../src/remote/watch_change.ts","../src/remote/remote_store.ts","../src/core/event_manager.ts","../src/local/index_free_query_engine.ts","../src/local/memory_mutation_queue.ts","../src/local/memory_remote_document_cache.ts","../src/local/memory_target_cache.ts","../src/local/memory_persistence.ts","../src/core/component_provider.ts","../src/core/firestore_client.ts","../src/util/async_observer.ts","../src/util/input_validation.ts","../src/api/field_path.ts","../src/api/credentials.ts","../src/api/observer.ts","../src/api/blob.ts","../src/model/transform_operation.ts","../src/api/field_value.ts","../src/api/geo_point.ts","../src/api/user_data_reader.ts","../src/remote/existence_filter.ts","../src/remote/serializer.ts","../src/api/user_data_writer.ts","../src/api/database.ts","../src/util/api.ts","../src/platform/config.ts","../src/remote/connectivity_monitor_noop.ts","../src/remote/stream_bridge.ts","../src/util/node_api.ts","../src/platform_node/grpc_connection.ts","../src/platform_node/load_protos.ts","../src/platform_node/node_platform.ts","../src/platform_node/node_init.ts","../index.node.memory.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\n\n/** The semver (www.semver.org) version of the SDK. */\nexport const SDK_VERSION = firebase.SDK_VERSION;\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { Connection } from '../remote/connection';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { fail } from '../util/assert';\nimport { ConnectivityMonitor } from './../remote/connectivity_monitor';\n\n/**\n * Provides a common interface to load anything platform dependent, e.g.\n * the connection implementation.\n *\n * An implementation of this must be provided at compile time for the platform.\n */\n// TODO: Consider only exposing the APIs of 'document' and 'window' that we\n// use in our client.\nexport interface Platform {\n  loadConnection(databaseInfo: DatabaseInfo): Promise<Connection>;\n  newConnectivityMonitor(): ConnectivityMonitor;\n  newSerializer(databaseId: DatabaseId): JsonProtoSerializer;\n\n  /** Formats an object as a JSON string, suitable for logging. */\n  formatJSON(value: unknown): string;\n\n  /** Converts a Base64 encoded string to a binary string. */\n  atob(encoded: string): string;\n\n  /** Converts a binary string to a Base64 encoded string. */\n  btoa(raw: string): string;\n\n  /**\n   * Generates `nBytes` of random bytes.\n   *\n   * If `nBytes < 0` , an error will be thrown.\n   */\n  randomBytes(nBytes: number): Uint8Array;\n\n  /** The Platform's 'window' implementation or null if not available. */\n  readonly window: Window | null;\n\n  /** The Platform's 'document' implementation or null if not available. */\n  readonly document: Document | null;\n\n  /** True if and only if the Base64 conversion functions are available. */\n  readonly base64Available: boolean;\n}\n\n/**\n * Provides singleton helpers where setup code can inject a platform at runtime.\n * setPlatform needs to be set before Firestore is used and must be set exactly\n * once.\n */\nexport class PlatformSupport {\n  private static platform: Platform;\n  static setPlatform(platform: Platform): void {\n    if (PlatformSupport.platform) {\n      fail('Platform already defined');\n    }\n    PlatformSupport.platform = platform;\n  }\n\n  static getPlatform(): Platform {\n    if (!PlatformSupport.platform) {\n      fail('Platform not set');\n    }\n    return PlatformSupport.platform;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Logger, LogLevel, LogLevelString } from '@firebase/logger';\nimport { SDK_VERSION } from '../core/version';\nimport { PlatformSupport } from '../platform/platform';\n\nexport { LogLevel };\n\nconst logClient = new Logger('@firebase/firestore');\n\n// Helper methods are needed because variables can't be exported as read/write\nexport function getLogLevel(): LogLevel {\n  return logClient.logLevel;\n}\n\nexport function setLogLevel(newLevel: LogLevelString | LogLevel): void {\n  logClient.setLogLevel(newLevel);\n}\n\nexport function logDebug(msg: string, ...obj: unknown[]): void {\n  if (logClient.logLevel <= LogLevel.DEBUG) {\n    const args = obj.map(argToString);\n    logClient.debug(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n  }\n}\n\nexport function logError(msg: string, ...obj: unknown[]): void {\n  if (logClient.logLevel <= LogLevel.ERROR) {\n    const args = obj.map(argToString);\n    logClient.error(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n  }\n}\n\nexport function logWarn(msg: string, ...obj: unknown[]): void {\n  if (logClient.logLevel <= LogLevel.WARN) {\n    const args = obj.map(argToString);\n    logClient.warn(`Firestore (${SDK_VERSION}): ${msg}`, ...args);\n  }\n}\n\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj: unknown): string | unknown {\n  if (typeof obj === 'string') {\n    return obj;\n  } else {\n    const platform = PlatformSupport.getPlatform();\n    try {\n      return platform.formatJSON(obj);\n    } catch (e) {\n      // Converting to JSON failed, just log the object directly\n      return obj;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SDK_VERSION } from '../core/version';\nimport { logError } from './log';\n\n/**\n * Unconditionally fails, throwing an Error with the given message.\n * Messages are stripped in production builds.\n *\n * Returns `never` and can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nexport function fail(failure: string = 'Unexpected state'): never {\n  // Log the failure in addition to throw an exception, just in case the\n  // exception is swallowed.\n  const message =\n    `FIRESTORE (${SDK_VERSION}) INTERNAL ASSERTION FAILED: ` + failure;\n  logError(message);\n\n  // NOTE: We don't use FirestoreError here because these are internal failures\n  // that cannot be handled by the user. (Also it would create a circular\n  // dependency between the error and assert modules which doesn't work.)\n  throw new Error(message);\n}\n\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * Messages are stripped in production builds.\n */\nexport function hardAssert(\n  assertion: boolean,\n  message?: string\n): asserts assertion {\n  if (!assertion) {\n    fail(message);\n  }\n}\n\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n *\n * The code of callsites invoking this function are stripped out in production\n * builds. Any side-effects of code within the debugAssert() invocation will not\n * happen in this case.\n */\nexport function debugAssert(\n  assertion: boolean,\n  message: string\n): asserts assertion {\n  if (!assertion) {\n    fail(message);\n  }\n}\n\n/**\n * Casts `obj` to `T`. In non-production builds, verifies that `obj` is an\n * instance of `T` before casting.\n */\nexport function debugCast<T>(\n  obj: object,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor: { new (...args: any[]): T }\n): T | never {\n  debugAssert(\n    obj instanceof constructor,\n    `Expected type '${constructor.name}', but was '${obj.constructor.name}'`\n  );\n  return obj as T;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from './assert';\nimport { PlatformSupport } from '../platform/platform';\n\nexport type EventHandler<E> = (value: E) => void;\nexport interface Indexable {\n  [k: string]: unknown;\n}\n\nexport class AutoId {\n  static newId(): string {\n    // Alphanumeric characters\n    const chars =\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    // The largest byte value that is a multiple of `char.length`.\n    const maxMultiple = Math.floor(256 / chars.length) * chars.length;\n    debugAssert(\n      0 < maxMultiple && maxMultiple < 256,\n      `Expect maxMultiple to be (0, 256), but got ${maxMultiple}`\n    );\n\n    let autoId = '';\n    const targetLength = 20;\n    while (autoId.length < targetLength) {\n      const bytes = PlatformSupport.getPlatform().randomBytes(40);\n      for (let i = 0; i < bytes.length; ++i) {\n        // Only accept values that are [0, maxMultiple), this ensures they can\n        // be evenly mapped to indices of `chars` via a modulo operation.\n        if (autoId.length < targetLength && bytes[i] < maxMultiple) {\n          autoId += chars.charAt(bytes[i] % chars.length);\n        }\n      }\n    }\n    debugAssert(autoId.length === targetLength, 'Invalid auto ID: ' + autoId);\n\n    return autoId;\n  }\n}\n\nexport function primitiveComparator<T>(left: T, right: T): number {\n  if (left < right) {\n    return -1;\n  }\n  if (left > right) {\n    return 1;\n  }\n  return 0;\n}\n\nexport interface Equatable<T> {\n  isEqual(other: T): boolean;\n}\n\n/** Helper to compare arrays using isEqual(). */\nexport function arrayEquals<T>(\n  left: T[],\n  right: T[],\n  comparator: (l: T, r: T) => boolean\n): boolean {\n  if (left.length !== right.length) {\n    return false;\n  }\n  return left.every((value, index) => comparator(value, right[index]));\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s: string): string {\n  // Return the input string, with an additional NUL byte appended.\n  return s + '\\0';\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { primitiveComparator } from '../util/misc';\n\nexport class DatabaseInfo {\n  /**\n   * Constructs a DatabaseInfo using the provided host, databaseId and\n   * persistenceKey.\n   *\n   * @param databaseId The database to use.\n   * @param persistenceKey A unique identifier for this Firestore's local\n   * storage (used in conjunction with the databaseId).\n   * @param host The Firestore backend host to connect to.\n   * @param ssl Whether to use SSL when connecting.\n   * @param forceLongPolling Whether to use the forceLongPolling option\n   * when using WebChannel as the network transport.\n   */\n  constructor(\n    readonly databaseId: DatabaseId,\n    readonly persistenceKey: string,\n    readonly host: string,\n    readonly ssl: boolean,\n    readonly forceLongPolling: boolean\n  ) {}\n}\n\n/** The default database name for a project. */\nconst DEFAULT_DATABASE_NAME = '(default)';\n\n/** Represents the database ID a Firestore client is associated with. */\nexport class DatabaseId {\n  readonly database: string;\n  constructor(readonly projectId: string, database?: string) {\n    this.database = database ? database : DEFAULT_DATABASE_NAME;\n  }\n\n  get isDefaultDatabase(): boolean {\n    return this.database === DEFAULT_DATABASE_NAME;\n  }\n\n  isEqual(other: {}): boolean {\n    return (\n      other instanceof DatabaseId &&\n      other.projectId === this.projectId &&\n      other.database === this.database\n    );\n  }\n\n  compareTo(other: DatabaseId): number {\n    return (\n      primitiveComparator(this.projectId, other.projectId) ||\n      primitiveComparator(this.database, other.database)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nexport class User {\n  /** A user with a null UID. */\n  static readonly UNAUTHENTICATED = new User(null);\n\n  // TODO(mikelehen): Look into getting a proper uid-equivalent for\n  // non-FirebaseAuth providers.\n  static readonly GOOGLE_CREDENTIALS = new User('google-credentials-uid');\n  static readonly FIRST_PARTY = new User('first-party-uid');\n\n  constructor(readonly uid: string | null) {}\n\n  isAuthenticated(): boolean {\n    return this.uid != null;\n  }\n\n  /**\n   * Returns a key representing this user, suitable for inclusion in a\n   * dictionary.\n   */\n  toKey(): string {\n    if (this.isAuthenticated()) {\n      return 'uid:' + this.uid;\n    } else {\n      return 'anonymous-user';\n    }\n  }\n\n  isEqual(otherUser: User): boolean {\n    return otherUser.uid === this.uid;\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ListenSequenceNumber } from './types';\n\n/**\n * `SequenceNumberSyncer` defines the methods required to keep multiple instances of a\n * `ListenSequence` in sync.\n */\nexport interface SequenceNumberSyncer {\n  // Notify the syncer that a new sequence number has been used.\n  writeSequenceNumber(sequenceNumber: ListenSequenceNumber): void;\n  // Setting this property allows the syncer to notify when a sequence number has been used, and\n  // and lets the ListenSequence adjust its internal previous value accordingly.\n  sequenceNumberHandler:\n    | ((sequenceNumber: ListenSequenceNumber) => void)\n    | null;\n}\n\n/**\n * `ListenSequence` is a monotonic sequence. It is initialized with a minimum value to\n * exceed. All subsequent calls to next will return increasing values. If provided with a\n * `SequenceNumberSyncer`, it will additionally bump its next value when told of a new value, as\n * well as write out sequence numbers that it produces via `next()`.\n */\nexport class ListenSequence {\n  static readonly INVALID: ListenSequenceNumber = -1;\n\n  private writeNewSequenceNumber?: (\n    newSequenceNumber: ListenSequenceNumber\n  ) => void;\n\n  constructor(\n    private previousValue: ListenSequenceNumber,\n    sequenceNumberSyncer?: SequenceNumberSyncer\n  ) {\n    if (sequenceNumberSyncer) {\n      sequenceNumberSyncer.sequenceNumberHandler = sequenceNumber =>\n        this.setPreviousValue(sequenceNumber);\n      this.writeNewSequenceNumber = sequenceNumber =>\n        sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);\n    }\n  }\n\n  private setPreviousValue(\n    externalPreviousValue: ListenSequenceNumber\n  ): ListenSequenceNumber {\n    this.previousValue = Math.max(externalPreviousValue, this.previousValue);\n    return this.previousValue;\n  }\n\n  next(): ListenSequenceNumber {\n    const nextValue = ++this.previousValue;\n    if (this.writeNewSequenceNumber) {\n      this.writeNewSequenceNumber(nextValue);\n    }\n    return nextValue;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert, fail } from './assert';\n\n/*\n * Implementation of an immutable SortedMap using a Left-leaning\n * Red-Black Tree, adapted from the implementation in Mugs\n * (http://mads379.github.com/mugs/) by Mads Hartmann Jensen\n * (mads379@gmail.com).\n *\n * Original paper on Left-leaning Red-Black Trees:\n *   http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf\n *\n * Invariant 1: No red node has a red child\n * Invariant 2: Every leaf path has the same number of black nodes\n * Invariant 3: Only the left child can be red (left leaning)\n */\n\nexport type Comparator<K> = (key1: K, key2: K) => number;\n\nexport interface Entry<K, V> {\n  key: K;\n  value: V;\n}\n\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nexport class SortedMap<K, V> {\n  // visible for testing\n  root: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n\n  constructor(\n    public comparator: Comparator<K>,\n    root?: LLRBNode<K, V> | LLRBEmptyNode<K, V>\n  ) {\n    this.root = root ? root : LLRBNode.EMPTY;\n  }\n\n  // Returns a copy of the map, with the specified key/value added or replaced.\n  insert(key: K, value: V): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .insert(key, value, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns a copy of the map, with the specified key removed.\n  remove(key: K): SortedMap<K, V> {\n    return new SortedMap<K, V>(\n      this.comparator,\n      this.root\n        .remove(key, this.comparator)\n        .copy(null, null, LLRBNode.BLACK, null, null)\n    );\n  }\n\n  // Returns the value of the node with the given key, or null.\n  get(key: K): V | null {\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return node.value;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else if (cmp > 0) {\n        node = node.right;\n      }\n    }\n    return null;\n  }\n\n  // Returns the index of the element in this sorted map, or -1 if it doesn't\n  // exist.\n  indexOf(key: K): number {\n    // Number of nodes that were pruned when descending right\n    let prunedNodes = 0;\n    let node = this.root;\n    while (!node.isEmpty()) {\n      const cmp = this.comparator(key, node.key);\n      if (cmp === 0) {\n        return prunedNodes + node.left.size;\n      } else if (cmp < 0) {\n        node = node.left;\n      } else {\n        // Count all nodes left of the node plus the node itself\n        prunedNodes += node.left.size + 1;\n        node = node.right;\n      }\n    }\n    // Node not found\n    return -1;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  // Returns the total number of nodes in the map.\n  get size(): number {\n    return this.root.size;\n  }\n\n  // Returns the minimum key in the map.\n  minKey(): K | null {\n    return this.root.minKey();\n  }\n\n  // Returns the maximum key in the map.\n  maxKey(): K | null {\n    return this.root.maxKey();\n  }\n\n  // Traverses the map in key order and calls the specified action function\n  // for each key/value pair. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).inorderTraversal(action);\n  }\n\n  forEach(fn: (k: K, v: V) => void): void {\n    this.inorderTraversal((k, v) => {\n      fn(k, v);\n      return false;\n    });\n  }\n\n  toString(): string {\n    const descriptions: string[] = [];\n    this.inorderTraversal((k, v) => {\n      descriptions.push(`${k}:${v}`);\n      return false;\n    });\n    return `{${descriptions.join(', ')}}`;\n  }\n\n  // Traverses the map in reverse key order and calls the specified action\n  // function for each key/value pair. If action returns true, traversal is\n  // aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (this.root as LLRBNode<K, V>).reverseTraversal(action);\n  }\n\n  // Returns an iterator over the SortedMap.\n  getIterator(): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, null, this.comparator, false);\n  }\n\n  getIteratorFrom(key: K): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, key, this.comparator, false);\n  }\n\n  getReverseIterator(): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, null, this.comparator, true);\n  }\n\n  getReverseIteratorFrom(key: K): SortedMapIterator<K, V> {\n    return new SortedMapIterator<K, V>(this.root, key, this.comparator, true);\n  }\n} // end SortedMap\n\n// An iterator over an LLRBNode.\nexport class SortedMapIterator<K, V> {\n  private isReverse: boolean;\n  private nodeStack: Array<LLRBNode<K, V> | LLRBEmptyNode<K, V>>;\n\n  constructor(\n    node: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    startKey: K | null,\n    comparator: Comparator<K>,\n    isReverse: boolean\n  ) {\n    this.isReverse = isReverse;\n    this.nodeStack = [];\n\n    let cmp = 1;\n    while (!node.isEmpty()) {\n      cmp = startKey ? comparator(node.key, startKey) : 1;\n      // flip the comparison if we're going in reverse\n      if (isReverse) {\n        cmp *= -1;\n      }\n\n      if (cmp < 0) {\n        // This node is less than our start key. ignore it\n        if (this.isReverse) {\n          node = node.left;\n        } else {\n          node = node.right;\n        }\n      } else if (cmp === 0) {\n        // This node is exactly equal to our start key. Push it on the stack,\n        // but stop iterating;\n        this.nodeStack.push(node);\n        break;\n      } else {\n        // This node is greater than our start key, add it to the stack and move\n        // to the next one\n        this.nodeStack.push(node);\n        if (this.isReverse) {\n          node = node.right;\n        } else {\n          node = node.left;\n        }\n      }\n    }\n  }\n\n  getNext(): Entry<K, V> {\n    debugAssert(\n      this.nodeStack.length > 0,\n      'getNext() called on iterator when hasNext() is false.'\n    );\n\n    let node = this.nodeStack.pop()!;\n    const result = { key: node.key, value: node.value };\n\n    if (this.isReverse) {\n      node = node.left;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.right;\n      }\n    } else {\n      node = node.right;\n      while (!node.isEmpty()) {\n        this.nodeStack.push(node);\n        node = node.left;\n      }\n    }\n\n    return result;\n  }\n\n  hasNext(): boolean {\n    return this.nodeStack.length > 0;\n  }\n\n  peek(): Entry<K, V> | null {\n    if (this.nodeStack.length === 0) {\n      return null;\n    }\n\n    const node = this.nodeStack[this.nodeStack.length - 1];\n    return { key: node.key, value: node.value };\n  }\n} // end SortedMapIterator\n\n// Represents a node in a Left-leaning Red-Black tree.\nexport class LLRBNode<K, V> {\n  readonly color: boolean;\n  readonly left: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly right: LLRBNode<K, V> | LLRBEmptyNode<K, V>;\n  readonly size: number;\n\n  // Empty node is shared between all LLRB trees.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static EMPTY: LLRBEmptyNode<any, any> = null as any;\n\n  static RED = true;\n  static BLACK = false;\n\n  constructor(\n    public key: K,\n    public value: V,\n    color?: boolean,\n    left?: LLRBNode<K, V> | LLRBEmptyNode<K, V>,\n    right?: LLRBNode<K, V> | LLRBEmptyNode<K, V>\n  ) {\n    this.color = color != null ? color : LLRBNode.RED;\n    this.left = left != null ? left : LLRBNode.EMPTY;\n    this.right = right != null ? right : LLRBNode.EMPTY;\n    this.size = this.left.size + 1 + this.right.size;\n  }\n\n  // Returns a copy of the current node, optionally replacing pieces of it.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBNode<K, V> {\n    return new LLRBNode<K, V>(\n      key != null ? key : this.key,\n      value != null ? value : this.value,\n      color != null ? color : this.color,\n      left != null ? left : this.left,\n      right != null ? right : this.right\n    );\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  // Traverses the tree in key order and calls the specified action function\n  // for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  inorderTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.left as LLRBNode<K, V>).inorderTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.right as LLRBNode<K, V>).inorderTraversal(action)\n    );\n  }\n\n  // Traverses the tree in reverse key order and calls the specified action\n  // function for each node. If action returns true, traversal is aborted.\n  // Returns the first truthy value returned by action, or the last falsey\n  // value returned by action.\n  reverseTraversal<T>(action: (k: K, v: V) => T): T {\n    return (\n      (this.right as LLRBNode<K, V>).reverseTraversal(action) ||\n      action(this.key, this.value) ||\n      (this.left as LLRBNode<K, V>).reverseTraversal(action)\n    );\n  }\n\n  // Returns the minimum node in the tree.\n  private min(): LLRBNode<K, V> {\n    if (this.left.isEmpty()) {\n      return this;\n    } else {\n      return (this.left as LLRBNode<K, V>).min();\n    }\n  }\n\n  // Returns the maximum key in the tree.\n  minKey(): K | null {\n    return this.min().key;\n  }\n\n  // Returns the maximum key in the tree.\n  maxKey(): K | null {\n    if (this.right.isEmpty()) {\n      return this.key;\n    } else {\n      return this.right.maxKey();\n    }\n  }\n\n  // Returns new tree, with the key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    let n: LLRBNode<K, V> = this;\n    const cmp = comparator(key, n.key);\n    if (cmp < 0) {\n      n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n    } else if (cmp === 0) {\n      n = n.copy(null, value, null, null, null);\n    } else {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        n.right.insert(key, value, comparator)\n      );\n    }\n    return n.fixUp();\n  }\n\n  private removeMin(): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    if (this.left.isEmpty()) {\n      return LLRBNode.EMPTY;\n    }\n    let n: LLRBNode<K, V> = this;\n    if (!n.left.isRed() && !n.left.left.isRed()) {\n      n = n.moveRedLeft();\n    }\n    n = n.copy(null, null, null, (n.left as LLRBNode<K, V>).removeMin(), null);\n    return n.fixUp();\n  }\n\n  // Returns new tree, with the specified item removed.\n  remove(\n    key: K,\n    comparator: Comparator<K>\n  ): LLRBNode<K, V> | LLRBEmptyNode<K, V> {\n    let smallest: LLRBNode<K, V>;\n    let n: LLRBNode<K, V> = this;\n    if (comparator(key, n.key) < 0) {\n      if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n        n = n.moveRedLeft();\n      }\n      n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n    } else {\n      if (n.left.isRed()) {\n        n = n.rotateRight();\n      }\n      if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n        n = n.moveRedRight();\n      }\n      if (comparator(key, n.key) === 0) {\n        if (n.right.isEmpty()) {\n          return LLRBNode.EMPTY;\n        } else {\n          smallest = (n.right as LLRBNode<K, V>).min();\n          n = n.copy(\n            smallest.key,\n            smallest.value,\n            null,\n            null,\n            (n.right as LLRBNode<K, V>).removeMin()\n          );\n        }\n      }\n      n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n    }\n    return n.fixUp();\n  }\n\n  isRed(): boolean {\n    return this.color;\n  }\n\n  // Returns new tree after performing any needed rotations.\n  private fixUp(): LLRBNode<K, V> {\n    let n: LLRBNode<K, V> = this;\n    if (n.right.isRed() && !n.left.isRed()) {\n      n = n.rotateLeft();\n    }\n    if (n.left.isRed() && n.left.left.isRed()) {\n      n = n.rotateRight();\n    }\n    if (n.left.isRed() && n.right.isRed()) {\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private moveRedLeft(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.right.left.isRed()) {\n      n = n.copy(\n        null,\n        null,\n        null,\n        null,\n        (n.right as LLRBNode<K, V>).rotateRight()\n      );\n      n = n.rotateLeft();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private moveRedRight(): LLRBNode<K, V> {\n    let n = this.colorFlip();\n    if (n.left.left.isRed()) {\n      n = n.rotateRight();\n      n = n.colorFlip();\n    }\n    return n;\n  }\n\n  private rotateLeft(): LLRBNode<K, V> {\n    const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n    return (this.right as LLRBNode<K, V>).copy(\n      null,\n      null,\n      this.color,\n      nl,\n      null\n    );\n  }\n\n  private rotateRight(): LLRBNode<K, V> {\n    const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n    return (this.left as LLRBNode<K, V>).copy(null, null, this.color, null, nr);\n  }\n\n  private colorFlip(): LLRBNode<K, V> {\n    const left = this.left.copy(null, null, !this.left.color, null, null);\n    const right = this.right.copy(null, null, !this.right.color, null, null);\n    return this.copy(null, null, !this.color, left, right);\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    const blackDepth = this.check();\n    if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // In a balanced RB tree, the black-depth (number of black nodes) from root to\n  // leaves is equal on both sides.  This function verifies that or asserts.\n  protected check(): number {\n    if (this.isRed() && this.left.isRed()) {\n      throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n    }\n    if (this.right.isRed()) {\n      throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n    }\n    const blackDepth = (this.left as LLRBNode<K, V>).check();\n    if (blackDepth !== (this.right as LLRBNode<K, V>).check()) {\n      throw fail('Black depths differ');\n    } else {\n      return blackDepth + (this.isRed() ? 0 : 1);\n    }\n  }\n} // end LLRBNode\n\n// Represents an empty node (a leaf node in the Red-Black Tree).\nexport class LLRBEmptyNode<K, V> {\n  get key(): never {\n    throw fail('LLRBEmptyNode has no key.');\n  }\n  get value(): never {\n    throw fail('LLRBEmptyNode has no value.');\n  }\n  get color(): never {\n    throw fail('LLRBEmptyNode has no color.');\n  }\n  get left(): never {\n    throw fail('LLRBEmptyNode has no left child.');\n  }\n  get right(): never {\n    throw fail('LLRBEmptyNode has no right child.');\n  }\n  size = 0;\n\n  // Returns a copy of the current node.\n  copy(\n    key: K | null,\n    value: V | null,\n    color: boolean | null,\n    left: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null,\n    right: LLRBNode<K, V> | LLRBEmptyNode<K, V> | null\n  ): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  // Returns a copy of the tree, with the specified key/value added.\n  insert(key: K, value: V, comparator: Comparator<K>): LLRBNode<K, V> {\n    return new LLRBNode<K, V>(key, value);\n  }\n\n  // Returns a copy of the tree, with the specified key removed.\n  remove(key: K, comparator: Comparator<K>): LLRBEmptyNode<K, V> {\n    return this;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  inorderTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  reverseTraversal(action: (k: K, v: V) => boolean): boolean {\n    return false;\n  }\n\n  minKey(): K | null {\n    return null;\n  }\n\n  maxKey(): K | null {\n    return null;\n  }\n\n  isRed(): boolean {\n    return false;\n  }\n\n  // For testing.\n  checkMaxDepth(): boolean {\n    return true;\n  }\n\n  protected check(): 0 {\n    return 0;\n  }\n} // end LLRBEmptyNode\n\nLLRBNode.EMPTY = new LLRBEmptyNode<unknown, unknown>();\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SortedMap, SortedMapIterator } from './sorted_map';\n\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nexport class SortedSet<T> {\n  private data: SortedMap<T, boolean>;\n\n  constructor(private comparator: (left: T, right: T) => number) {\n    this.data = new SortedMap<T, boolean>(this.comparator);\n  }\n\n  has(elem: T): boolean {\n    return this.data.get(elem) !== null;\n  }\n\n  first(): T | null {\n    return this.data.minKey();\n  }\n\n  last(): T | null {\n    return this.data.maxKey();\n  }\n\n  get size(): number {\n    return this.data.size;\n  }\n\n  indexOf(elem: T): number {\n    return this.data.indexOf(elem);\n  }\n\n  /** Iterates elements in order defined by \"comparator\" */\n  forEach(cb: (elem: T) => void): void {\n    this.data.inorderTraversal((k: T, v: boolean) => {\n      cb(k);\n      return false;\n    });\n  }\n\n  /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */\n  forEachInRange(range: [T, T], cb: (elem: T) => void): void {\n    const iter = this.data.getIteratorFrom(range[0]);\n    while (iter.hasNext()) {\n      const elem = iter.getNext();\n      if (this.comparator(elem.key, range[1]) >= 0) {\n        return;\n      }\n      cb(elem.key);\n    }\n  }\n\n  /**\n   * Iterates over `elem`s such that: start <= elem until false is returned.\n   */\n  forEachWhile(cb: (elem: T) => boolean, start?: T): void {\n    let iter: SortedMapIterator<T, boolean>;\n    if (start !== undefined) {\n      iter = this.data.getIteratorFrom(start);\n    } else {\n      iter = this.data.getIterator();\n    }\n    while (iter.hasNext()) {\n      const elem = iter.getNext();\n      const result = cb(elem.key);\n      if (!result) {\n        return;\n      }\n    }\n  }\n\n  /** Finds the least element greater than or equal to `elem`. */\n  firstAfterOrEqual(elem: T): T | null {\n    const iter = this.data.getIteratorFrom(elem);\n    return iter.hasNext() ? iter.getNext().key : null;\n  }\n\n  getIterator(): SortedSetIterator<T> {\n    return new SortedSetIterator<T>(this.data.getIterator());\n  }\n\n  getIteratorFrom(key: T): SortedSetIterator<T> {\n    return new SortedSetIterator<T>(this.data.getIteratorFrom(key));\n  }\n\n  /** Inserts or updates an element */\n  add(elem: T): SortedSet<T> {\n    return this.copy(this.data.remove(elem).insert(elem, true));\n  }\n\n  /** Deletes an element */\n  delete(elem: T): SortedSet<T> {\n    if (!this.has(elem)) {\n      return this;\n    }\n    return this.copy(this.data.remove(elem));\n  }\n\n  isEmpty(): boolean {\n    return this.data.isEmpty();\n  }\n\n  unionWith(other: SortedSet<T>): SortedSet<T> {\n    let result: SortedSet<T> = this;\n\n    // Make sure `result` always refers to the larger one of the two sets.\n    if (result.size < other.size) {\n      result = other;\n      other = this;\n    }\n\n    other.forEach(elem => {\n      result = result.add(elem);\n    });\n    return result;\n  }\n\n  isEqual(other: SortedSet<T>): boolean {\n    if (!(other instanceof SortedSet)) {\n      return false;\n    }\n    if (this.size !== other.size) {\n      return false;\n    }\n\n    const thisIt = this.data.getIterator();\n    const otherIt = other.data.getIterator();\n    while (thisIt.hasNext()) {\n      const thisElem = thisIt.getNext().key;\n      const otherElem = otherIt.getNext().key;\n      if (this.comparator(thisElem, otherElem) !== 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  toArray(): T[] {\n    const res: T[] = [];\n    this.forEach(targetId => {\n      res.push(targetId);\n    });\n    return res;\n  }\n\n  toString(): string {\n    const result: T[] = [];\n    this.forEach(elem => result.push(elem));\n    return 'SortedSet(' + result.toString() + ')';\n  }\n\n  private copy(data: SortedMap<T, boolean>): SortedSet<T> {\n    const result = new SortedSet(this.comparator);\n    result.data = data;\n    return result;\n  }\n}\n\nexport class SortedSetIterator<T> {\n  constructor(private iter: SortedMapIterator<T, boolean>) {}\n\n  getNext(): T {\n    return this.iter.getNext().key;\n  }\n\n  hasNext(): boolean {\n    return this.iter.hasNext();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from '@firebase/firestore-types';\n\n/**\n * Error Codes describing the different ways Firestore can fail. These come\n * directly from GRPC.\n */\nexport type Code = firestore.FirestoreErrorCode;\n\nexport const Code = {\n  // Causes are copied from:\n  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n  /** Not an error; returned on success. */\n  OK: 'ok' as Code,\n\n  /** The operation was cancelled (typically by the caller). */\n  CANCELLED: 'cancelled' as Code,\n\n  /** Unknown error or an error from a different error domain. */\n  UNKNOWN: 'unknown' as Code,\n\n  /**\n   * Client specified an invalid argument. Note that this differs from\n   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n   * problematic regardless of the state of the system (e.g., a malformed file\n   * name).\n   */\n  INVALID_ARGUMENT: 'invalid-argument' as Code,\n\n  /**\n   * Deadline expired before operation could complete. For operations that\n   * change the state of the system, this error may be returned even if the\n   * operation has completed successfully. For example, a successful response\n   * from a server could have been delayed long enough for the deadline to\n   * expire.\n   */\n  DEADLINE_EXCEEDED: 'deadline-exceeded' as Code,\n\n  /** Some requested entity (e.g., file or directory) was not found. */\n  NOT_FOUND: 'not-found' as Code,\n\n  /**\n   * Some entity that we attempted to create (e.g., file or directory) already\n   * exists.\n   */\n  ALREADY_EXISTS: 'already-exists' as Code,\n\n  /**\n   * The caller does not have permission to execute the specified operation.\n   * PERMISSION_DENIED must not be used for rejections caused by exhausting\n   * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n   * PERMISSION_DENIED must not be used if the caller can not be identified\n   * (use UNAUTHENTICATED instead for those errors).\n   */\n  PERMISSION_DENIED: 'permission-denied' as Code,\n\n  /**\n   * The request does not have valid authentication credentials for the\n   * operation.\n   */\n  UNAUTHENTICATED: 'unauthenticated' as Code,\n\n  /**\n   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n   * entire file system is out of space.\n   */\n  RESOURCE_EXHAUSTED: 'resource-exhausted' as Code,\n\n  /**\n   * Operation was rejected because the system is not in a state required for\n   * the operation's execution. For example, directory to be deleted may be\n   * non-empty, an rmdir operation is applied to a non-directory, etc.\n   *\n   * A litmus test that may help a service implementor in deciding\n   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n   *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n   *  (b) Use ABORTED if the client should retry at a higher-level\n   *      (e.g., restarting a read-modify-write sequence).\n   *  (c) Use FAILED_PRECONDITION if the client should not retry until\n   *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n   *      fails because the directory is non-empty, FAILED_PRECONDITION\n   *      should be returned since the client should not retry unless\n   *      they have first fixed up the directory by deleting files from it.\n   *  (d) Use FAILED_PRECONDITION if the client performs conditional\n   *      REST Get/Update/Delete on a resource and the resource on the\n   *      server does not match the condition. E.g., conflicting\n   *      read-modify-write on the same resource.\n   */\n  FAILED_PRECONDITION: 'failed-precondition' as Code,\n\n  /**\n   * The operation was aborted, typically due to a concurrency issue like\n   * sequencer check failures, transaction aborts, etc.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n   * and UNAVAILABLE.\n   */\n  ABORTED: 'aborted' as Code,\n\n  /**\n   * Operation was attempted past the valid range. E.g., seeking or reading\n   * past end of file.\n   *\n   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n   * if the system state changes. For example, a 32-bit file system will\n   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n   * an offset past the current file size.\n   *\n   * There is a fair bit of overlap between FAILED_PRECONDITION and\n   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n   * when it applies so that callers who are iterating through a space can\n   * easily look for an OUT_OF_RANGE error to detect when they are done.\n   */\n  OUT_OF_RANGE: 'out-of-range' as Code,\n\n  /** Operation is not implemented or not supported/enabled in this service. */\n  UNIMPLEMENTED: 'unimplemented' as Code,\n\n  /**\n   * Internal errors. Means some invariants expected by underlying System has\n   * been broken. If you see one of these errors, Something is very broken.\n   */\n  INTERNAL: 'internal' as Code,\n\n  /**\n   * The service is currently unavailable. This is a most likely a transient\n   * condition and may be corrected by retrying with a backoff.\n   *\n   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n   * and UNAVAILABLE.\n   */\n  UNAVAILABLE: 'unavailable' as Code,\n\n  /** Unrecoverable data loss or corruption. */\n  DATA_LOSS: 'data-loss' as Code\n};\n\n/**\n * An error class used for Firestore-generated errors. Ideally we should be\n * using FirebaseError, but integrating with it is overly arduous at the moment,\n * so we define our own compatible error class (with a `name` of 'FirebaseError'\n * and compatible `code` and `message` fields.)\n */\nexport class FirestoreError extends Error implements firestore.FirestoreError {\n  name = 'FirebaseError';\n  stack?: string;\n\n  constructor(readonly code: Code, readonly message: string) {\n    super(message);\n\n    // HACK: We write a toString property directly because Error is not a real\n    // class and so inheritance does not work correctly. We could alternatively\n    // do the same \"back-door inheritance\" trick that FirebaseError does.\n    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\n\nexport const DOCUMENT_KEY_NAME = '__name__';\n\n/**\n * Path represents an ordered sequence of string segments.\n */\nabstract class BasePath<B extends BasePath<B>> {\n  private segments: string[];\n  private offset: number;\n  private len: number;\n\n  constructor(segments: string[], offset?: number, length?: number) {\n    if (offset === undefined) {\n      offset = 0;\n    } else if (offset > segments.length) {\n      fail('offset ' + offset + ' out of range ' + segments.length);\n    }\n\n    if (length === undefined) {\n      length = segments.length - offset;\n    } else if (length > segments.length - offset) {\n      fail('length ' + length + ' out of range ' + (segments.length - offset));\n    }\n    this.segments = segments;\n    this.offset = offset;\n    this.len = length;\n  }\n\n  /**\n   * Abstract constructor method to construct an instance of B with the given\n   * parameters.\n   */\n  protected abstract construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): B;\n\n  /**\n   * Returns a String representation.\n   *\n   * Implementing classes are required to provide deterministic implementations as\n   * the String representation is used to obtain canonical Query IDs.\n   */\n  abstract toString(): string;\n\n  get length(): number {\n    return this.len;\n  }\n\n  isEqual(other: B): boolean {\n    return BasePath.comparator(this, other) === 0;\n  }\n\n  child(nameOrPath: string | B): B {\n    const segments = this.segments.slice(this.offset, this.limit());\n    if (nameOrPath instanceof BasePath) {\n      nameOrPath.forEach(segment => {\n        segments.push(segment);\n      });\n    } else {\n      segments.push(nameOrPath);\n    }\n    return this.construct(segments);\n  }\n\n  /** The index of one past the last segment of the path. */\n  private limit(): number {\n    return this.offset + this.length;\n  }\n\n  popFirst(size?: number): B {\n    size = size === undefined ? 1 : size;\n    debugAssert(\n      this.length >= size,\n      \"Can't call popFirst() with less segments\"\n    );\n    return this.construct(\n      this.segments,\n      this.offset + size,\n      this.length - size\n    );\n  }\n\n  popLast(): B {\n    debugAssert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n    return this.construct(this.segments, this.offset, this.length - 1);\n  }\n\n  firstSegment(): string {\n    debugAssert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n    return this.segments[this.offset];\n  }\n\n  lastSegment(): string {\n    return this.get(this.length - 1);\n  }\n\n  get(index: number): string {\n    debugAssert(index < this.length, 'Index out of range');\n    return this.segments[this.offset + index];\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  isPrefixOf(other: this): boolean {\n    if (other.length < this.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== other.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  isImmediateParentOf(potentialChild: this): boolean {\n    if (this.length + 1 !== potentialChild.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (this.get(i) !== potentialChild.get(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  forEach(fn: (segment: string) => void): void {\n    for (let i = this.offset, end = this.limit(); i < end; i++) {\n      fn(this.segments[i]);\n    }\n  }\n\n  toArray(): string[] {\n    return this.segments.slice(this.offset, this.limit());\n  }\n\n  static comparator<T extends BasePath<T>>(\n    p1: BasePath<T>,\n    p2: BasePath<T>\n  ): number {\n    const len = Math.min(p1.length, p2.length);\n    for (let i = 0; i < len; i++) {\n      const left = p1.get(i);\n      const right = p2.get(i);\n      if (left < right) {\n        return -1;\n      }\n      if (left > right) {\n        return 1;\n      }\n    }\n    if (p1.length < p2.length) {\n      return -1;\n    }\n    if (p1.length > p2.length) {\n      return 1;\n    }\n    return 0;\n  }\n}\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nexport class ResourcePath extends BasePath<ResourcePath> {\n  protected construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): ResourcePath {\n    return new ResourcePath(segments, offset, length);\n  }\n\n  canonicalString(): string {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    return this.toArray().join('/');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Creates a resource path from the given slash-delimited string.\n   */\n  static fromString(path: string): ResourcePath {\n    // NOTE: The client is ignorant of any path segments containing escape\n    // sequences (e.g. __id123__) and just passes them through raw (they exist\n    // for legacy reasons and should not be used frequently).\n\n    if (path.indexOf('//') >= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid path (${path}). Paths must not contain // in them.`\n      );\n    }\n\n    // We may still have an empty segment at the beginning or end if they had a\n    // leading or trailing slash (which we allow).\n    const segments = path.split('/').filter(segment => segment.length > 0);\n\n    return new ResourcePath(segments);\n  }\n\n  static EMPTY_PATH = new ResourcePath([]);\n}\n\nconst identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n\n/** A dot-separated path for navigating sub-objects within a document. */\nexport class FieldPath extends BasePath<FieldPath> {\n  protected construct(\n    segments: string[],\n    offset?: number,\n    length?: number\n  ): FieldPath {\n    return new FieldPath(segments, offset, length);\n  }\n\n  /**\n   * Returns true if the string could be used as a segment in a field path\n   * without escaping.\n   */\n  private static isValidIdentifier(segment: string): boolean {\n    return identifierRegExp.test(segment);\n  }\n\n  canonicalString(): string {\n    return this.toArray()\n      .map(str => {\n        str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n        if (!FieldPath.isValidIdentifier(str)) {\n          str = '`' + str + '`';\n        }\n        return str;\n      })\n      .join('.');\n  }\n\n  toString(): string {\n    return this.canonicalString();\n  }\n\n  /**\n   * Returns true if this field references the key of a document.\n   */\n  isKeyField(): boolean {\n    return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n  }\n\n  /**\n   * The field designating the key of a document.\n   */\n  static keyField(): FieldPath {\n    return new FieldPath([DOCUMENT_KEY_NAME]);\n  }\n\n  /**\n   * Parses a field string from the given server-formatted string.\n   *\n   * - Splitting the empty string is not allowed (for now at least).\n   * - Empty segments within the string (e.g. if there are two consecutive\n   *   separators) are not allowed.\n   *\n   * TODO(b/37244157): we should make this more strict. Right now, it allows\n   * non-identifier path components, even if they aren't escaped.\n   */\n  static fromServerFormat(path: string): FieldPath {\n    const segments: string[] = [];\n    let current = '';\n    let i = 0;\n\n    const addCurrentSegment = (): void => {\n      if (current.length === 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid field path (${path}). Paths must not be empty, begin ` +\n            `with '.', end with '.', or contain '..'`\n        );\n      }\n      segments.push(current);\n      current = '';\n    };\n\n    let inBackticks = false;\n\n    while (i < path.length) {\n      const c = path[i];\n      if (c === '\\\\') {\n        if (i + 1 === path.length) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has trailing escape character: ' + path\n          );\n        }\n        const next = path[i + 1];\n        if (!(next === '\\\\' || next === '.' || next === '`')) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Path has invalid escape sequence: ' + path\n          );\n        }\n        current += next;\n        i += 2;\n      } else if (c === '`') {\n        inBackticks = !inBackticks;\n        i++;\n      } else if (c === '.' && !inBackticks) {\n        addCurrentSegment();\n        i++;\n      } else {\n        current += c;\n        i++;\n      }\n    }\n    addCurrentSegment();\n\n    if (inBackticks) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Unterminated ` in path: ' + path\n      );\n    }\n\n    return new FieldPath(segments);\n  }\n\n  static EMPTY_PATH = new FieldPath([]);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from '../util/assert';\n\nimport { ResourcePath } from './path';\n\nexport class DocumentKey {\n  constructor(readonly path: ResourcePath) {\n    debugAssert(\n      DocumentKey.isDocumentKey(path),\n      'Invalid DocumentKey with an odd number of segments: ' +\n        path.toArray().join('/')\n    );\n  }\n\n  static fromName(name: string): DocumentKey {\n    return new DocumentKey(ResourcePath.fromString(name).popFirst(5));\n  }\n\n  /** Returns true if the document is in the specified collectionId. */\n  hasCollectionId(collectionId: string): boolean {\n    return (\n      this.path.length >= 2 &&\n      this.path.get(this.path.length - 2) === collectionId\n    );\n  }\n\n  isEqual(other: DocumentKey | null): boolean {\n    return (\n      other !== null && ResourcePath.comparator(this.path, other.path) === 0\n    );\n  }\n\n  toString(): string {\n    return this.path.toString();\n  }\n\n  static EMPTY = new DocumentKey(new ResourcePath([]));\n\n  static comparator(k1: DocumentKey, k2: DocumentKey): number {\n    return ResourcePath.comparator(k1.path, k2.path);\n  }\n\n  static isDocumentKey(path: ResourcePath): boolean {\n    return path.length % 2 === 0;\n  }\n\n  /**\n   * Creates and returns a new document key with the given segments.\n   *\n   * @param segments The segments of the path to the document\n   * @return A new instance of DocumentKey\n   */\n  static fromSegments(segments: string[]): DocumentKey {\n    return new DocumentKey(new ResourcePath(segments.slice()));\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { SortedMap } from '../util/sorted_map';\nimport { SortedSet } from '../util/sorted_set';\n\nimport { TargetId } from '../core/types';\nimport { primitiveComparator } from '../util/misc';\nimport { Document, MaybeDocument } from './document';\nimport { DocumentKey } from './document_key';\n\n/** Miscellaneous collection types / constants. */\nexport interface DocumentSizeEntry {\n  maybeDocument: MaybeDocument;\n  size: number;\n}\n\nexport type MaybeDocumentMap = SortedMap<DocumentKey, MaybeDocument>;\nconst EMPTY_MAYBE_DOCUMENT_MAP = new SortedMap<DocumentKey, MaybeDocument>(\n  DocumentKey.comparator\n);\nexport function maybeDocumentMap(): MaybeDocumentMap {\n  return EMPTY_MAYBE_DOCUMENT_MAP;\n}\n\nexport type NullableMaybeDocumentMap = SortedMap<\n  DocumentKey,\n  MaybeDocument | null\n>;\n\nexport function nullableMaybeDocumentMap(): NullableMaybeDocumentMap {\n  return maybeDocumentMap();\n}\n\nexport interface DocumentSizeEntries {\n  maybeDocuments: NullableMaybeDocumentMap;\n  sizeMap: SortedMap<DocumentKey, number>;\n}\n\nexport type DocumentMap = SortedMap<DocumentKey, Document>;\nconst EMPTY_DOCUMENT_MAP = new SortedMap<DocumentKey, Document>(\n  DocumentKey.comparator\n);\nexport function documentMap(): DocumentMap {\n  return EMPTY_DOCUMENT_MAP;\n}\n\nexport type DocumentVersionMap = SortedMap<DocumentKey, SnapshotVersion>;\nconst EMPTY_DOCUMENT_VERSION_MAP = new SortedMap<DocumentKey, SnapshotVersion>(\n  DocumentKey.comparator\n);\nexport function documentVersionMap(): DocumentVersionMap {\n  return EMPTY_DOCUMENT_VERSION_MAP;\n}\n\nexport type DocumentKeySet = SortedSet<DocumentKey>;\nconst EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nexport function documentKeySet(...keys: DocumentKey[]): DocumentKeySet {\n  let set = EMPTY_DOCUMENT_KEY_SET;\n  for (const key of keys) {\n    set = set.add(key);\n  }\n  return set;\n}\n\nexport type TargetIdSet = SortedSet<TargetId>;\nconst EMPTY_TARGET_ID_SET = new SortedSet<TargetId>(primitiveComparator);\nexport function targetIdSet(): SortedSet<TargetId> {\n  return EMPTY_TARGET_ID_SET;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// An Object whose keys and values are strings.\nexport interface StringMap {\n  [key: string]: string;\n}\n\n/**\n * Returns whether a variable is either undefined or null.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/** Returns whether the value represents -0. */\nexport function isNegativeZero(value: number): boolean {\n  // Detect if the value is -0.0. Based on polyfill from\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  return value === -0 && 1 / value === 1 / -0;\n}\n\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value The value to test for being an integer and in the safe range\n */\nexport function isSafeInteger(value: unknown): boolean {\n  return (\n    typeof value === 'number' &&\n    Number.isInteger(value) &&\n    !isNegativeZero(value) &&\n    value <= Number.MAX_SAFE_INTEGER &&\n    value >= Number.MIN_SAFE_INTEGER\n  );\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { ListenSequence } from '../core/listen_sequence';\nimport {\n  BatchId,\n  ListenSequenceNumber,\n  MutationBatchState,\n  OnlineState,\n  TargetId\n} from '../core/types';\nimport { TargetIdSet, targetIdSet } from '../model/collections';\nimport { Platform } from '../platform/platform';\nimport { hardAssert, debugAssert } from '../util/assert';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { logError, logDebug } from '../util/log';\nimport { SortedSet } from '../util/sorted_set';\nimport { SortedMap } from '../util/sorted_map';\nimport { primitiveComparator } from '../util/misc';\nimport { isSafeInteger } from '../util/types';\nimport {\n  QueryTargetState,\n  SharedClientStateSyncer\n} from './shared_client_state_syncer';\nimport {\n  CLIENT_STATE_KEY_PREFIX,\n  ClientStateSchema,\n  createWebStorageClientStateKey,\n  createWebStorageMutationBatchKey,\n  createWebStorageOnlineStateKey,\n  createWebStorageQueryTargetMetadataKey,\n  createWebStorageSequenceNumberKey,\n  MUTATION_BATCH_KEY_PREFIX,\n  MutationMetadataSchema,\n  QUERY_TARGET_KEY_PREFIX,\n  QueryTargetStateSchema,\n  SharedOnlineStateSchema\n} from './shared_client_state_schema';\n\nconst LOG_TAG = 'SharedClientState';\n\n/**\n * A randomly-generated key assigned to each Firestore instance at startup.\n */\nexport type ClientId = string;\n\n/**\n * A `SharedClientState` keeps track of the global state of the mutations\n * and query targets for all active clients with the same persistence key (i.e.\n * project ID and FirebaseApp name). It relays local changes to other clients\n * and updates its local state as new state is observed.\n *\n * `SharedClientState` is primarily used for synchronization in Multi-Tab\n * environments. Each tab is responsible for registering its active query\n * targets and mutations. `SharedClientState` will then notify the listener\n * assigned to `.syncEngine` for updates to mutations and queries that\n * originated in other clients.\n *\n * To receive notifications, `.syncEngine` and `.onlineStateHandler` has to be\n * assigned before calling `start()`.\n */\nexport interface SharedClientState {\n  syncEngine: SharedClientStateSyncer | null;\n  onlineStateHandler: ((onlineState: OnlineState) => void) | null;\n  sequenceNumberHandler:\n    | ((sequenceNumber: ListenSequenceNumber) => void)\n    | null;\n\n  /** Registers the Mutation Batch ID of a newly pending mutation. */\n  addPendingMutation(batchId: BatchId): void;\n\n  /**\n   * Records that a pending mutation has been acknowledged or rejected.\n   * Called by the primary client to notify secondary clients of mutation\n   * results as they come back from the backend.\n   */\n  updateMutationState(\n    batchId: BatchId,\n    state: 'acknowledged' | 'rejected',\n    error?: FirestoreError\n  ): void;\n\n  /**\n   * Associates a new Query Target ID with the local Firestore client. Returns\n   * the new query state for the query (which can be 'current' if the query is\n   * already associated with another tab).\n   *\n   * If the target id is already associated with local client, the method simply\n   * returns its `QueryTargetState`.\n   */\n  addLocalQueryTarget(targetId: TargetId): QueryTargetState;\n\n  /** Removes the Query Target ID association from the local client. */\n  removeLocalQueryTarget(targetId: TargetId): void;\n\n  /** Checks whether the target is associated with the local client. */\n  isLocalQueryTarget(targetId: TargetId): boolean;\n\n  /**\n   * Processes an update to a query target.\n   *\n   * Called by the primary client to notify secondary clients of document\n   * changes or state transitions that affect the provided query target.\n   */\n  updateQueryState(\n    targetId: TargetId,\n    state: QueryTargetState,\n    error?: FirestoreError\n  ): void;\n\n  /**\n   * Removes the target's metadata entry.\n   *\n   * Called by the primary client when all clients stopped listening to a query\n   * target.\n   */\n  clearQueryState(targetId: TargetId): void;\n\n  /**\n   * Gets the active Query Targets IDs for all active clients.\n   *\n   * The implementation for this may require O(n) runtime, where 'n' is the size\n   * of the result set.\n   */\n  // Visible for testing\n  getAllActiveQueryTargets(): SortedSet<TargetId>;\n\n  /**\n   * Checks whether the provided target ID is currently being listened to by\n   * any of the active clients.\n   *\n   * The implementation may require O(n*log m) runtime, where 'n' is the number\n   * of clients and 'm' the number of targets.\n   */\n  isActiveQueryTarget(targetId: TargetId): boolean;\n\n  /**\n   * Starts the SharedClientState, reads existing client data and registers\n   * listeners for updates to new and existing clients.\n   */\n  start(): Promise<void>;\n\n  /** Shuts down the `SharedClientState` and its listeners. */\n  shutdown(): void;\n\n  /**\n   * Changes the active user and removes all existing user-specific data. The\n   * user change does not call back into SyncEngine (for example, no mutations\n   * will be marked as removed).\n   */\n  handleUserChange(\n    user: User,\n    removedBatchIds: BatchId[],\n    addedBatchIds: BatchId[]\n  ): void;\n\n  /** Changes the shared online state of all clients. */\n  setOnlineState(onlineState: OnlineState): void;\n\n  writeSequenceNumber(sequenceNumber: ListenSequenceNumber): void;\n}\n\n/**\n * Holds the state of a mutation batch, including its user ID, batch ID and\n * whether the batch is 'pending', 'acknowledged' or 'rejected'.\n */\n// Visible for testing\nexport class MutationMetadata {\n  constructor(\n    readonly user: User,\n    readonly batchId: BatchId,\n    readonly state: MutationBatchState,\n    readonly error?: FirestoreError\n  ) {\n    debugAssert(\n      (error !== undefined) === (state === 'rejected'),\n      `MutationMetadata must contain an error iff state is 'rejected'`\n    );\n  }\n\n  /**\n   * Parses a MutationMetadata from its JSON representation in WebStorage.\n   * Logs a warning and returns null if the format of the data is not valid.\n   */\n  static fromWebStorageEntry(\n    user: User,\n    batchId: BatchId,\n    value: string\n  ): MutationMetadata | null {\n    const mutationBatch = JSON.parse(value) as MutationMetadataSchema;\n\n    let validData =\n      typeof mutationBatch === 'object' &&\n      ['pending', 'acknowledged', 'rejected'].indexOf(mutationBatch.state) !==\n        -1 &&\n      (mutationBatch.error === undefined ||\n        typeof mutationBatch.error === 'object');\n\n    let firestoreError: FirestoreError | undefined = undefined;\n\n    if (validData && mutationBatch.error) {\n      validData =\n        typeof mutationBatch.error.message === 'string' &&\n        typeof mutationBatch.error.code === 'string';\n      if (validData) {\n        firestoreError = new FirestoreError(\n          mutationBatch.error.code as Code,\n          mutationBatch.error.message\n        );\n      }\n    }\n\n    if (validData) {\n      return new MutationMetadata(\n        user,\n        batchId,\n        mutationBatch.state,\n        firestoreError\n      );\n    } else {\n      logError(\n        LOG_TAG,\n        `Failed to parse mutation state for ID '${batchId}': ${value}`\n      );\n      return null;\n    }\n  }\n\n  toWebStorageJSON(): string {\n    const batchMetadata: MutationMetadataSchema = {\n      state: this.state,\n      updateTimeMs: Date.now() // Modify the existing value to trigger update.\n    };\n\n    if (this.error) {\n      batchMetadata.error = {\n        code: this.error.code,\n        message: this.error.message\n      };\n    }\n\n    return JSON.stringify(batchMetadata);\n  }\n}\n\n/**\n * Holds the state of a query target, including its target ID and whether the\n * target is 'not-current', 'current' or 'rejected'.\n */\n// Visible for testing\nexport class QueryTargetMetadata {\n  constructor(\n    readonly targetId: TargetId,\n    readonly state: QueryTargetState,\n    readonly error?: FirestoreError\n  ) {\n    debugAssert(\n      (error !== undefined) === (state === 'rejected'),\n      `QueryTargetMetadata must contain an error iff state is 'rejected'`\n    );\n  }\n\n  /**\n   * Parses a QueryTargetMetadata from its JSON representation in WebStorage.\n   * Logs a warning and returns null if the format of the data is not valid.\n   */\n  static fromWebStorageEntry(\n    targetId: TargetId,\n    value: string\n  ): QueryTargetMetadata | null {\n    const targetState = JSON.parse(value) as QueryTargetStateSchema;\n\n    let validData =\n      typeof targetState === 'object' &&\n      ['not-current', 'current', 'rejected'].indexOf(targetState.state) !==\n        -1 &&\n      (targetState.error === undefined ||\n        typeof targetState.error === 'object');\n\n    let firestoreError: FirestoreError | undefined = undefined;\n\n    if (validData && targetState.error) {\n      validData =\n        typeof targetState.error.message === 'string' &&\n        typeof targetState.error.code === 'string';\n      if (validData) {\n        firestoreError = new FirestoreError(\n          targetState.error.code as Code,\n          targetState.error.message\n        );\n      }\n    }\n\n    if (validData) {\n      return new QueryTargetMetadata(\n        targetId,\n        targetState.state,\n        firestoreError\n      );\n    } else {\n      logError(\n        LOG_TAG,\n        `Failed to parse target state for ID '${targetId}': ${value}`\n      );\n      return null;\n    }\n  }\n\n  toWebStorageJSON(): string {\n    const targetState: QueryTargetStateSchema = {\n      state: this.state,\n      updateTimeMs: Date.now() // Modify the existing value to trigger update.\n    };\n\n    if (this.error) {\n      targetState.error = {\n        code: this.error.code,\n        message: this.error.message\n      };\n    }\n\n    return JSON.stringify(targetState);\n  }\n}\n\n/**\n * Metadata state of a single client denoting the query targets it is actively\n * listening to.\n */\n// Visible for testing.\nexport interface ClientState {\n  readonly activeTargetIds: TargetIdSet;\n}\n\n/**\n * This class represents the immutable ClientState for a client read from\n * WebStorage, containing the list of active query targets.\n */\nclass RemoteClientState implements ClientState {\n  private constructor(\n    readonly clientId: ClientId,\n    readonly activeTargetIds: TargetIdSet\n  ) {}\n\n  /**\n   * Parses a RemoteClientState from the JSON representation in WebStorage.\n   * Logs a warning and returns null if the format of the data is not valid.\n   */\n  static fromWebStorageEntry(\n    clientId: ClientId,\n    value: string\n  ): RemoteClientState | null {\n    const clientState = JSON.parse(value) as ClientStateSchema;\n\n    let validData =\n      typeof clientState === 'object' &&\n      clientState.activeTargetIds instanceof Array;\n\n    let activeTargetIdsSet = targetIdSet();\n\n    for (let i = 0; validData && i < clientState.activeTargetIds.length; ++i) {\n      validData = isSafeInteger(clientState.activeTargetIds[i]);\n      activeTargetIdsSet = activeTargetIdsSet.add(\n        clientState.activeTargetIds[i]\n      );\n    }\n\n    if (validData) {\n      return new RemoteClientState(clientId, activeTargetIdsSet);\n    } else {\n      logError(\n        LOG_TAG,\n        `Failed to parse client data for instance '${clientId}': ${value}`\n      );\n      return null;\n    }\n  }\n}\n\n/**\n * This class represents the online state for all clients participating in\n * multi-tab. The online state is only written to by the primary client, and\n * used in secondary clients to update their query views.\n */\nexport class SharedOnlineState {\n  constructor(readonly clientId: string, readonly onlineState: OnlineState) {}\n\n  /**\n   * Parses a SharedOnlineState from its JSON representation in WebStorage.\n   * Logs a warning and returns null if the format of the data is not valid.\n   */\n  static fromWebStorageEntry(value: string): SharedOnlineState | null {\n    const onlineState = JSON.parse(value) as SharedOnlineStateSchema;\n\n    const validData =\n      typeof onlineState === 'object' &&\n      ['Unknown', 'Online', 'Offline'].indexOf(onlineState.onlineState) !==\n        -1 &&\n      typeof onlineState.clientId === 'string';\n\n    if (validData) {\n      return new SharedOnlineState(\n        onlineState.clientId,\n        onlineState.onlineState as OnlineState\n      );\n    } else {\n      logError(LOG_TAG, `Failed to parse online state: ${value}`);\n      return null;\n    }\n  }\n}\n\n/**\n * Metadata state of the local client. Unlike `RemoteClientState`, this class is\n * mutable and keeps track of all pending mutations, which allows us to\n * update the range of pending mutation batch IDs as new mutations are added or\n * removed.\n *\n * The data in `LocalClientState` is not read from WebStorage and instead\n * updated via its instance methods. The updated state can be serialized via\n * `toWebStorageJSON()`.\n */\n// Visible for testing.\nexport class LocalClientState implements ClientState {\n  activeTargetIds = targetIdSet();\n\n  addQueryTarget(targetId: TargetId): void {\n    this.activeTargetIds = this.activeTargetIds.add(targetId);\n  }\n\n  removeQueryTarget(targetId: TargetId): void {\n    this.activeTargetIds = this.activeTargetIds.delete(targetId);\n  }\n\n  /**\n   * Converts this entry into a JSON-encoded format we can use for WebStorage.\n   * Does not encode `clientId` as it is part of the key in WebStorage.\n   */\n  toWebStorageJSON(): string {\n    const data: ClientStateSchema = {\n      activeTargetIds: this.activeTargetIds.toArray(),\n      updateTimeMs: Date.now() // Modify the existing value to trigger update.\n    };\n    return JSON.stringify(data);\n  }\n}\n\n/**\n * `WebStorageSharedClientState` uses WebStorage (window.localStorage) as the\n * backing store for the SharedClientState. It keeps track of all active\n * clients and supports modifications of the local client's data.\n */\nexport class WebStorageSharedClientState implements SharedClientState {\n  syncEngine: SharedClientStateSyncer | null = null;\n  onlineStateHandler: ((onlineState: OnlineState) => void) | null = null;\n  sequenceNumberHandler:\n    | ((sequenceNumber: ListenSequenceNumber) => void)\n    | null = null;\n\n  private readonly storage: Storage;\n  private readonly localClientStorageKey: string;\n  private readonly sequenceNumberKey: string;\n  private readonly storageListener = this.handleWebStorageEvent.bind(this);\n  private readonly onlineStateKey: string;\n  private readonly clientStateKeyRe: RegExp;\n  private readonly mutationBatchKeyRe: RegExp;\n  private readonly queryTargetKeyRe: RegExp;\n  private activeClients = new SortedMap<string, ClientState>(\n    primitiveComparator\n  );\n  private started = false;\n  private currentUser: User;\n\n  /**\n   * Captures WebStorage events that occur before `start()` is called. These\n   * events are replayed once `WebStorageSharedClientState` is started.\n   */\n  private earlyEvents: StorageEvent[] = [];\n\n  constructor(\n    private readonly queue: AsyncQueue,\n    private readonly platform: Platform,\n    private readonly persistenceKey: string,\n    private readonly localClientId: ClientId,\n    initialUser: User\n  ) {\n    if (!WebStorageSharedClientState.isAvailable(this.platform)) {\n      throw new FirestoreError(\n        Code.UNIMPLEMENTED,\n        'LocalStorage is not available on this platform.'\n      );\n    }\n    // Escape the special characters mentioned here:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n    const escapedPersistenceKey = persistenceKey.replace(\n      /[.*+?^${}()|[\\]\\\\]/g,\n      '\\\\$&'\n    );\n\n    this.storage = this.platform.window!.localStorage;\n    this.currentUser = initialUser;\n    this.localClientStorageKey = createWebStorageClientStateKey(\n      this.persistenceKey,\n      this.localClientId\n    );\n    this.sequenceNumberKey = createWebStorageSequenceNumberKey(\n      this.persistenceKey\n    );\n    this.activeClients = this.activeClients.insert(\n      this.localClientId,\n      new LocalClientState()\n    );\n\n    this.clientStateKeyRe = new RegExp(\n      `^${CLIENT_STATE_KEY_PREFIX}_${escapedPersistenceKey}_([^_]*)$`\n    );\n    this.mutationBatchKeyRe = new RegExp(\n      `^${MUTATION_BATCH_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)(?:_(.*))?$`\n    );\n    this.queryTargetKeyRe = new RegExp(\n      `^${QUERY_TARGET_KEY_PREFIX}_${escapedPersistenceKey}_(\\\\d+)$`\n    );\n\n    this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);\n\n    // Rather than adding the storage observer during start(), we add the\n    // storage observer during initialization. This ensures that we collect\n    // events before other components populate their initial state (during their\n    // respective start() calls). Otherwise, we might for example miss a\n    // mutation that is added after LocalStore's start() processed the existing\n    // mutations but before we observe WebStorage events.\n    this.platform.window!.addEventListener('storage', this.storageListener);\n  }\n\n  /** Returns 'true' if WebStorage is available in the current environment. */\n  static isAvailable(platform: Platform): boolean {\n    return !!(platform.window && platform.window.localStorage != null);\n  }\n\n  async start(): Promise<void> {\n    debugAssert(!this.started, 'WebStorageSharedClientState already started');\n    debugAssert(\n      this.syncEngine !== null,\n      'syncEngine property must be set before calling start()'\n    );\n    debugAssert(\n      this.onlineStateHandler !== null,\n      'onlineStateHandler property must be set before calling start()'\n    );\n\n    // Retrieve the list of existing clients to backfill the data in\n    // SharedClientState.\n    const existingClients = await this.syncEngine!.getActiveClients();\n\n    for (const clientId of existingClients) {\n      if (clientId === this.localClientId) {\n        continue;\n      }\n\n      const storageItem = this.getItem(\n        createWebStorageClientStateKey(this.persistenceKey, clientId)\n      );\n      if (storageItem) {\n        const clientState = RemoteClientState.fromWebStorageEntry(\n          clientId,\n          storageItem\n        );\n        if (clientState) {\n          this.activeClients = this.activeClients.insert(\n            clientState.clientId,\n            clientState\n          );\n        }\n      }\n    }\n\n    this.persistClientState();\n\n    // Check if there is an existing online state and call the callback handler\n    // if applicable.\n    const onlineStateJSON = this.storage.getItem(this.onlineStateKey);\n    if (onlineStateJSON) {\n      const onlineState = this.fromWebStorageOnlineState(onlineStateJSON);\n      if (onlineState) {\n        this.handleOnlineStateEvent(onlineState);\n      }\n    }\n\n    for (const event of this.earlyEvents) {\n      this.handleWebStorageEvent(event);\n    }\n\n    this.earlyEvents = [];\n\n    // Register a window unload hook to remove the client metadata entry from\n    // WebStorage even if `shutdown()` was not called.\n    this.platform.window!.addEventListener('unload', () => this.shutdown());\n\n    this.started = true;\n  }\n\n  writeSequenceNumber(sequenceNumber: ListenSequenceNumber): void {\n    this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));\n  }\n\n  getAllActiveQueryTargets(): TargetIdSet {\n    return this.extractActiveQueryTargets(this.activeClients);\n  }\n\n  isActiveQueryTarget(targetId: TargetId): boolean {\n    let found = false;\n    this.activeClients.forEach((key, value) => {\n      if (value.activeTargetIds.has(targetId)) {\n        found = true;\n      }\n    });\n    return found;\n  }\n\n  addPendingMutation(batchId: BatchId): void {\n    this.persistMutationState(batchId, 'pending');\n  }\n\n  updateMutationState(\n    batchId: BatchId,\n    state: 'acknowledged' | 'rejected',\n    error?: FirestoreError\n  ): void {\n    this.persistMutationState(batchId, state, error);\n\n    // Once a final mutation result is observed by other clients, they no longer\n    // access the mutation's metadata entry. Since WebStorage replays events\n    // in order, it is safe to delete the entry right after updating it.\n    this.removeMutationState(batchId);\n  }\n\n  addLocalQueryTarget(targetId: TargetId): QueryTargetState {\n    let queryState: QueryTargetState = 'not-current';\n\n    // Lookup an existing query state if the target ID was already registered\n    // by another tab\n    if (this.isActiveQueryTarget(targetId)) {\n      const storageItem = this.storage.getItem(\n        createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId)\n      );\n\n      if (storageItem) {\n        const metadata = QueryTargetMetadata.fromWebStorageEntry(\n          targetId,\n          storageItem\n        );\n        if (metadata) {\n          queryState = metadata.state;\n        }\n      }\n    }\n\n    this.localClientState.addQueryTarget(targetId);\n    this.persistClientState();\n\n    return queryState;\n  }\n\n  removeLocalQueryTarget(targetId: TargetId): void {\n    this.localClientState.removeQueryTarget(targetId);\n    this.persistClientState();\n  }\n\n  isLocalQueryTarget(targetId: TargetId): boolean {\n    return this.localClientState.activeTargetIds.has(targetId);\n  }\n\n  clearQueryState(targetId: TargetId): void {\n    this.removeItem(\n      createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId)\n    );\n  }\n\n  updateQueryState(\n    targetId: TargetId,\n    state: QueryTargetState,\n    error?: FirestoreError\n  ): void {\n    this.persistQueryTargetState(targetId, state, error);\n  }\n\n  handleUserChange(\n    user: User,\n    removedBatchIds: BatchId[],\n    addedBatchIds: BatchId[]\n  ): void {\n    removedBatchIds.forEach(batchId => {\n      this.removeMutationState(batchId);\n    });\n    this.currentUser = user;\n    addedBatchIds.forEach(batchId => {\n      this.addPendingMutation(batchId);\n    });\n  }\n\n  setOnlineState(onlineState: OnlineState): void {\n    this.persistOnlineState(onlineState);\n  }\n\n  shutdown(): void {\n    if (this.started) {\n      this.platform.window!.removeEventListener(\n        'storage',\n        this.storageListener\n      );\n      this.removeItem(this.localClientStorageKey);\n      this.started = false;\n    }\n  }\n\n  private getItem(key: string): string | null {\n    const value = this.storage.getItem(key);\n    logDebug(LOG_TAG, 'READ', key, value);\n    return value;\n  }\n\n  private setItem(key: string, value: string): void {\n    logDebug(LOG_TAG, 'SET', key, value);\n    this.storage.setItem(key, value);\n  }\n\n  private removeItem(key: string): void {\n    logDebug(LOG_TAG, 'REMOVE', key);\n    this.storage.removeItem(key);\n  }\n\n  private handleWebStorageEvent(event: StorageEvent): void {\n    if (event.storageArea === this.storage) {\n      logDebug(LOG_TAG, 'EVENT', event.key, event.newValue);\n\n      if (event.key === this.localClientStorageKey) {\n        logError(\n          'Received WebStorage notification for local change. Another client might have ' +\n            'garbage-collected our state'\n        );\n        return;\n      }\n\n      this.queue.enqueueRetryable(async () => {\n        if (!this.started) {\n          this.earlyEvents.push(event);\n          return;\n        }\n\n        if (event.key === null) {\n          return;\n        }\n\n        if (this.clientStateKeyRe.test(event.key)) {\n          if (event.newValue != null) {\n            const clientState = this.fromWebStorageClientState(\n              event.key,\n              event.newValue\n            );\n            if (clientState) {\n              return this.handleClientStateEvent(\n                clientState.clientId,\n                clientState\n              );\n            }\n          } else {\n            const clientId = this.fromWebStorageClientStateKey(event.key)!;\n            return this.handleClientStateEvent(clientId, null);\n          }\n        } else if (this.mutationBatchKeyRe.test(event.key)) {\n          if (event.newValue !== null) {\n            const mutationMetadata = this.fromWebStorageMutationMetadata(\n              event.key,\n              event.newValue\n            );\n            if (mutationMetadata) {\n              return this.handleMutationBatchEvent(mutationMetadata);\n            }\n          }\n        } else if (this.queryTargetKeyRe.test(event.key)) {\n          if (event.newValue !== null) {\n            const queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(\n              event.key,\n              event.newValue\n            );\n            if (queryTargetMetadata) {\n              return this.handleQueryTargetEvent(queryTargetMetadata);\n            }\n          }\n        } else if (event.key === this.onlineStateKey) {\n          if (event.newValue !== null) {\n            const onlineState = this.fromWebStorageOnlineState(event.newValue);\n            if (onlineState) {\n              return this.handleOnlineStateEvent(onlineState);\n            }\n          }\n        } else if (event.key === this.sequenceNumberKey) {\n          debugAssert(\n            !!this.sequenceNumberHandler,\n            'Missing sequenceNumberHandler'\n          );\n          const sequenceNumber = fromWebStorageSequenceNumber(event.newValue);\n          if (sequenceNumber !== ListenSequence.INVALID) {\n            this.sequenceNumberHandler!(sequenceNumber);\n          }\n        }\n      });\n    }\n  }\n\n  private get localClientState(): LocalClientState {\n    return this.activeClients.get(this.localClientId) as LocalClientState;\n  }\n\n  private persistClientState(): void {\n    this.setItem(\n      this.localClientStorageKey,\n      this.localClientState.toWebStorageJSON()\n    );\n  }\n\n  private persistMutationState(\n    batchId: BatchId,\n    state: MutationBatchState,\n    error?: FirestoreError\n  ): void {\n    const mutationState = new MutationMetadata(\n      this.currentUser,\n      batchId,\n      state,\n      error\n    );\n    const mutationKey = createWebStorageMutationBatchKey(\n      this.persistenceKey,\n      this.currentUser,\n      batchId\n    );\n    this.setItem(mutationKey, mutationState.toWebStorageJSON());\n  }\n\n  private removeMutationState(batchId: BatchId): void {\n    const mutationKey = createWebStorageMutationBatchKey(\n      this.persistenceKey,\n      this.currentUser,\n      batchId\n    );\n    this.removeItem(mutationKey);\n  }\n\n  private persistOnlineState(onlineState: OnlineState): void {\n    const entry: SharedOnlineStateSchema = {\n      clientId: this.localClientId,\n      onlineState\n    };\n    this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));\n  }\n\n  private persistQueryTargetState(\n    targetId: TargetId,\n    state: QueryTargetState,\n    error?: FirestoreError\n  ): void {\n    const targetKey = createWebStorageQueryTargetMetadataKey(\n      this.persistenceKey,\n      targetId\n    );\n    const targetMetadata = new QueryTargetMetadata(targetId, state, error);\n    this.setItem(targetKey, targetMetadata.toWebStorageJSON());\n  }\n\n  /**\n   * Parses a client state key in WebStorage. Returns null if the key does not\n   * match the expected key format.\n   */\n  private fromWebStorageClientStateKey(key: string): ClientId | null {\n    const match = this.clientStateKeyRe.exec(key);\n    return match ? match[1] : null;\n  }\n\n  /**\n   * Parses a client state in WebStorage. Returns 'null' if the value could not\n   * be parsed.\n   */\n  private fromWebStorageClientState(\n    key: string,\n    value: string\n  ): RemoteClientState | null {\n    const clientId = this.fromWebStorageClientStateKey(key);\n    debugAssert(clientId !== null, `Cannot parse client state key '${key}'`);\n    return RemoteClientState.fromWebStorageEntry(clientId, value);\n  }\n\n  /**\n   * Parses a mutation batch state in WebStorage. Returns 'null' if the value\n   * could not be parsed.\n   */\n  private fromWebStorageMutationMetadata(\n    key: string,\n    value: string\n  ): MutationMetadata | null {\n    const match = this.mutationBatchKeyRe.exec(key);\n    debugAssert(match !== null, `Cannot parse mutation batch key '${key}'`);\n\n    const batchId = Number(match[1]);\n    const userId = match[2] !== undefined ? match[2] : null;\n    return MutationMetadata.fromWebStorageEntry(\n      new User(userId),\n      batchId,\n      value\n    );\n  }\n\n  /**\n   * Parses a query target state from WebStorage. Returns 'null' if the value\n   * could not be parsed.\n   */\n  private fromWebStorageQueryTargetMetadata(\n    key: string,\n    value: string\n  ): QueryTargetMetadata | null {\n    const match = this.queryTargetKeyRe.exec(key);\n    debugAssert(match !== null, `Cannot parse query target key '${key}'`);\n\n    const targetId = Number(match[1]);\n    return QueryTargetMetadata.fromWebStorageEntry(targetId, value);\n  }\n\n  /**\n   * Parses an online state from WebStorage. Returns 'null' if the value\n   * could not be parsed.\n   */\n  private fromWebStorageOnlineState(value: string): SharedOnlineState | null {\n    return SharedOnlineState.fromWebStorageEntry(value);\n  }\n\n  private async handleMutationBatchEvent(\n    mutationBatch: MutationMetadata\n  ): Promise<void> {\n    if (mutationBatch.user.uid !== this.currentUser.uid) {\n      logDebug(\n        LOG_TAG,\n        `Ignoring mutation for non-active user ${mutationBatch.user.uid}`\n      );\n      return;\n    }\n\n    return this.syncEngine!.applyBatchState(\n      mutationBatch.batchId,\n      mutationBatch.state,\n      mutationBatch.error\n    );\n  }\n\n  private handleQueryTargetEvent(\n    targetMetadata: QueryTargetMetadata\n  ): Promise<void> {\n    return this.syncEngine!.applyTargetState(\n      targetMetadata.targetId,\n      targetMetadata.state,\n      targetMetadata.error\n    );\n  }\n\n  private handleClientStateEvent(\n    clientId: ClientId,\n    clientState: RemoteClientState | null\n  ): Promise<void> {\n    const updatedClients = clientState\n      ? this.activeClients.insert(clientId, clientState)\n      : this.activeClients.remove(clientId);\n\n    const existingTargets = this.extractActiveQueryTargets(this.activeClients);\n    const newTargets = this.extractActiveQueryTargets(updatedClients);\n\n    const addedTargets: TargetId[] = [];\n    const removedTargets: TargetId[] = [];\n\n    newTargets.forEach(targetId => {\n      if (!existingTargets.has(targetId)) {\n        addedTargets.push(targetId);\n      }\n    });\n\n    existingTargets.forEach(targetId => {\n      if (!newTargets.has(targetId)) {\n        removedTargets.push(targetId);\n      }\n    });\n\n    return this.syncEngine!.applyActiveTargetsChange(\n      addedTargets,\n      removedTargets\n    ).then(() => {\n      this.activeClients = updatedClients;\n    });\n  }\n\n  private handleOnlineStateEvent(onlineState: SharedOnlineState): void {\n    // We check whether the client that wrote this online state is still active\n    // by comparing its client ID to the list of clients kept active in\n    // IndexedDb. If a client does not update their IndexedDb client state\n    // within 5 seconds, it is considered inactive and we don't emit an online\n    // state event.\n    if (this.activeClients.get(onlineState.clientId)) {\n      this.onlineStateHandler!(onlineState.onlineState);\n    }\n  }\n\n  private extractActiveQueryTargets(\n    clients: SortedMap<string, ClientState>\n  ): SortedSet<TargetId> {\n    let activeTargets = targetIdSet();\n    clients.forEach((kev, value) => {\n      activeTargets = activeTargets.unionWith(value.activeTargetIds);\n    });\n    return activeTargets;\n  }\n}\n\nfunction fromWebStorageSequenceNumber(\n  seqString: string | null\n): ListenSequenceNumber {\n  let sequenceNumber = ListenSequence.INVALID;\n  if (seqString != null) {\n    try {\n      const parsed = JSON.parse(seqString);\n      hardAssert(\n        typeof parsed === 'number',\n        'Found non-numeric sequence number'\n      );\n      sequenceNumber = parsed;\n    } catch (e) {\n      logError(LOG_TAG, 'Failed to read sequence number from WebStorage', e);\n    }\n  }\n  return sequenceNumber;\n}\n\n/**\n * `MemorySharedClientState` is a simple implementation of SharedClientState for\n * clients using memory persistence. The state in this class remains fully\n * isolated and no synchronization is performed.\n */\nexport class MemorySharedClientState implements SharedClientState {\n  private localState = new LocalClientState();\n  private queryState: { [targetId: number]: QueryTargetState } = {};\n\n  syncEngine: SharedClientStateSyncer | null = null;\n  onlineStateHandler: ((onlineState: OnlineState) => void) | null = null;\n  sequenceNumberHandler:\n    | ((sequenceNumber: ListenSequenceNumber) => void)\n    | null = null;\n\n  addPendingMutation(batchId: BatchId): void {\n    // No op.\n  }\n\n  updateMutationState(\n    batchId: BatchId,\n    state: 'acknowledged' | 'rejected',\n    error?: FirestoreError\n  ): void {\n    // No op.\n  }\n\n  addLocalQueryTarget(targetId: TargetId): QueryTargetState {\n    this.localState.addQueryTarget(targetId);\n    return this.queryState[targetId] || 'not-current';\n  }\n\n  updateQueryState(\n    targetId: TargetId,\n    state: QueryTargetState,\n    error?: FirestoreError\n  ): void {\n    this.queryState[targetId] = state;\n  }\n\n  removeLocalQueryTarget(targetId: TargetId): void {\n    this.localState.removeQueryTarget(targetId);\n  }\n\n  isLocalQueryTarget(targetId: TargetId): boolean {\n    return this.localState.activeTargetIds.has(targetId);\n  }\n\n  clearQueryState(targetId: TargetId): void {\n    delete this.queryState[targetId];\n  }\n\n  getAllActiveQueryTargets(): TargetIdSet {\n    return this.localState.activeTargetIds;\n  }\n\n  isActiveQueryTarget(targetId: TargetId): boolean {\n    return this.localState.activeTargetIds.has(targetId);\n  }\n\n  start(): Promise<void> {\n    this.localState = new LocalClientState();\n    return Promise.resolve();\n  }\n\n  handleUserChange(\n    user: User,\n    removedBatchIds: BatchId[],\n    addedBatchIds: BatchId[]\n  ): void {\n    // No op.\n  }\n\n  setOnlineState(onlineState: OnlineState): void {\n    // No op.\n  }\n\n  shutdown(): void {}\n\n  writeSequenceNumber(sequenceNumber: ListenSequenceNumber): void {}\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from '../util/error';\nimport { primitiveComparator } from '../util/misc';\n\n// The earlist date supported by Firestore timestamps (0001-01-01T00:00:00Z).\nconst MIN_SECONDS = -62135596800;\n\nexport class Timestamp {\n  static now(): Timestamp {\n    return Timestamp.fromMillis(Date.now());\n  }\n\n  static fromDate(date: Date): Timestamp {\n    return Timestamp.fromMillis(date.getTime());\n  }\n\n  static fromMillis(milliseconds: number): Timestamp {\n    const seconds = Math.floor(milliseconds / 1000);\n    const nanos = (milliseconds - seconds * 1000) * 1e6;\n    return new Timestamp(seconds, nanos);\n  }\n\n  constructor(readonly seconds: number, readonly nanoseconds: number) {\n    if (nanoseconds < 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp nanoseconds out of range: ' + nanoseconds\n      );\n    }\n    if (nanoseconds >= 1e9) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp nanoseconds out of range: ' + nanoseconds\n      );\n    }\n    if (seconds < MIN_SECONDS) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp seconds out of range: ' + seconds\n      );\n    }\n    // This will break in the year 10,000.\n    if (seconds >= 253402300800) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Timestamp seconds out of range: ' + seconds\n      );\n    }\n  }\n\n  toDate(): Date {\n    return new Date(this.toMillis());\n  }\n\n  toMillis(): number {\n    return this.seconds * 1000 + this.nanoseconds / 1e6;\n  }\n\n  _compareTo(other: Timestamp): number {\n    if (this.seconds === other.seconds) {\n      return primitiveComparator(this.nanoseconds, other.nanoseconds);\n    }\n    return primitiveComparator(this.seconds, other.seconds);\n  }\n\n  isEqual(other: Timestamp): boolean {\n    return (\n      other.seconds === this.seconds && other.nanoseconds === this.nanoseconds\n    );\n  }\n\n  toString(): string {\n    return (\n      'Timestamp(seconds=' +\n      this.seconds +\n      ', nanoseconds=' +\n      this.nanoseconds +\n      ')'\n    );\n  }\n\n  valueOf(): string {\n    // This method returns a string of the form <seconds>.<nanoseconds> where <seconds> is\n    // translated to have a non-negative value and both <seconds> and <nanoseconds> are left-padded\n    // with zeroes to be a consistent length. Strings with this format then have a lexiographical\n    // ordering that matches the expected ordering. The <seconds> translation is done to avoid\n    // having a leading negative sign (i.e. a leading '-' character) in its string representation,\n    // which would affect its lexiographical ordering.\n    const adjustedSeconds = this.seconds - MIN_SECONDS;\n    // Note: Up to 12 decimal digits are required to represent all valid 'seconds' values.\n    const formattedSeconds = String(adjustedSeconds).padStart(12, '0');\n    const formattedNanoseconds = String(this.nanoseconds).padStart(9, '0');\n    return formattedSeconds + '.' + formattedNanoseconds;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../api/timestamp';\n\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nexport class SnapshotVersion {\n  static fromTimestamp(value: Timestamp): SnapshotVersion {\n    return new SnapshotVersion(value);\n  }\n\n  static min(): SnapshotVersion {\n    return new SnapshotVersion(new Timestamp(0, 0));\n  }\n\n  private constructor(private timestamp: Timestamp) {}\n\n  compareTo(other: SnapshotVersion): number {\n    return this.timestamp._compareTo(other.timestamp);\n  }\n\n  isEqual(other: SnapshotVersion): boolean {\n    return this.timestamp.isEqual(other.timestamp);\n  }\n\n  /** Returns a number representation of the version for use in spec tests. */\n  toMicroseconds(): number {\n    // Convert to microseconds.\n    return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1000;\n  }\n\n  toString(): string {\n    return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n  }\n\n  toTimestamp(): Timestamp {\n    return this.timestamp;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from './assert';\n\nexport interface Dict<V> {\n  [stringKey: string]: V;\n}\n\nexport function objectSize<V>(obj: object): number {\n  let count = 0;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      count++;\n    }\n  }\n  return count;\n}\n\nexport function forEach<V>(\n  obj: Dict<V>,\n  fn: (key: string, val: V) => void\n): void {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      fn(key, obj[key]);\n    }\n  }\n}\n\nexport function isEmpty<V>(obj: Dict<V>): boolean {\n  debugAssert(\n    obj != null && typeof obj === 'object',\n    'isEmpty() expects object parameter.'\n  );\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PlatformSupport } from '../platform/platform';\nimport { primitiveComparator } from './misc';\n\n/**\n * Immutable class that represents a \"proto\" byte string.\n *\n * Proto byte strings can either be Base64-encoded strings or Uint8Arrays when\n * sent on the wire. This class abstracts away this differentiation by holding\n * the proto byte string in a common class that must be converted into a string\n * before being sent as a proto.\n */\nexport class ByteString {\n  static readonly EMPTY_BYTE_STRING = new ByteString('');\n\n  private constructor(private readonly binaryString: string) {}\n\n  static fromBase64String(base64: string): ByteString {\n    const binaryString = PlatformSupport.getPlatform().atob(base64);\n    return new ByteString(binaryString);\n  }\n\n  static fromUint8Array(array: Uint8Array): ByteString {\n    const binaryString = binaryStringFromUint8Array(array);\n    return new ByteString(binaryString);\n  }\n\n  toBase64(): string {\n    return PlatformSupport.getPlatform().btoa(this.binaryString);\n  }\n\n  toUint8Array(): Uint8Array {\n    return uint8ArrayFromBinaryString(this.binaryString);\n  }\n\n  approximateByteSize(): number {\n    return this.binaryString.length * 2;\n  }\n\n  compareTo(other: ByteString): number {\n    return primitiveComparator(this.binaryString, other.binaryString);\n  }\n\n  isEqual(other: ByteString): boolean {\n    return this.binaryString === other.binaryString;\n  }\n}\n\n/**\n * Helper function to convert an Uint8array to a binary string.\n */\nexport function binaryStringFromUint8Array(array: Uint8Array): string {\n  let binaryString = '';\n  for (let i = 0; i < array.length; ++i) {\n    binaryString += String.fromCharCode(array[i]);\n  }\n  return binaryString;\n}\n\n/**\n * Helper function to convert a binary string to an Uint8Array.\n */\nexport function uint8ArrayFromBinaryString(binaryString: string): Uint8Array {\n  const buffer = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    buffer[i] = binaryString.charCodeAt(i);\n  }\n  return buffer;\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\nimport { Timestamp } from '../api/timestamp';\nimport { normalizeTimestamp } from './values';\n\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Server Timestamps are backed by MapValues that contain an internal field\n * `__type__` with a value of `server_timestamp`. The previous value and local\n * write time are stored in its `__previous_value__` and `__local_write_time__`\n * fields respectively.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   TransformMutation (see TransformMutation.applyTo()). They can only exist in\n *   the local view of a document. Therefore they do not need to be parsed or\n *   serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\n\nconst SERVER_TIMESTAMP_SENTINEL = 'server_timestamp';\nconst TYPE_KEY = '__type__';\nconst PREVIOUS_VALUE_KEY = '__previous_value__';\nconst LOCAL_WRITE_TIME_KEY = '__local_write_time__';\n\nexport function isServerTimestamp(value: api.Value | null): boolean {\n  const type = (value?.mapValue?.fields || {})[TYPE_KEY]?.stringValue;\n  return type === SERVER_TIMESTAMP_SENTINEL;\n}\n\n/**\n * Creates a new ServerTimestamp proto value (using the internal format).\n */\nexport function serverTimestamp(\n  localWriteTime: Timestamp,\n  previousValue: api.Value | null\n): api.Value {\n  const mapValue: api.MapValue = {\n    fields: {\n      [TYPE_KEY]: {\n        stringValue: SERVER_TIMESTAMP_SENTINEL\n      },\n      [LOCAL_WRITE_TIME_KEY]: {\n        timestampValue: {\n          seconds: localWriteTime.seconds,\n          nanos: localWriteTime.nanoseconds\n        }\n      }\n    }\n  };\n\n  if (previousValue) {\n    mapValue.fields![PREVIOUS_VALUE_KEY] = previousValue;\n  }\n\n  return { mapValue };\n}\n\n/**\n * Returns the value of the field before this ServerTimestamp was set.\n *\n * Preserving the previous values allows the user to display the last resoled\n * value until the backend responds with the timestamp.\n */\nexport function getPreviousValue(value: api.Value): api.Value | null {\n  const previousValue = value.mapValue!.fields![PREVIOUS_VALUE_KEY];\n\n  if (isServerTimestamp(previousValue)) {\n    return getPreviousValue(previousValue);\n  }\n  return previousValue;\n}\n\n/**\n * Returns the local time at which this timestamp was first set.\n */\nexport function getLocalWriteTime(value: api.Value): Timestamp {\n  const localWriteTime = normalizeTimestamp(\n    value.mapValue!.fields![LOCAL_WRITE_TIME_KEY].timestampValue!\n  );\n  return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { TypeOrder } from './object_value';\nimport { fail, hardAssert } from '../util/assert';\nimport { forEach, objectSize } from '../util/obj';\nimport { ByteString } from '../util/byte_string';\nimport { isNegativeZero } from '../util/types';\nimport { DocumentKey } from './document_key';\nimport { arrayEquals, primitiveComparator } from '../util/misc';\nimport { DatabaseId } from '../core/database_info';\nimport {\n  getLocalWriteTime,\n  getPreviousValue,\n  isServerTimestamp\n} from './server_timestamps';\n\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nconst ISO_TIMESTAMP_REG_EXP = new RegExp(\n  /^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/\n);\n\n/** Extracts the backend's type order for the provided value. */\nexport function typeOrder(value: api.Value): TypeOrder {\n  if ('nullValue' in value) {\n    return TypeOrder.NullValue;\n  } else if ('booleanValue' in value) {\n    return TypeOrder.BooleanValue;\n  } else if ('integerValue' in value || 'doubleValue' in value) {\n    return TypeOrder.NumberValue;\n  } else if ('timestampValue' in value) {\n    return TypeOrder.TimestampValue;\n  } else if ('stringValue' in value) {\n    return TypeOrder.StringValue;\n  } else if ('bytesValue' in value) {\n    return TypeOrder.BlobValue;\n  } else if ('referenceValue' in value) {\n    return TypeOrder.RefValue;\n  } else if ('geoPointValue' in value) {\n    return TypeOrder.GeoPointValue;\n  } else if ('arrayValue' in value) {\n    return TypeOrder.ArrayValue;\n  } else if ('mapValue' in value) {\n    if (isServerTimestamp(value)) {\n      return TypeOrder.ServerTimestampValue;\n    }\n    return TypeOrder.ObjectValue;\n  } else {\n    return fail('Invalid value type: ' + JSON.stringify(value));\n  }\n}\n\n/** Tests `left` and `right` for equality based on the backend semantics. */\nexport function valueEquals(left: api.Value, right: api.Value): boolean {\n  const leftType = typeOrder(left);\n  const rightType = typeOrder(right);\n  if (leftType !== rightType) {\n    return false;\n  }\n\n  switch (leftType) {\n    case TypeOrder.NullValue:\n      return true;\n    case TypeOrder.BooleanValue:\n      return left.booleanValue === right.booleanValue;\n    case TypeOrder.ServerTimestampValue:\n      return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));\n    case TypeOrder.TimestampValue:\n      return timestampEquals(left, right);\n    case TypeOrder.StringValue:\n      return left.stringValue === right.stringValue;\n    case TypeOrder.BlobValue:\n      return blobEquals(left, right);\n    case TypeOrder.RefValue:\n      return left.referenceValue === right.referenceValue;\n    case TypeOrder.GeoPointValue:\n      return geoPointEquals(left, right);\n    case TypeOrder.NumberValue:\n      return numberEquals(left, right);\n    case TypeOrder.ArrayValue:\n      return arrayEquals(\n        left.arrayValue!.values || [],\n        right.arrayValue!.values || [],\n        valueEquals\n      );\n    case TypeOrder.ObjectValue:\n      return objectEquals(left, right);\n    default:\n      return fail('Unexpected value type: ' + JSON.stringify(left));\n  }\n}\n\nfunction timestampEquals(left: api.Value, right: api.Value): boolean {\n  if (\n    typeof left.timestampValue === 'string' &&\n    typeof right.timestampValue === 'string' &&\n    left.timestampValue.length === right.timestampValue.length\n  ) {\n    // Use string equality for ISO 8601 timestamps\n    return left.timestampValue === right.timestampValue;\n  }\n\n  const leftTimestamp = normalizeTimestamp(left.timestampValue!);\n  const rightTimestamp = normalizeTimestamp(right.timestampValue!);\n  return (\n    leftTimestamp.seconds === rightTimestamp.seconds &&\n    leftTimestamp.nanos === rightTimestamp.nanos\n  );\n}\n\nfunction geoPointEquals(left: api.Value, right: api.Value): boolean {\n  return (\n    normalizeNumber(left.geoPointValue!.latitude) ===\n      normalizeNumber(right.geoPointValue!.latitude) &&\n    normalizeNumber(left.geoPointValue!.longitude) ===\n      normalizeNumber(right.geoPointValue!.longitude)\n  );\n}\n\nfunction blobEquals(left: api.Value, right: api.Value): boolean {\n  return normalizeByteString(left.bytesValue!).isEqual(\n    normalizeByteString(right.bytesValue!)\n  );\n}\n\nexport function numberEquals(left: api.Value, right: api.Value): boolean {\n  if ('integerValue' in left && 'integerValue' in right) {\n    return (\n      normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue)\n    );\n  } else if ('doubleValue' in left && 'doubleValue' in right) {\n    const n1 = normalizeNumber(left.doubleValue!);\n    const n2 = normalizeNumber(right.doubleValue!);\n\n    if (n1 === n2) {\n      return isNegativeZero(n1) === isNegativeZero(n2);\n    } else {\n      return isNaN(n1) && isNaN(n2);\n    }\n  }\n\n  return false;\n}\n\nfunction objectEquals(left: api.Value, right: api.Value): boolean {\n  const leftMap = left.mapValue!.fields || {};\n  const rightMap = right.mapValue!.fields || {};\n\n  if (objectSize(leftMap) !== objectSize(rightMap)) {\n    return false;\n  }\n\n  for (const key in leftMap) {\n    if (leftMap.hasOwnProperty(key)) {\n      if (\n        rightMap[key] === undefined ||\n        !valueEquals(leftMap[key], rightMap[key])\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/** Returns true if the ArrayValue contains the specified element. */\nexport function arrayValueContains(\n  haystack: api.ArrayValue,\n  needle: api.Value\n): boolean {\n  return (\n    (haystack.values || []).find(v => valueEquals(v, needle)) !== undefined\n  );\n}\n\nexport function valueCompare(left: api.Value, right: api.Value): number {\n  const leftType = typeOrder(left);\n  const rightType = typeOrder(right);\n\n  if (leftType !== rightType) {\n    return primitiveComparator(leftType, rightType);\n  }\n\n  switch (leftType) {\n    case TypeOrder.NullValue:\n      return 0;\n    case TypeOrder.BooleanValue:\n      return primitiveComparator(left.booleanValue!, right.booleanValue!);\n    case TypeOrder.NumberValue:\n      return compareNumbers(left, right);\n    case TypeOrder.TimestampValue:\n      return compareTimestamps(left.timestampValue!, right.timestampValue!);\n    case TypeOrder.ServerTimestampValue:\n      return compareTimestamps(\n        getLocalWriteTime(left),\n        getLocalWriteTime(right)\n      );\n    case TypeOrder.StringValue:\n      return primitiveComparator(left.stringValue!, right.stringValue!);\n    case TypeOrder.BlobValue:\n      return compareBlobs(left.bytesValue!, right.bytesValue!);\n    case TypeOrder.RefValue:\n      return compareReferences(left.referenceValue!, right.referenceValue!);\n    case TypeOrder.GeoPointValue:\n      return compareGeoPoints(left.geoPointValue!, right.geoPointValue!);\n    case TypeOrder.ArrayValue:\n      return compareArrays(left.arrayValue!, right.arrayValue!);\n    case TypeOrder.ObjectValue:\n      return compareMaps(left.mapValue!, right.mapValue!);\n    default:\n      throw fail('Invalid value type: ' + leftType);\n  }\n}\n\nfunction compareNumbers(left: api.Value, right: api.Value): number {\n  const leftNumber = normalizeNumber(left.integerValue || left.doubleValue);\n  const rightNumber = normalizeNumber(right.integerValue || right.doubleValue);\n\n  if (leftNumber < rightNumber) {\n    return -1;\n  } else if (leftNumber > rightNumber) {\n    return 1;\n  } else if (leftNumber === rightNumber) {\n    return 0;\n  } else {\n    // one or both are NaN.\n    if (isNaN(leftNumber)) {\n      return isNaN(rightNumber) ? 0 : -1;\n    } else {\n      return 1;\n    }\n  }\n}\n\nfunction compareTimestamps(left: api.Timestamp, right: api.Timestamp): number {\n  if (\n    typeof left === 'string' &&\n    typeof right === 'string' &&\n    left.length === right.length\n  ) {\n    return primitiveComparator(left, right);\n  }\n\n  const leftTimestamp = normalizeTimestamp(left);\n  const rightTimestamp = normalizeTimestamp(right);\n\n  const comparison = primitiveComparator(\n    leftTimestamp.seconds,\n    rightTimestamp.seconds\n  );\n  if (comparison !== 0) {\n    return comparison;\n  }\n  return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);\n}\n\nfunction compareReferences(leftPath: string, rightPath: string): number {\n  const leftSegments = leftPath.split('/');\n  const rightSegments = rightPath.split('/');\n  for (let i = 0; i < leftSegments.length && i < rightSegments.length; i++) {\n    const comparison = primitiveComparator(leftSegments[i], rightSegments[i]);\n    if (comparison !== 0) {\n      return comparison;\n    }\n  }\n  return primitiveComparator(leftSegments.length, rightSegments.length);\n}\n\nfunction compareGeoPoints(left: api.LatLng, right: api.LatLng): number {\n  const comparison = primitiveComparator(\n    normalizeNumber(left.latitude),\n    normalizeNumber(right.latitude)\n  );\n  if (comparison !== 0) {\n    return comparison;\n  }\n  return primitiveComparator(\n    normalizeNumber(left.longitude),\n    normalizeNumber(right.longitude)\n  );\n}\n\nfunction compareBlobs(\n  left: string | Uint8Array,\n  right: string | Uint8Array\n): number {\n  const leftBytes = normalizeByteString(left);\n  const rightBytes = normalizeByteString(right);\n  return leftBytes.compareTo(rightBytes);\n}\n\nfunction compareArrays(left: api.ArrayValue, right: api.ArrayValue): number {\n  const leftArray = left.values || [];\n  const rightArray = right.values || [];\n\n  for (let i = 0; i < leftArray.length && i < rightArray.length; ++i) {\n    const compare = valueCompare(leftArray[i], rightArray[i]);\n    if (compare) {\n      return compare;\n    }\n  }\n  return primitiveComparator(leftArray.length, rightArray.length);\n}\n\nfunction compareMaps(left: api.MapValue, right: api.MapValue): number {\n  const leftMap = left.fields || {};\n  const leftKeys = Object.keys(leftMap);\n  const rightMap = right.fields || {};\n  const rightKeys = Object.keys(rightMap);\n\n  // Even though MapValues are likely sorted correctly based on their insertion\n  // order (e.g. when received from the backend), local modifications can bring\n  // elements out of order. We need to re-sort the elements to ensure that\n  // canonical IDs are independent of insertion order.\n  leftKeys.sort();\n  rightKeys.sort();\n\n  for (let i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {\n    const keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);\n    if (keyCompare !== 0) {\n      return keyCompare;\n    }\n    const compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);\n    if (compare !== 0) {\n      return compare;\n    }\n  }\n\n  return primitiveComparator(leftKeys.length, rightKeys.length);\n}\n\n/**\n * Generates the canonical ID for the provided field value (as used in Target\n * serialization).\n */\nexport function canonicalId(value: api.Value): string {\n  return canonifyValue(value);\n}\n\nfunction canonifyValue(value: api.Value): string {\n  if ('nullValue' in value) {\n    return 'null';\n  } else if ('booleanValue' in value) {\n    return '' + value.booleanValue!;\n  } else if ('integerValue' in value) {\n    return '' + value.integerValue!;\n  } else if ('doubleValue' in value) {\n    return '' + value.doubleValue!;\n  } else if ('timestampValue' in value) {\n    return canonifyTimestamp(value.timestampValue!);\n  } else if ('stringValue' in value) {\n    return value.stringValue!;\n  } else if ('bytesValue' in value) {\n    return canonifyByteString(value.bytesValue!);\n  } else if ('referenceValue' in value) {\n    return canonifyReference(value.referenceValue!);\n  } else if ('geoPointValue' in value) {\n    return canonifyGeoPoint(value.geoPointValue!);\n  } else if ('arrayValue' in value) {\n    return canonifyArray(value.arrayValue!);\n  } else if ('mapValue' in value) {\n    return canonifyMap(value.mapValue!);\n  } else {\n    return fail('Invalid value type: ' + JSON.stringify(value));\n  }\n}\n\nfunction canonifyByteString(byteString: string | Uint8Array): string {\n  return normalizeByteString(byteString).toBase64();\n}\n\nfunction canonifyTimestamp(timestamp: api.Timestamp): string {\n  const normalizedTimestamp = normalizeTimestamp(timestamp);\n  return `time(${normalizedTimestamp.seconds},${normalizedTimestamp.nanos})`;\n}\n\nfunction canonifyGeoPoint(geoPoint: api.LatLng): string {\n  return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\n\nfunction canonifyReference(referenceValue: string): string {\n  return DocumentKey.fromName(referenceValue).toString();\n}\n\nfunction canonifyMap(mapValue: api.MapValue): string {\n  // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n  // matching canonical IDs for identical maps, we need to sort the keys.\n  const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n\n  let result = '{';\n  let first = true;\n  for (const key of sortedKeys) {\n    if (!first) {\n      result += ',';\n    } else {\n      first = false;\n    }\n    result += `${key}:${canonifyValue(mapValue.fields![key])}`;\n  }\n  return result + '}';\n}\n\nfunction canonifyArray(arrayValue: api.ArrayValue): string {\n  let result = '[';\n  let first = true;\n  for (const value of arrayValue.values || []) {\n    if (!first) {\n      result += ',';\n    } else {\n      first = false;\n    }\n    result += canonifyValue(value);\n  }\n  return result + ']';\n}\n\n/**\n * Returns an approximate (and wildly inaccurate) in-memory size for the field\n * value.\n *\n * The memory size takes into account only the actual user data as it resides\n * in memory and ignores object overhead.\n */\nexport function estimateByteSize(value: api.Value): number {\n  switch (typeOrder(value)) {\n    case TypeOrder.NullValue:\n      return 4;\n    case TypeOrder.BooleanValue:\n      return 4;\n    case TypeOrder.NumberValue:\n      return 8;\n    case TypeOrder.TimestampValue:\n      // Timestamps are made up of two distinct numbers (seconds + nanoseconds)\n      return 16;\n    case TypeOrder.ServerTimestampValue:\n      const previousValue = getPreviousValue(value);\n      return previousValue ? 16 + estimateByteSize(previousValue) : 16;\n    case TypeOrder.StringValue:\n      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures:\n      // \"JavaScript's String type is [...] a set of elements of 16-bit unsigned\n      // integer values\"\n      return value.stringValue!.length * 2;\n    case TypeOrder.BlobValue:\n      return normalizeByteString(value.bytesValue!).approximateByteSize();\n    case TypeOrder.RefValue:\n      return value.referenceValue!.length;\n    case TypeOrder.GeoPointValue:\n      // GeoPoints are made up of two distinct numbers (latitude + longitude)\n      return 16;\n    case TypeOrder.ArrayValue:\n      return estimateArrayByteSize(value.arrayValue!);\n    case TypeOrder.ObjectValue:\n      return estimateMapByteSize(value.mapValue!);\n    default:\n      throw fail('Invalid value type: ' + JSON.stringify(value));\n  }\n}\n\nfunction estimateMapByteSize(mapValue: api.MapValue): number {\n  let size = 0;\n  forEach(mapValue.fields || {}, (key, val) => {\n    size += key.length + estimateByteSize(val);\n  });\n  return size;\n}\n\nfunction estimateArrayByteSize(arrayValue: api.ArrayValue): number {\n  return (arrayValue.values || []).reduce(\n    (previousSize, value) => previousSize + estimateByteSize(value),\n    0\n  );\n}\n\n/**\n * Converts the possible Proto values for a timestamp value into a \"seconds and\n * nanos\" representation.\n */\nexport function normalizeTimestamp(\n  date: api.Timestamp\n): { seconds: number; nanos: number } {\n  hardAssert(!!date, 'Cannot normalize null or undefined timestamp.');\n\n  // The json interface (for the browser) will return an iso timestamp string,\n  // while the proto js library (for node) will return a\n  // google.protobuf.Timestamp instance.\n  if (typeof date === 'string') {\n    // The date string can have higher precision (nanos) than the Date class\n    // (millis), so we do some custom parsing here.\n\n    // Parse the nanos right out of the string.\n    let nanos = 0;\n    const fraction = ISO_TIMESTAMP_REG_EXP.exec(date);\n    hardAssert(!!fraction, 'invalid timestamp: ' + date);\n    if (fraction[1]) {\n      // Pad the fraction out to 9 digits (nanos).\n      let nanoStr = fraction[1];\n      nanoStr = (nanoStr + '000000000').substr(0, 9);\n      nanos = Number(nanoStr);\n    }\n\n    // Parse the date to get the seconds.\n    const parsedDate = new Date(date);\n    const seconds = Math.floor(parsedDate.getTime() / 1000);\n\n    return { seconds, nanos };\n  } else {\n    // TODO(b/37282237): Use strings for Proto3 timestamps\n    // assert(!this.options.useProto3Json,\n    //   'The timestamp instance format requires Proto JS.');\n    const seconds = normalizeNumber(date.seconds);\n    const nanos = normalizeNumber(date.nanos);\n    return { seconds, nanos };\n  }\n}\n\n/**\n * Converts the possible Proto types for numbers into a JavaScript number.\n * Returns 0 if the value is not numeric.\n */\nexport function normalizeNumber(value: number | string | undefined): number {\n  // TODO(bjornick): Handle int64 greater than 53 bits.\n  if (typeof value === 'number') {\n    return value;\n  } else if (typeof value === 'string') {\n    return Number(value);\n  } else {\n    return 0;\n  }\n}\n\n/** Converts the possible Proto types for Blobs into a ByteString. */\nexport function normalizeByteString(blob: string | Uint8Array): ByteString {\n  if (typeof blob === 'string') {\n    return ByteString.fromBase64String(blob);\n  } else {\n    return ByteString.fromUint8Array(blob);\n  }\n}\n\n/** Returns a reference value for the provided database and key. */\nexport function refValue(databaseId: DatabaseId, key: DocumentKey): api.Value {\n  return {\n    referenceValue: `projects/${databaseId.projectId}/databases/${\n      databaseId.database\n    }/documents/${key.path.canonicalString()}`\n  };\n}\n\n/** Returns true if `value` is an IntegerValue . */\nexport function isInteger(\n  value?: api.Value | null\n): value is { integerValue: string | number } {\n  return !!value && 'integerValue' in value;\n}\n\n/** Returns true if `value` is a DoubleValue. */\nexport function isDouble(\n  value?: api.Value | null\n): value is { doubleValue: string | number } {\n  return !!value && 'doubleValue' in value;\n}\n\n/** Returns true if `value` is either an IntegerValue or a DoubleValue. */\nexport function isNumber(value?: api.Value | null): boolean {\n  return isInteger(value) || isDouble(value);\n}\n\n/** Returns true if `value` is an ArrayValue. */\nexport function isArray(\n  value?: api.Value | null\n): value is { arrayValue: api.ArrayValue } {\n  return !!value && 'arrayValue' in value;\n}\n\n/** Returns true if `value` is a ReferenceValue. */\nexport function isReferenceValue(\n  value?: api.Value | null\n): value is { referenceValue: string } {\n  return !!value && 'referenceValue' in value;\n}\n\n/** Returns true if `value` is a NullValue. */\nexport function isNullValue(\n  value?: api.Value | null\n): value is { nullValue: 'NULL_VALUE' } {\n  return !!value && 'nullValue' in value;\n}\n\n/** Returns true if `value` is NaN. */\nexport function isNanValue(\n  value?: api.Value | null\n): value is { doubleValue: 'NaN' | number } {\n  return !!value && 'doubleValue' in value && isNaN(Number(value.doubleValue));\n}\n\n/** Returns true if `value` is a MapValue. */\nexport function isMapValue(\n  value?: api.Value | null\n): value is { mapValue: api.MapValue } {\n  return !!value && 'mapValue' in value;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { fail } from '../util/assert';\n\nimport { DocumentKey } from './document_key';\nimport { ObjectValue } from './object_value';\nimport { FieldPath } from './path';\nimport { valueCompare } from './values';\n\nexport interface DocumentOptions {\n  hasLocalMutations?: boolean;\n  hasCommittedMutations?: boolean;\n}\n\n/**\n * The result of a lookup for a given path may be an existing document or a\n * marker that this document does not exist at a given version.\n */\nexport abstract class MaybeDocument {\n  constructor(readonly key: DocumentKey, readonly version: SnapshotVersion) {}\n\n  /**\n   * Whether this document had a local mutation applied that has not yet been\n   * acknowledged by Watch.\n   */\n  abstract get hasPendingWrites(): boolean;\n\n  abstract isEqual(other: MaybeDocument | null | undefined): boolean;\n\n  abstract toString(): string;\n}\n\n/**\n * Represents a document in Firestore with a key, version, data and whether the\n * data has local mutations applied to it.\n */\nexport class Document extends MaybeDocument {\n  readonly hasLocalMutations: boolean;\n  readonly hasCommittedMutations: boolean;\n\n  constructor(\n    key: DocumentKey,\n    version: SnapshotVersion,\n    private readonly objectValue: ObjectValue,\n    options: DocumentOptions\n  ) {\n    super(key, version);\n    this.hasLocalMutations = !!options.hasLocalMutations;\n    this.hasCommittedMutations = !!options.hasCommittedMutations;\n  }\n\n  field(path: FieldPath): api.Value | null {\n    return this.objectValue.field(path);\n  }\n\n  data(): ObjectValue {\n    return this.objectValue;\n  }\n\n  toProto(): { mapValue: api.MapValue } {\n    return this.objectValue.proto;\n  }\n\n  isEqual(other: MaybeDocument | null | undefined): boolean {\n    return (\n      other instanceof Document &&\n      this.key.isEqual(other.key) &&\n      this.version.isEqual(other.version) &&\n      this.hasLocalMutations === other.hasLocalMutations &&\n      this.hasCommittedMutations === other.hasCommittedMutations &&\n      this.objectValue.isEqual(other.objectValue)\n    );\n  }\n\n  toString(): string {\n    return (\n      `Document(${this.key}, ${\n        this.version\n      }, ${this.objectValue.toString()}, ` +\n      `{hasLocalMutations: ${this.hasLocalMutations}}), ` +\n      `{hasCommittedMutations: ${this.hasCommittedMutations}})`\n    );\n  }\n\n  get hasPendingWrites(): boolean {\n    return this.hasLocalMutations || this.hasCommittedMutations;\n  }\n}\n\n/**\n * Compares the value for field `field` in the provided documents. Throws if\n * the field does not exist in both documents.\n */\nexport function compareDocumentsByField(\n  field: FieldPath,\n  d1: Document,\n  d2: Document\n): number {\n  const v1 = d1.field(field);\n  const v2 = d2.field(field);\n  if (v1 !== null && v2 !== null) {\n    return valueCompare(v1, v2);\n  } else {\n    return fail(\"Trying to compare documents on fields that don't exist\");\n  }\n}\n\n/**\n * A class representing a deleted document.\n * Version is set to 0 if we don't point to any specific time, otherwise it\n * denotes time we know it didn't exist at.\n */\nexport class NoDocument extends MaybeDocument {\n  readonly hasCommittedMutations: boolean;\n\n  constructor(\n    key: DocumentKey,\n    version: SnapshotVersion,\n    options?: DocumentOptions\n  ) {\n    super(key, version);\n    this.hasCommittedMutations = !!(options && options.hasCommittedMutations);\n  }\n\n  toString(): string {\n    return `NoDocument(${this.key}, ${this.version})`;\n  }\n\n  get hasPendingWrites(): boolean {\n    return this.hasCommittedMutations;\n  }\n\n  isEqual(other: MaybeDocument | null | undefined): boolean {\n    return (\n      other instanceof NoDocument &&\n      other.hasCommittedMutations === this.hasCommittedMutations &&\n      other.version.isEqual(this.version) &&\n      other.key.isEqual(this.key)\n    );\n  }\n}\n\n/**\n * A class representing an existing document whose data is unknown (e.g. a\n * document that was updated without a known base document).\n */\nexport class UnknownDocument extends MaybeDocument {\n  toString(): string {\n    return `UnknownDocument(${this.key}, ${this.version})`;\n  }\n\n  get hasPendingWrites(): boolean {\n    return true;\n  }\n\n  isEqual(other: MaybeDocument | null | undefined): boolean {\n    return (\n      other instanceof UnknownDocument &&\n      other.version.isEqual(this.version) &&\n      other.key.isEqual(this.key)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { debugAssert } from '../util/assert';\nimport { FieldMask } from './mutation';\nimport { FieldPath } from './path';\nimport { isServerTimestamp } from './server_timestamps';\nimport { valueEquals, isMapValue, typeOrder } from './values';\nimport { forEach } from '../util/obj';\n\nexport interface JsonObject<T> {\n  [name: string]: T;\n}\n\nexport const enum TypeOrder {\n  // This order is based on the backend's ordering, but modified to support\n  // server timestamps.\n  NullValue = 0,\n  BooleanValue = 1,\n  NumberValue = 2,\n  TimestampValue = 3,\n  ServerTimestampValue = 4,\n  StringValue = 5,\n  BlobValue = 6,\n  RefValue = 7,\n  GeoPointValue = 8,\n  ArrayValue = 9,\n  ObjectValue = 10\n}\n\n/**\n * An ObjectValue represents a MapValue in the Firestore Proto and offers the\n * ability to add and remove fields (via the ObjectValueBuilder).\n */\nexport class ObjectValue {\n  constructor(public readonly proto: { mapValue: api.MapValue }) {\n    debugAssert(\n      !isServerTimestamp(proto),\n      'ServerTimestamps should be converted to ServerTimestampValue'\n    );\n  }\n\n  static empty(): ObjectValue {\n    return new ObjectValue({ mapValue: {} });\n  }\n\n  /**\n   * Returns the value at the given path or null.\n   *\n   * @param path the path to search\n   * @return The value at the path or if there it doesn't exist.\n   */\n  field(path: FieldPath): api.Value | null {\n    if (path.isEmpty()) {\n      return this.proto;\n    } else {\n      let value: api.Value = this.proto;\n      for (let i = 0; i < path.length - 1; ++i) {\n        if (!value.mapValue!.fields) {\n          return null;\n        }\n        value = value.mapValue!.fields[path.get(i)];\n        if (!isMapValue(value)) {\n          return null;\n        }\n      }\n\n      value = (value.mapValue!.fields || {})[path.lastSegment()];\n      return value || null;\n    }\n  }\n\n  isEqual(other: ObjectValue): boolean {\n    return valueEquals(this.proto, other.proto);\n  }\n}\n\n/**\n * An Overlay, which contains an update to apply. Can either be Value proto, a\n * map of Overlay values (to represent additional nesting at the given key) or\n * `null` (to represent field deletes).\n */\ntype Overlay = Map<string, Overlay> | api.Value | null;\n\n/**\n * An ObjectValueBuilder provides APIs to set and delete fields from an\n * ObjectValue.\n */\nexport class ObjectValueBuilder {\n  /** A map that contains the accumulated changes in this builder. */\n  private overlayMap = new Map<string, Overlay>();\n\n  /**\n   * @param baseObject The object to mutate.\n   */\n  constructor(private readonly baseObject: ObjectValue = ObjectValue.empty()) {}\n\n  /**\n   * Sets the field to the provided value.\n   *\n   * @param path The field path to set.\n   * @param value The value to set.\n   * @return The current Builder instance.\n   */\n  set(path: FieldPath, value: api.Value): ObjectValueBuilder {\n    debugAssert(\n      !path.isEmpty(),\n      'Cannot set field for empty path on ObjectValue'\n    );\n    this.setOverlay(path, value);\n    return this;\n  }\n\n  /**\n   * Removes the field at the specified path. If there is no field at the\n   * specified path, nothing is changed.\n   *\n   * @param path The field path to remove.\n   * @return The current Builder instance.\n   */\n  delete(path: FieldPath): ObjectValueBuilder {\n    debugAssert(\n      !path.isEmpty(),\n      'Cannot delete field for empty path on ObjectValue'\n    );\n    this.setOverlay(path, null);\n    return this;\n  }\n\n  /**\n   * Adds `value` to the overlay map at `path`. Creates nested map entries if\n   * needed.\n   */\n  private setOverlay(path: FieldPath, value: api.Value | null): void {\n    let currentLevel = this.overlayMap;\n\n    for (let i = 0; i < path.length - 1; ++i) {\n      const currentSegment = path.get(i);\n      let currentValue = currentLevel.get(currentSegment);\n\n      if (currentValue instanceof Map) {\n        // Re-use a previously created map\n        currentLevel = currentValue;\n      } else if (\n        currentValue &&\n        typeOrder(currentValue) === TypeOrder.ObjectValue\n      ) {\n        // Convert the existing Protobuf MapValue into a map\n        currentValue = new Map<string, Overlay>(\n          Object.entries(currentValue.mapValue!.fields || {})\n        );\n        currentLevel.set(currentSegment, currentValue);\n        currentLevel = currentValue;\n      } else {\n        // Create an empty map to represent the current nesting level\n        currentValue = new Map<string, Overlay>();\n        currentLevel.set(currentSegment, currentValue);\n        currentLevel = currentValue;\n      }\n    }\n\n    currentLevel.set(path.lastSegment(), value);\n  }\n\n  /** Returns an ObjectValue with all mutations applied. */\n  build(): ObjectValue {\n    const mergedResult = this.applyOverlay(\n      FieldPath.EMPTY_PATH,\n      this.overlayMap\n    );\n    if (mergedResult != null) {\n      return new ObjectValue(mergedResult);\n    } else {\n      return this.baseObject;\n    }\n  }\n\n  /**\n   * Applies any overlays from `currentOverlays` that exist at `currentPath`\n   * and returns the merged data at `currentPath` (or null if there were no\n   * changes).\n   *\n   * @param currentPath The path at the current nesting level. Can be set to\n   * FieldValue.EMPTY_PATH to represent the root.\n   * @param currentOverlays The overlays at the current nesting level in the\n   * same format as `overlayMap`.\n   * @return The merged data at `currentPath` or null if no modifications\n   * were applied.\n   */\n  private applyOverlay(\n    currentPath: FieldPath,\n    currentOverlays: Map<string, Overlay>\n  ): { mapValue: api.MapValue } | null {\n    let modified = false;\n\n    const existingValue = this.baseObject.field(currentPath);\n    const resultAtPath = isMapValue(existingValue)\n      ? // If there is already data at the current path, base our\n        // modifications on top of the existing data.\n        { ...existingValue.mapValue.fields }\n      : {};\n\n    currentOverlays.forEach((value, pathSegment) => {\n      if (value instanceof Map) {\n        const nested = this.applyOverlay(currentPath.child(pathSegment), value);\n        if (nested != null) {\n          resultAtPath[pathSegment] = nested;\n          modified = true;\n        }\n      } else if (value !== null) {\n        resultAtPath[pathSegment] = value;\n        modified = true;\n      } else if (resultAtPath.hasOwnProperty(pathSegment)) {\n        delete resultAtPath[pathSegment];\n        modified = true;\n      }\n    });\n\n    return modified ? { mapValue: { fields: resultAtPath } } : null;\n  }\n}\n\n/**\n * Returns a FieldMask built from all fields in a MapValue.\n */\nexport function extractFieldMask(value: api.MapValue): FieldMask {\n  const fields: FieldPath[] = [];\n  forEach(value!.fields || {}, (key, value) => {\n    const currentPath = new FieldPath([key]);\n    if (isMapValue(value)) {\n      const nestedMask = extractFieldMask(value.mapValue!);\n      const nestedFields = nestedMask.fields;\n      if (nestedFields.length === 0) {\n        // Preserve the empty map by adding it to the FieldMask.\n        fields.push(currentPath);\n      } else {\n        // For nested and non-empty ObjectValues, add the FieldPath of the\n        // leaf nodes.\n        for (const nestedPath of nestedFields) {\n          fields.push(currentPath.child(nestedPath));\n        }\n      }\n    } else {\n      // For nested and non-empty ObjectValues, add the FieldPath of the leaf\n      // nodes.\n      fields.push(currentPath);\n    }\n  });\n  return new FieldMask(fields);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { Timestamp } from '../api/timestamp';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { debugAssert, fail, hardAssert } from '../util/assert';\n\nimport {\n  Document,\n  MaybeDocument,\n  NoDocument,\n  UnknownDocument\n} from './document';\nimport { DocumentKey } from './document_key';\nimport { ObjectValue, ObjectValueBuilder } from './object_value';\nimport { FieldPath } from './path';\nimport { TransformOperation } from './transform_operation';\nimport { arrayEquals } from '../util/misc';\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nexport class FieldMask {\n  constructor(readonly fields: FieldPath[]) {\n    // TODO(dimond): validation of FieldMask\n    // Sort the field mask to support `FieldMask.isEqual()` and assert below.\n    fields.sort(FieldPath.comparator);\n    debugAssert(\n      !fields.some((v, i) => i !== 0 && v.isEqual(fields[i - 1])),\n      'FieldMask contains field that is not unique: ' +\n        fields.find((v, i) => i !== 0 && v.isEqual(fields[i - 1]))!\n    );\n  }\n\n  /**\n   * Verifies that `fieldPath` is included by at least one field in this field\n   * mask.\n   *\n   * This is an O(n) operation, where `n` is the size of the field mask.\n   */\n  covers(fieldPath: FieldPath): boolean {\n    for (const fieldMaskPath of this.fields) {\n      if (fieldMaskPath.isPrefixOf(fieldPath)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isEqual(other: FieldMask): boolean {\n    return arrayEquals(this.fields, other.fields, (l, r) => l.isEqual(r));\n  }\n}\n\n/** A field path and the TransformOperation to perform upon it. */\nexport class FieldTransform {\n  constructor(\n    readonly field: FieldPath,\n    readonly transform: TransformOperation\n  ) {}\n\n  isEqual(other: FieldTransform): boolean {\n    return (\n      this.field.isEqual(other.field) && this.transform.isEqual(other.transform)\n    );\n  }\n}\n\n/** The result of successfully applying a mutation to the backend. */\nexport class MutationResult {\n  constructor(\n    /**\n     * The version at which the mutation was committed:\n     *\n     * - For most operations, this is the updateTime in the WriteResult.\n     * - For deletes, the commitTime of the WriteResponse (because deletes are\n     *   not stored and have no updateTime).\n     *\n     * Note that these versions can be different: No-op writes will not change\n     * the updateTime even though the commitTime advances.\n     */\n    readonly version: SnapshotVersion,\n    /**\n     * The resulting fields returned from the backend after a\n     * TransformMutation has been committed. Contains one FieldValue for each\n     * FieldTransform that was in the mutation.\n     *\n     * Will be null if the mutation was not a TransformMutation.\n     */\n    readonly transformResults: Array<api.Value | null> | null\n  ) {}\n}\n\nexport const enum MutationType {\n  Set,\n  Patch,\n  Transform,\n  Delete,\n  Verify\n}\n\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nexport class Precondition {\n  private constructor(\n    readonly updateTime?: SnapshotVersion,\n    readonly exists?: boolean\n  ) {\n    debugAssert(\n      updateTime === undefined || exists === undefined,\n      'Precondition can specify \"exists\" or \"updateTime\" but not both'\n    );\n  }\n\n  /** Creates a new empty Precondition. */\n  static none(): Precondition {\n    return new Precondition();\n  }\n\n  /** Creates a new Precondition with an exists flag. */\n  static exists(exists: boolean): Precondition {\n    return new Precondition(undefined, exists);\n  }\n\n  /** Creates a new Precondition based on a version a document exists at. */\n  static updateTime(version: SnapshotVersion): Precondition {\n    return new Precondition(version);\n  }\n\n  /** Returns whether this Precondition is empty. */\n  get isNone(): boolean {\n    return this.updateTime === undefined && this.exists === undefined;\n  }\n\n  /**\n   * Returns true if the preconditions is valid for the given document\n   * (or null if no document is available).\n   */\n  isValidFor(maybeDoc: MaybeDocument | null): boolean {\n    if (this.updateTime !== undefined) {\n      return (\n        maybeDoc instanceof Document &&\n        maybeDoc.version.isEqual(this.updateTime)\n      );\n    } else if (this.exists !== undefined) {\n      return this.exists === maybeDoc instanceof Document;\n    } else {\n      debugAssert(this.isNone, 'Precondition should be empty');\n      return true;\n    }\n  }\n\n  isEqual(other: Precondition): boolean {\n    return (\n      this.exists === other.exists &&\n      (this.updateTime\n        ? !!other.updateTime && this.updateTime.isEqual(other.updateTime)\n        : !other.updateTime)\n    );\n  }\n}\n\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also its version.\n *\n * For local mutations (mutations that haven't been committed yet), we preserve\n * the existing version for Set, Patch, and Transform mutations. For Delete\n * mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * For acknowledged mutations, we use the updateTime of the WriteResponse as\n * the resulting version for Set, Patch, and Transform mutations. As deletes\n * have no explicit update time, we use the commitTime of the WriteResponse for\n * Delete mutations.\n *\n * If a mutation is acknowledged by the backend but fails the precondition check\n * locally, we return an `UnknownDocument` and rely on Watch to send us the\n * updated version.\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nexport abstract class Mutation {\n  abstract readonly type: MutationType;\n  abstract readonly key: DocumentKey;\n  abstract readonly precondition: Precondition;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing a new remote document. If the input document doesn't match the\n   * expected state (e.g. it is null or outdated), an `UnknownDocument` can be\n   * returned.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param mutationResult The result of applying the mutation from the backend.\n   * @return The mutated document. The returned document may be an\n   *     UnknownDocument if the mutation could not be applied to the locally\n   *     cached base document.\n   */\n  abstract applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument;\n\n  /**\n   * Applies this mutation to the given MaybeDocument or null for the purposes\n   * of computing the new local view of a document. Both the input and returned\n   * documents can be null.\n   *\n   * @param maybeDoc The document to mutate. The input document can be null if\n   *     the client has no knowledge of the pre-mutation state of the document.\n   * @param baseDoc The state of the document prior to this mutation batch. The\n   *     input document can be null if the client has no knowledge of the\n   *     pre-mutation state of the document.\n   * @param localWriteTime A timestamp indicating the local write time of the\n   *     batch this mutation is a part of.\n   * @return The mutated document. The returned document may be null, but only\n   *     if maybeDoc was null and the mutation would not create a new document.\n   */\n  abstract applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null;\n\n  /**\n   * If this mutation is not idempotent, returns the base value to persist with\n   * this mutation. If a base value is returned, the mutation is always applied\n   * to this base value, even if document has already been updated.\n   *\n   * The base value is a sparse object that consists of only the document\n   * fields for which this mutation contains a non-idempotent transformation\n   * (e.g. a numeric increment). The provided value guarantees consistent\n   * behavior for non-idempotent transforms and allow us to return the same\n   * latency-compensated value even if the backend has already applied the\n   * mutation. The base value is null for idempotent mutations, as they can be\n   * re-played even if the backend has already applied them.\n   *\n   * @return a base value to store along with the mutation, or null for\n   * idempotent mutations.\n   */\n  abstract extractBaseValue(maybeDoc: MaybeDocument | null): ObjectValue | null;\n\n  abstract isEqual(other: Mutation): boolean;\n\n  protected verifyKeyMatches(maybeDoc: MaybeDocument | null): void {\n    if (maybeDoc != null) {\n      debugAssert(\n        maybeDoc.key.isEqual(this.key),\n        'Can only apply a mutation to a document with the same key'\n      );\n    }\n  }\n\n  /**\n   * Returns the version from the given document for use as the result of a\n   * mutation. Mutations are defined to return the version of the base document\n   * only if it is an existing document. Deleted and unknown documents have a\n   * post-mutation version of SnapshotVersion.min().\n   */\n  protected static getPostMutationVersion(\n    maybeDoc: MaybeDocument | null\n  ): SnapshotVersion {\n    if (maybeDoc instanceof Document) {\n      return maybeDoc.version;\n    } else {\n      return SnapshotVersion.min();\n    }\n  }\n}\n\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nexport class SetMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly value: ObjectValue,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Set;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument {\n    this.verifyKeyMatches(maybeDoc);\n\n    debugAssert(\n      mutationResult.transformResults == null,\n      'Transform results received by SetMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    const version = mutationResult.version;\n    return new Document(this.key, version, this.value, {\n      hasCommittedMutations: true\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    return new Document(this.key, version, this.value, {\n      hasLocalMutations: true\n    });\n  }\n\n  extractBaseValue(maybeDoc: MaybeDocument | null): null {\n    return null;\n  }\n\n  isEqual(other: Mutation): boolean {\n    return (\n      other instanceof SetMutation &&\n      this.key.isEqual(other.key) &&\n      this.value.isEqual(other.value) &&\n      this.precondition.isEqual(other.precondition)\n    );\n  }\n}\n\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nexport class PatchMutation extends Mutation {\n  constructor(\n    readonly key: DocumentKey,\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly precondition: Precondition\n  ) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Patch;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument {\n    this.verifyKeyMatches(maybeDoc);\n\n    debugAssert(\n      mutationResult.transformResults == null,\n      'Transform results received by PatchMutation.'\n    );\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      // Since the mutation was not rejected, we know that the  precondition\n      // matched on the backend. We therefore must not have the expected version\n      // of the document in our cache and return an UnknownDocument with the\n      // known updateTime.\n      return new UnknownDocument(this.key, mutationResult.version);\n    }\n\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, mutationResult.version, newData, {\n      hasCommittedMutations: true\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const version = Mutation.getPostMutationVersion(maybeDoc);\n    const newData = this.patchDocument(maybeDoc);\n    return new Document(this.key, version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  extractBaseValue(maybeDoc: MaybeDocument | null): null {\n    return null;\n  }\n\n  isEqual(other: Mutation): boolean {\n    return (\n      other instanceof PatchMutation &&\n      this.key.isEqual(other.key) &&\n      this.fieldMask.isEqual(other.fieldMask) &&\n      this.precondition.isEqual(other.precondition)\n    );\n  }\n\n  /**\n   * Patches the data of document if available or creates a new document. Note\n   * that this does not check whether or not the precondition of this patch\n   * holds.\n   */\n  private patchDocument(maybeDoc: MaybeDocument | null): ObjectValue {\n    let data: ObjectValue;\n    if (maybeDoc instanceof Document) {\n      data = maybeDoc.data();\n    } else {\n      data = ObjectValue.empty();\n    }\n    return this.patchObject(data);\n  }\n\n  private patchObject(data: ObjectValue): ObjectValue {\n    const builder = new ObjectValueBuilder(data);\n    this.fieldMask.fields.forEach(fieldPath => {\n      if (!fieldPath.isEmpty()) {\n        const newValue = this.data.field(fieldPath);\n        if (newValue !== null) {\n          builder.set(fieldPath, newValue);\n        } else {\n          builder.delete(fieldPath);\n        }\n      }\n    });\n    return builder.build();\n  }\n}\n\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nexport class TransformMutation extends Mutation {\n  readonly type: MutationType = MutationType.Transform;\n\n  // NOTE: We set a precondition of exists: true as a safety-check, since we\n  // always combine TransformMutations with a SetMutation or PatchMutation which\n  // (if successful) should end up with an existing document.\n  readonly precondition = Precondition.exists(true);\n\n  constructor(\n    readonly key: DocumentKey,\n    readonly fieldTransforms: FieldTransform[]\n  ) {\n    super();\n  }\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument {\n    this.verifyKeyMatches(maybeDoc);\n\n    hardAssert(\n      mutationResult.transformResults != null,\n      'Transform results missing for TransformMutation.'\n    );\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      // Since the mutation was not rejected, we know that the  precondition\n      // matched on the backend. We therefore must not have the expected version\n      // of the document in our cache and return an UnknownDocument with the\n      // known updateTime.\n      return new UnknownDocument(this.key, mutationResult.version);\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const transformResults = this.serverTransformResults(\n      maybeDoc,\n      mutationResult.transformResults!\n    );\n\n    const version = mutationResult.version;\n    const newData = this.transformObject(doc.data(), transformResults);\n    return new Document(this.key, version, newData, {\n      hasCommittedMutations: true\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    const doc = this.requireDocument(maybeDoc);\n    const transformResults = this.localTransformResults(\n      localWriteTime,\n      maybeDoc,\n      baseDoc\n    );\n    const newData = this.transformObject(doc.data(), transformResults);\n    return new Document(this.key, doc.version, newData, {\n      hasLocalMutations: true\n    });\n  }\n\n  extractBaseValue(maybeDoc: MaybeDocument | null): ObjectValue | null {\n    let baseObject: ObjectValueBuilder | null = null;\n    for (const fieldTransform of this.fieldTransforms) {\n      const existingValue =\n        maybeDoc instanceof Document\n          ? maybeDoc.field(fieldTransform.field)\n          : undefined;\n      const coercedValue = fieldTransform.transform.computeBaseValue(\n        existingValue || null\n      );\n\n      if (coercedValue != null) {\n        if (baseObject == null) {\n          baseObject = new ObjectValueBuilder().set(\n            fieldTransform.field,\n            coercedValue\n          );\n        } else {\n          baseObject = baseObject.set(fieldTransform.field, coercedValue);\n        }\n      }\n    }\n    return baseObject ? baseObject.build() : null;\n  }\n\n  isEqual(other: Mutation): boolean {\n    return (\n      other instanceof TransformMutation &&\n      this.key.isEqual(other.key) &&\n      arrayEquals(this.fieldTransforms, other.fieldTransforms, (l, r) =>\n        l.isEqual(r)\n      ) &&\n      this.precondition.isEqual(other.precondition)\n    );\n  }\n\n  /**\n   * Asserts that the given MaybeDocument is actually a Document and verifies\n   * that it matches the key for this mutation. Since we only support\n   * transformations with precondition exists this method is guaranteed to be\n   * safe.\n   */\n  private requireDocument(maybeDoc: MaybeDocument | null): Document {\n    debugAssert(\n      maybeDoc instanceof Document,\n      'Unknown MaybeDocument type ' + maybeDoc\n    );\n    debugAssert(\n      maybeDoc.key.isEqual(this.key),\n      'Can only transform a document with the same key'\n    );\n    return maybeDoc;\n  }\n\n  /**\n   * Creates a list of \"transform results\" (a transform result is a field value\n   * representing the result of applying a transform) for use after a\n   * TransformMutation has been acknowledged by the server.\n   *\n   * @param baseDoc The document prior to applying this mutation batch.\n   * @param serverTransformResults The transform results received by the server.\n   * @return The transform results list.\n   */\n  private serverTransformResults(\n    baseDoc: MaybeDocument | null,\n    serverTransformResults: Array<api.Value | null>\n  ): api.Value[] {\n    const transformResults: api.Value[] = [];\n    hardAssert(\n      this.fieldTransforms.length === serverTransformResults.length,\n      `server transform result count (${serverTransformResults.length}) ` +\n        `should match field transform count (${this.fieldTransforms.length})`\n    );\n\n    for (let i = 0; i < serverTransformResults.length; i++) {\n      const fieldTransform = this.fieldTransforms[i];\n      const transform = fieldTransform.transform;\n      let previousValue: api.Value | null = null;\n      if (baseDoc instanceof Document) {\n        previousValue = baseDoc.field(fieldTransform.field);\n      }\n      transformResults.push(\n        transform.applyToRemoteDocument(\n          previousValue,\n          serverTransformResults[i]\n        )\n      );\n    }\n    return transformResults;\n  }\n\n  /**\n   * Creates a list of \"transform results\" (a transform result is a field value\n   * representing the result of applying a transform) for use when applying a\n   * TransformMutation locally.\n   *\n   * @param localWriteTime The local time of the transform mutation (used to\n   *     generate ServerTimestampValues).\n   * @param maybeDoc The current state of the document after applying all\n   *     previous mutations.\n   * @param baseDoc The document prior to applying this mutation batch.\n   * @return The transform results list.\n   */\n  private localTransformResults(\n    localWriteTime: Timestamp,\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null\n  ): api.Value[] {\n    const transformResults: api.Value[] = [];\n    for (const fieldTransform of this.fieldTransforms) {\n      const transform = fieldTransform.transform;\n\n      let previousValue: api.Value | null = null;\n      if (maybeDoc instanceof Document) {\n        previousValue = maybeDoc.field(fieldTransform.field);\n      }\n\n      if (previousValue === null && baseDoc instanceof Document) {\n        // If the current document does not contain a value for the mutated\n        // field, use the value that existed before applying this mutation\n        // batch. This solves an edge case where a PatchMutation clears the\n        // values in a nested map before the TransformMutation is applied.\n        previousValue = baseDoc.field(fieldTransform.field);\n      }\n\n      transformResults.push(\n        transform.applyToLocalView(previousValue, localWriteTime)\n      );\n    }\n    return transformResults;\n  }\n\n  private transformObject(\n    data: ObjectValue,\n    transformResults: api.Value[]\n  ): ObjectValue {\n    debugAssert(\n      transformResults.length === this.fieldTransforms.length,\n      'TransformResults length mismatch.'\n    );\n\n    const builder = new ObjectValueBuilder(data);\n    for (let i = 0; i < this.fieldTransforms.length; i++) {\n      const fieldTransform = this.fieldTransforms[i];\n      const fieldPath = fieldTransform.field;\n      builder.set(fieldPath, transformResults[i]);\n    }\n    return builder.build();\n  }\n}\n\n/** A mutation that deletes the document at the given key. */\nexport class DeleteMutation extends Mutation {\n  constructor(readonly key: DocumentKey, readonly precondition: Precondition) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Delete;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument {\n    this.verifyKeyMatches(maybeDoc);\n\n    debugAssert(\n      mutationResult.transformResults == null,\n      'Transform results received by DeleteMutation.'\n    );\n\n    // Unlike applyToLocalView, if we're applying a mutation to a remote\n    // document the server has accepted the mutation so the precondition must\n    // have held.\n\n    return new NoDocument(this.key, mutationResult.version, {\n      hasCommittedMutations: true\n    });\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    this.verifyKeyMatches(maybeDoc);\n\n    if (!this.precondition.isValidFor(maybeDoc)) {\n      return maybeDoc;\n    }\n\n    if (maybeDoc) {\n      debugAssert(\n        maybeDoc.key.isEqual(this.key),\n        'Can only apply mutation to document with same key'\n      );\n    }\n    return new NoDocument(this.key, SnapshotVersion.min());\n  }\n\n  extractBaseValue(maybeDoc: MaybeDocument | null): null {\n    return null;\n  }\n\n  isEqual(other: Mutation): boolean {\n    return (\n      other instanceof DeleteMutation &&\n      this.key.isEqual(other.key) &&\n      this.precondition.isEqual(other.precondition)\n    );\n  }\n}\n\n/**\n * A mutation that verifies the existence of the document at the given key with\n * the provided precondition.\n *\n * The `verify` operation is only used in Transactions, and this class serves\n * primarily to facilitate serialization into protos.\n */\nexport class VerifyMutation extends Mutation {\n  constructor(readonly key: DocumentKey, readonly precondition: Precondition) {\n    super();\n  }\n\n  readonly type: MutationType = MutationType.Verify;\n\n  applyToRemoteDocument(\n    maybeDoc: MaybeDocument | null,\n    mutationResult: MutationResult\n  ): MaybeDocument {\n    fail('VerifyMutation should only be used in Transactions.');\n  }\n\n  applyToLocalView(\n    maybeDoc: MaybeDocument | null,\n    baseDoc: MaybeDocument | null,\n    localWriteTime: Timestamp\n  ): MaybeDocument | null {\n    fail('VerifyMutation should only be used in Transactions.');\n  }\n\n  extractBaseValue(maybeDoc: MaybeDocument | null): null {\n    fail('VerifyMutation should only be used in Transactions.');\n  }\n\n  isEqual(other: Mutation): boolean {\n    return (\n      other instanceof VerifyMutation &&\n      this.key.isEqual(other.key) &&\n      this.precondition.isEqual(other.precondition)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../api/timestamp';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { BatchId } from '../core/types';\nimport { hardAssert, debugAssert } from '../util/assert';\nimport { arrayEquals } from '../util/misc';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  DocumentVersionMap,\n  documentVersionMap,\n  MaybeDocumentMap\n} from './collections';\nimport { MaybeDocument } from './document';\nimport { DocumentKey } from './document_key';\nimport { Mutation, MutationResult } from './mutation';\n\nexport const BATCHID_UNKNOWN = -1;\n\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nexport class MutationBatch {\n  /**\n   * @param batchId The unique ID of this mutation batch.\n   * @param localWriteTime The original write time of this mutation.\n   * @param baseMutations Mutations that are used to populate the base\n   * values when this mutation is applied locally. This can be used to locally\n   * overwrite values that are persisted in the remote document cache. Base\n   * mutations are never sent to the backend.\n   * @param mutations The user-provided mutations in this mutation batch.\n   * User-provided mutations are applied both locally and remotely on the\n   * backend.\n   */\n  constructor(\n    public batchId: BatchId,\n    public localWriteTime: Timestamp,\n    public baseMutations: Mutation[],\n    public mutations: Mutation[]\n  ) {\n    debugAssert(mutations.length > 0, 'Cannot create an empty mutation batch');\n  }\n\n  /**\n   * Applies all the mutations in this MutationBatch to the specified document\n   * to create a new remote document\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   * @param batchResult The result of applying the MutationBatch to the\n   * backend.\n   */\n  applyToRemoteDocument(\n    docKey: DocumentKey,\n    maybeDoc: MaybeDocument | null,\n    batchResult: MutationBatchResult\n  ): MaybeDocument | null {\n    if (maybeDoc) {\n      debugAssert(\n        maybeDoc.key.isEqual(docKey),\n        `applyToRemoteDocument: key ${docKey} should match maybeDoc key\n        ${maybeDoc.key}`\n      );\n    }\n\n    const mutationResults = batchResult.mutationResults;\n    debugAssert(\n      mutationResults.length === this.mutations.length,\n      `Mismatch between mutations length\n      (${this.mutations.length}) and mutation results length\n      (${mutationResults.length}).`\n    );\n\n    for (let i = 0; i < this.mutations.length; i++) {\n      const mutation = this.mutations[i];\n      if (mutation.key.isEqual(docKey)) {\n        const mutationResult = mutationResults[i];\n        maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n      }\n    }\n    return maybeDoc;\n  }\n\n  /**\n   * Computes the local view of a document given all the mutations in this\n   * batch.\n   *\n   * @param docKey The key of the document to apply mutations to.\n   * @param maybeDoc The document to apply mutations to.\n   */\n  applyToLocalView(\n    docKey: DocumentKey,\n    maybeDoc: MaybeDocument | null\n  ): MaybeDocument | null {\n    if (maybeDoc) {\n      debugAssert(\n        maybeDoc.key.isEqual(docKey),\n        `applyToLocalDocument: key ${docKey} should match maybeDoc key\n        ${maybeDoc.key}`\n      );\n    }\n\n    // First, apply the base state. This allows us to apply non-idempotent\n    // transform against a consistent set of values.\n    for (const mutation of this.baseMutations) {\n      if (mutation.key.isEqual(docKey)) {\n        maybeDoc = mutation.applyToLocalView(\n          maybeDoc,\n          maybeDoc,\n          this.localWriteTime\n        );\n      }\n    }\n\n    const baseDoc = maybeDoc;\n\n    // Second, apply all user-provided mutations.\n    for (const mutation of this.mutations) {\n      if (mutation.key.isEqual(docKey)) {\n        maybeDoc = mutation.applyToLocalView(\n          maybeDoc,\n          baseDoc,\n          this.localWriteTime\n        );\n      }\n    }\n    return maybeDoc;\n  }\n\n  /**\n   * Computes the local view for all provided documents given the mutations in\n   * this batch.\n   */\n  applyToLocalDocumentSet(maybeDocs: MaybeDocumentMap): MaybeDocumentMap {\n    // TODO(mrschmidt): This implementation is O(n^2). If we apply the mutations\n    // directly (as done in `applyToLocalView()`), we can reduce the complexity\n    // to O(n).\n    let mutatedDocuments = maybeDocs;\n    this.mutations.forEach(m => {\n      const mutatedDocument = this.applyToLocalView(\n        m.key,\n        maybeDocs.get(m.key)\n      );\n      if (mutatedDocument) {\n        mutatedDocuments = mutatedDocuments.insert(m.key, mutatedDocument);\n      }\n    });\n    return mutatedDocuments;\n  }\n\n  keys(): DocumentKeySet {\n    return this.mutations.reduce(\n      (keys, m) => keys.add(m.key),\n      documentKeySet()\n    );\n  }\n\n  isEqual(other: MutationBatch): boolean {\n    return (\n      this.batchId === other.batchId &&\n      arrayEquals(this.mutations, other.mutations, (l, r) => l.isEqual(r)) &&\n      arrayEquals(this.baseMutations, other.baseMutations, (l, r) =>\n        l.isEqual(r)\n      )\n    );\n  }\n}\n\n/** The result of applying a mutation batch to the backend. */\nexport class MutationBatchResult {\n  private constructor(\n    readonly batch: MutationBatch,\n    readonly commitVersion: SnapshotVersion,\n    readonly mutationResults: MutationResult[],\n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    readonly docVersions: DocumentVersionMap\n  ) {}\n\n  /**\n   * Creates a new MutationBatchResult for the given batch and results. There\n   * must be one result for each mutation in the batch. This static factory\n   * caches a document=>version mapping (docVersions).\n   */\n  static from(\n    batch: MutationBatch,\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ): MutationBatchResult {\n    hardAssert(\n      batch.mutations.length === results.length,\n      'Mutations sent ' +\n        batch.mutations.length +\n        ' must equal results received ' +\n        results.length\n    );\n\n    let versionMap = documentVersionMap();\n    const mutations = batch.mutations;\n    for (let i = 0; i < mutations.length; i++) {\n      versionMap = versionMap.insert(mutations[i].key, results[i].version);\n    }\n\n    return new MutationBatchResult(batch, commitVersion, results, versionMap);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Equatable } from './misc';\nimport { forEach, isEmpty } from './obj';\n\ntype Entry<K, V> = [K, V];\n\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nexport class ObjectMap<KeyType extends Equatable<KeyType>, ValueType> {\n  /**\n   * The inner map for a key -> value pair. Due to the possibility of\n   * collisions we keep a list of entries that we do a linear search through\n   * to find an actual match. Note that collisions should be rare, so we still\n   * expect near constant time lookups in practice.\n   */\n  private inner: {\n    [canonicalId: string]: Array<Entry<KeyType, ValueType>>;\n  } = {};\n\n  constructor(private mapKeyFn: (key: KeyType) => string) {}\n\n  /** Get a value for this key, or undefined if it does not exist. */\n  get(key: KeyType): ValueType | undefined {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      return undefined;\n    }\n    for (const [otherKey, value] of matches) {\n      if (otherKey.isEqual(key)) {\n        return value;\n      }\n    }\n    return undefined;\n  }\n\n  has(key: KeyType): boolean {\n    return this.get(key) !== undefined;\n  }\n\n  /** Put this key and value in the map. */\n  set(key: KeyType, value: ValueType): void {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      this.inner[id] = [[key, value]];\n      return;\n    }\n    for (let i = 0; i < matches.length; i++) {\n      if (matches[i][0].isEqual(key)) {\n        matches[i] = [key, value];\n        return;\n      }\n    }\n    matches.push([key, value]);\n  }\n\n  /**\n   * Remove this key from the map. Returns a boolean if anything was deleted.\n   */\n  delete(key: KeyType): boolean {\n    const id = this.mapKeyFn(key);\n    const matches = this.inner[id];\n    if (matches === undefined) {\n      return false;\n    }\n    for (let i = 0; i < matches.length; i++) {\n      if (matches[i][0].isEqual(key)) {\n        if (matches.length === 1) {\n          delete this.inner[id];\n        } else {\n          matches.splice(i, 1);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  forEach(fn: (key: KeyType, val: ValueType) => void): void {\n    forEach(this.inner, (_, entries) => {\n      for (const [k, v] of entries) {\n        fn(k, v);\n      }\n    });\n  }\n\n  isEmpty(): boolean {\n    return isEmpty(this.inner);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fail } from '../util/assert';\n\nexport type FulfilledHandler<T, R> =\n  | ((result: T) => R | PersistencePromise<R>)\n  | null;\nexport type RejectedHandler<R> =\n  | ((reason: Error) => R | PersistencePromise<R>)\n  | null;\nexport type Resolver<T> = (value?: T) => void;\nexport type Rejector = (error: Error) => void;\n\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nexport class PersistencePromise<T> {\n  // NOTE: next/catchCallback will always point to our own wrapper functions,\n  // not the user's raw next() or catch() callbacks.\n  private nextCallback: FulfilledHandler<T, unknown> = null;\n  private catchCallback: RejectedHandler<unknown> = null;\n\n  // When the operation resolves, we'll set result or error and mark isDone.\n  private result: T | undefined = undefined;\n  private error: Error | undefined = undefined;\n  private isDone = false;\n\n  // Set to true when .then() or .catch() are called and prevents additional\n  // chaining.\n  private callbackAttached = false;\n\n  constructor(callback: (resolve: Resolver<T>, reject: Rejector) => void) {\n    callback(\n      value => {\n        this.isDone = true;\n        this.result = value;\n        if (this.nextCallback) {\n          // value should be defined unless T is Void, but we can't express\n          // that in the type system.\n          this.nextCallback(value!);\n        }\n      },\n      error => {\n        this.isDone = true;\n        this.error = error;\n        if (this.catchCallback) {\n          this.catchCallback(error);\n        }\n      }\n    );\n  }\n\n  catch<R>(\n    fn: (error: Error) => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    return this.next(undefined, fn);\n  }\n\n  next<R>(\n    nextFn?: FulfilledHandler<T, R>,\n    catchFn?: RejectedHandler<R>\n  ): PersistencePromise<R> {\n    if (this.callbackAttached) {\n      fail('Called next() or catch() twice for PersistencePromise');\n    }\n    this.callbackAttached = true;\n    if (this.isDone) {\n      if (!this.error) {\n        return this.wrapSuccess(nextFn, this.result!);\n      } else {\n        return this.wrapFailure(catchFn, this.error);\n      }\n    } else {\n      return new PersistencePromise<R>((resolve, reject) => {\n        this.nextCallback = (value: T) => {\n          this.wrapSuccess(nextFn, value).next(resolve, reject);\n        };\n        this.catchCallback = (error: Error) => {\n          this.wrapFailure(catchFn, error).next(resolve, reject);\n        };\n      });\n    }\n  }\n\n  toPromise(): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.next(resolve, reject);\n    });\n  }\n\n  private wrapUserFunction<R>(\n    fn: () => R | PersistencePromise<R>\n  ): PersistencePromise<R> {\n    try {\n      const result = fn();\n      if (result instanceof PersistencePromise) {\n        return result;\n      } else {\n        return PersistencePromise.resolve(result);\n      }\n    } catch (e) {\n      return PersistencePromise.reject<R>(e);\n    }\n  }\n\n  private wrapSuccess<R>(\n    nextFn: FulfilledHandler<T, R> | undefined,\n    value: T\n  ): PersistencePromise<R> {\n    if (nextFn) {\n      return this.wrapUserFunction(() => nextFn(value));\n    } else {\n      // If there's no nextFn, then R must be the same as T\n      return PersistencePromise.resolve<R>((value as unknown) as R);\n    }\n  }\n\n  private wrapFailure<R>(\n    catchFn: RejectedHandler<R> | undefined,\n    error: Error\n  ): PersistencePromise<R> {\n    if (catchFn) {\n      return this.wrapUserFunction(() => catchFn(error));\n    } else {\n      return PersistencePromise.reject<R>(error);\n    }\n  }\n\n  static resolve(): PersistencePromise<void>;\n  static resolve<R>(result: R): PersistencePromise<R>;\n  static resolve<R>(result?: R): PersistencePromise<R | void> {\n    return new PersistencePromise<R | void>((resolve, reject) => {\n      resolve(result);\n    });\n  }\n\n  static reject<R>(error: Error): PersistencePromise<R> {\n    return new PersistencePromise<R>((resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  static waitFor(\n    // Accept all Promise types in waitFor().\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    all: { forEach: (cb: (el: PersistencePromise<any>) => void) => void }\n  ): PersistencePromise<void> {\n    return new PersistencePromise<void>((resolve, reject) => {\n      let expectedCount = 0;\n      let resolvedCount = 0;\n      let done = false;\n\n      all.forEach(element => {\n        ++expectedCount;\n        element.next(\n          () => {\n            ++resolvedCount;\n            if (done && resolvedCount === expectedCount) {\n              resolve();\n            }\n          },\n          err => reject(err)\n        );\n      });\n\n      done = true;\n      if (resolvedCount === expectedCount) {\n        resolve();\n      }\n    });\n  }\n\n  /**\n   * Given an array of predicate functions that asynchronously evaluate to a\n   * boolean, implements a short-circuiting `or` between the results. Predicates\n   * will be evaluated until one of them returns `true`, then stop. The final\n   * result will be whether any of them returned `true`.\n   */\n  static or(\n    predicates: Array<() => PersistencePromise<boolean>>\n  ): PersistencePromise<boolean> {\n    let p: PersistencePromise<boolean> = PersistencePromise.resolve<boolean>(\n      false\n    );\n    for (const predicate of predicates) {\n      p = p.next(isTrue => {\n        if (isTrue) {\n          return PersistencePromise.resolve<boolean>(isTrue);\n        } else {\n          return predicate();\n        }\n      });\n    }\n    return p;\n  }\n\n  /**\n   * Given an iterable, call the given function on each element in the\n   * collection and wait for all of the resulting concurrent PersistencePromises\n   * to resolve.\n   */\n  static forEach<R, S>(\n    collection: { forEach: (cb: (r: R, s: S) => void) => void },\n    f:\n      | ((r: R, s: S) => PersistencePromise<void>)\n      | ((r: R) => PersistencePromise<void>)\n  ): PersistencePromise<void>;\n  static forEach<R>(\n    collection: { forEach: (cb: (r: R) => void) => void },\n    f: (r: R) => PersistencePromise<void>\n  ): PersistencePromise<void>;\n  static forEach<R, S>(\n    collection: { forEach: (cb: (r: R, s?: S) => void) => void },\n    f: (r: R, s?: S) => PersistencePromise<void>\n  ): PersistencePromise<void> {\n    const promises: Array<PersistencePromise<void>> = [];\n    collection.forEach((r, s) => {\n      promises.push(f.call(this, r, s));\n    });\n    return this.waitFor(promises);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport {\n  DocumentKeySet,\n  documentKeySet,\n  DocumentMap,\n  documentMap,\n  MaybeDocumentMap,\n  maybeDocumentMap,\n  NullableMaybeDocumentMap,\n  nullableMaybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { ResourcePath } from '../model/path';\n\nimport { debugAssert } from '../util/assert';\nimport { IndexManager } from './index_manager';\nimport { MutationQueue } from './mutation_queue';\nimport { PatchMutation } from '../model/mutation';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\n\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nexport class LocalDocumentsView {\n  constructor(\n    readonly remoteDocumentCache: RemoteDocumentCache,\n    readonly mutationQueue: MutationQueue,\n    readonly indexManager: IndexManager\n  ) {}\n\n  /**\n   * Get the local view of the document identified by `key`.\n   *\n   * @return Local view of the document or null if we don't have any cached\n   * state for it.\n   */\n  getDocument(\n    transaction: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.mutationQueue\n      .getAllMutationBatchesAffectingDocumentKey(transaction, key)\n      .next(batches => this.getDocumentInternal(transaction, key, batches));\n  }\n\n  /** Internal version of `getDocument` that allows reusing batches. */\n  private getDocumentInternal(\n    transaction: PersistenceTransaction,\n    key: DocumentKey,\n    inBatches: MutationBatch[]\n  ): PersistencePromise<MaybeDocument | null> {\n    return this.remoteDocumentCache.getEntry(transaction, key).next(doc => {\n      for (const batch of inBatches) {\n        doc = batch.applyToLocalView(key, doc);\n      }\n      return doc;\n    });\n  }\n\n  // Returns the view of the given `docs` as they would appear after applying\n  // all mutations in the given `batches`.\n  private applyLocalMutationsToDocuments(\n    transaction: PersistenceTransaction,\n    docs: NullableMaybeDocumentMap,\n    batches: MutationBatch[]\n  ): NullableMaybeDocumentMap {\n    let results = nullableMaybeDocumentMap();\n    docs.forEach((key, localView) => {\n      for (const batch of batches) {\n        localView = batch.applyToLocalView(key, localView);\n      }\n      results = results.insert(key, localView);\n    });\n    return results;\n  }\n\n  /**\n   * Gets the local view of the documents identified by `keys`.\n   *\n   * If we don't have cached state for a document in `keys`, a NoDocument will\n   * be stored for that key in the resulting set.\n   */\n  getDocuments(\n    transaction: PersistenceTransaction,\n    keys: DocumentKeySet\n  ): PersistencePromise<MaybeDocumentMap> {\n    return this.remoteDocumentCache\n      .getEntries(transaction, keys)\n      .next(docs => this.getLocalViewOfDocuments(transaction, docs));\n  }\n\n  /**\n   * Similar to `getDocuments`, but creates the local view from the given\n   * `baseDocs` without retrieving documents from the local store.\n   */\n  getLocalViewOfDocuments(\n    transaction: PersistenceTransaction,\n    baseDocs: NullableMaybeDocumentMap\n  ): PersistencePromise<MaybeDocumentMap> {\n    return this.mutationQueue\n      .getAllMutationBatchesAffectingDocumentKeys(transaction, baseDocs)\n      .next(batches => {\n        const docs = this.applyLocalMutationsToDocuments(\n          transaction,\n          baseDocs,\n          batches\n        );\n        let results = maybeDocumentMap();\n        docs.forEach((key, maybeDoc) => {\n          // TODO(http://b/32275378): Don't conflate missing / deleted.\n          if (!maybeDoc) {\n            maybeDoc = new NoDocument(key, SnapshotVersion.min());\n          }\n          results = results.insert(key, maybeDoc);\n        });\n\n        return results;\n      });\n  }\n\n  /**\n   * Performs a query against the local view of all documents.\n   *\n   * @param transaction The persistence transaction.\n   * @param query The query to match documents against.\n   * @param sinceReadTime If not set to SnapshotVersion.min(), return only\n   *     documents that have been read since this snapshot version (exclusive).\n   */\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query,\n    sinceReadTime: SnapshotVersion\n  ): PersistencePromise<DocumentMap> {\n    if (query.isDocumentQuery()) {\n      return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n    } else if (query.isCollectionGroupQuery()) {\n      return this.getDocumentsMatchingCollectionGroupQuery(\n        transaction,\n        query,\n        sinceReadTime\n      );\n    } else {\n      return this.getDocumentsMatchingCollectionQuery(\n        transaction,\n        query,\n        sinceReadTime\n      );\n    }\n  }\n\n  private getDocumentsMatchingDocumentQuery(\n    transaction: PersistenceTransaction,\n    docPath: ResourcePath\n  ): PersistencePromise<DocumentMap> {\n    // Just do a simple document lookup.\n    return this.getDocument(transaction, new DocumentKey(docPath)).next(\n      maybeDoc => {\n        let result = documentMap();\n        if (maybeDoc instanceof Document) {\n          result = result.insert(maybeDoc.key, maybeDoc);\n        }\n        return result;\n      }\n    );\n  }\n\n  private getDocumentsMatchingCollectionGroupQuery(\n    transaction: PersistenceTransaction,\n    query: Query,\n    sinceReadTime: SnapshotVersion\n  ): PersistencePromise<DocumentMap> {\n    debugAssert(\n      query.path.isEmpty(),\n      'Currently we only support collection group queries at the root.'\n    );\n    const collectionId = query.collectionGroup!;\n    let results = documentMap();\n    return this.indexManager\n      .getCollectionParents(transaction, collectionId)\n      .next(parents => {\n        // Perform a collection query against each parent that contains the\n        // collectionId and aggregate the results.\n        return PersistencePromise.forEach(parents, (parent: ResourcePath) => {\n          const collectionQuery = query.asCollectionQueryAtPath(\n            parent.child(collectionId)\n          );\n          return this.getDocumentsMatchingCollectionQuery(\n            transaction,\n            collectionQuery,\n            sinceReadTime\n          ).next(r => {\n            r.forEach((key, doc) => {\n              results = results.insert(key, doc);\n            });\n          });\n        }).next(() => results);\n      });\n  }\n\n  private getDocumentsMatchingCollectionQuery(\n    transaction: PersistenceTransaction,\n    query: Query,\n    sinceReadTime: SnapshotVersion\n  ): PersistencePromise<DocumentMap> {\n    // Query the remote documents and overlay mutations.\n    let results: DocumentMap;\n    let mutationBatches: MutationBatch[];\n    return this.remoteDocumentCache\n      .getDocumentsMatchingQuery(transaction, query, sinceReadTime)\n      .next(queryResults => {\n        results = queryResults;\n        return this.mutationQueue.getAllMutationBatchesAffectingQuery(\n          transaction,\n          query\n        );\n      })\n      .next(matchingMutationBatches => {\n        mutationBatches = matchingMutationBatches;\n        // It is possible that a PatchMutation can make a document match a query, even if\n        // the version in the RemoteDocumentCache is not a match yet (waiting for server\n        // to ack). To handle this, we find all document keys affected by the PatchMutations\n        // that are not in `result` yet, and back fill them via `remoteDocumentCache.getEntries`,\n        // otherwise those `PatchMutations` will be ignored because no base document can be found,\n        // and lead to missing result for the query.\n        return this.addMissingBaseDocuments(\n          transaction,\n          mutationBatches,\n          results\n        ).next(mergedDocuments => {\n          results = mergedDocuments;\n\n          for (const batch of mutationBatches) {\n            for (const mutation of batch.mutations) {\n              const key = mutation.key;\n              const baseDoc = results.get(key);\n              const mutatedDoc = mutation.applyToLocalView(\n                baseDoc,\n                baseDoc,\n                batch.localWriteTime\n              );\n              if (mutatedDoc instanceof Document) {\n                results = results.insert(key, mutatedDoc);\n              } else {\n                results = results.remove(key);\n              }\n            }\n          }\n        });\n      })\n      .next(() => {\n        // Finally, filter out any documents that don't actually match\n        // the query.\n        results.forEach((key, doc) => {\n          if (!query.matches(doc)) {\n            results = results.remove(key);\n          }\n        });\n\n        return results;\n      });\n  }\n\n  private addMissingBaseDocuments(\n    transaction: PersistenceTransaction,\n    matchingMutationBatches: MutationBatch[],\n    existingDocuments: DocumentMap\n  ): PersistencePromise<DocumentMap> {\n    let missingBaseDocEntriesForPatching = documentKeySet();\n    for (const batch of matchingMutationBatches) {\n      for (const mutation of batch.mutations) {\n        if (\n          mutation instanceof PatchMutation &&\n          existingDocuments.get(mutation.key) === null\n        ) {\n          missingBaseDocEntriesForPatching = missingBaseDocEntriesForPatching.add(\n            mutation.key\n          );\n        }\n      }\n    }\n\n    let mergedDocuments = existingDocuments;\n    return this.remoteDocumentCache\n      .getEntries(transaction, missingBaseDocEntriesForPatching)\n      .next(missingBaseDocs => {\n        missingBaseDocs.forEach((key, doc) => {\n          if (doc !== null && doc instanceof Document) {\n            mergedDocuments = mergedDocuments.insert(key, doc);\n          }\n        });\n        return mergedDocuments;\n      });\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { ListenSequenceNumber, TargetId } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { IndexManager } from './index_manager';\nimport { LocalStore } from './local_store';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistencePromise } from './persistence_promise';\nimport { TargetCache } from './target_cache';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { TargetData } from './target_data';\n\nexport const PRIMARY_LEASE_LOST_ERROR_MSG =\n  'The current tab is not in the required state to perform this operation. ' +\n  'It might be necessary to refresh the browser tab.';\n\n/**\n * A base class representing a persistence transaction, encapsulating both the\n * transaction's sequence numbers as well as a list of onCommitted listeners.\n *\n * When you call Persistence.runTransaction(), it will create a transaction and\n * pass it to your callback. You then pass it to any method that operates\n * on persistence.\n */\nexport abstract class PersistenceTransaction {\n  private readonly onCommittedListeners: Array<() => void> = [];\n\n  abstract readonly currentSequenceNumber: ListenSequenceNumber;\n\n  addOnCommittedListener(listener: () => void): void {\n    this.onCommittedListeners.push(listener);\n  }\n\n  raiseOnCommittedEvent(): void {\n    this.onCommittedListeners.forEach(listener => listener());\n  }\n}\n\n/** The different modes supported by `IndexedDbPersistence.runTransaction()`. */\nexport type PersistenceTransactionMode =\n  | 'readonly'\n  | 'readwrite'\n  | 'readwrite-primary';\n\n/**\n * Callback type for primary state notifications. This callback can be\n * registered with the persistence layer to get notified when we transition from\n * primary to secondary state and vice versa.\n *\n * Note: Instances can only toggle between Primary and Secondary state if\n * IndexedDB persistence is enabled and multiple clients are active. If this\n * listener is registered with MemoryPersistence, the callback will be called\n * exactly once marking the current instance as Primary.\n */\nexport type PrimaryStateListener = (isPrimary: boolean) => Promise<void>;\n\n/**\n * A ReferenceDelegate instance handles all of the hooks into the document-reference lifecycle. This\n * includes being added to a target, being removed from a target, being subject to mutation, and\n * being mutated by the user.\n *\n * Different implementations may do different things with each of these events. Not every\n * implementation needs to do something with every lifecycle hook.\n *\n * PORTING NOTE: since sequence numbers are attached to transactions in this\n * client, the ReferenceDelegate does not need to deal in transactional\n * semantics (onTransactionStarted/Committed()), nor does it need to track and\n * generate sequence numbers (getCurrentSequenceNumber()).\n */\nexport interface ReferenceDelegate {\n  /** Notify the delegate that the given document was added to a target. */\n  addReference(\n    txn: PersistenceTransaction,\n    targetId: TargetId,\n    doc: DocumentKey\n  ): PersistencePromise<void>;\n\n  /** Notify the delegate that the given document was removed from a target. */\n  removeReference(\n    txn: PersistenceTransaction,\n    targetId: TargetId,\n    doc: DocumentKey\n  ): PersistencePromise<void>;\n\n  /**\n   * Notify the delegate that a target was removed. The delegate may, but is not obligated to,\n   * actually delete the target and associated data.\n   */\n  removeTarget(\n    txn: PersistenceTransaction,\n    targetData: TargetData\n  ): PersistencePromise<void>;\n\n  /**\n   * Notify the delegate that a document may no longer be part of any views or\n   * have any mutations associated.\n   */\n  markPotentiallyOrphaned(\n    txn: PersistenceTransaction,\n    doc: DocumentKey\n  ): PersistencePromise<void>;\n\n  /** Notify the delegate that a limbo document was updated. */\n  updateLimboDocument(\n    txn: PersistenceTransaction,\n    doc: DocumentKey\n  ): PersistencePromise<void>;\n}\n\n/**\n * Persistence is the lowest-level shared interface to persistent storage in\n * Firestore.\n *\n * Persistence is used to create MutationQueue and RemoteDocumentCache\n * instances backed by persistence (which might be in-memory or LevelDB).\n *\n * Persistence also exposes an API to create and run PersistenceTransactions\n * against persistence. All read / write operations must be wrapped in a\n * transaction. Implementations of PersistenceTransaction / Persistence only\n * need to guarantee that writes made against the transaction are not made to\n * durable storage until the transaction resolves its PersistencePromise.\n * Since memory-only storage components do not alter durable storage, they are\n * free to ignore the transaction.\n *\n * This contract is enough to allow the LocalStore be be written\n * independently of whether or not the stored state actually is durably\n * persisted. If persistent storage is enabled, writes are grouped together to\n * avoid inconsistent state that could cause crashes.\n *\n * Concretely, when persistent storage is enabled, the persistent versions of\n * MutationQueue, RemoteDocumentCache, and others (the mutators) will\n * defer their writes into a transaction. Once the local store has completed\n * one logical operation, it commits the transaction.\n *\n * When persistent storage is disabled, the non-persistent versions of the\n * mutators ignore the transaction. This short-cut is allowed because\n * memory-only storage leaves no state so it cannot be inconsistent.\n *\n * This simplifies the implementations of the mutators and allows memory-only\n * implementations to supplement the persistent ones without requiring any\n * special dual-store implementation of Persistence. The cost is that the\n * LocalStore needs to be slightly careful about the order of its reads and\n * writes in order to avoid relying on being able to read back uncommitted\n * writes.\n */\nexport interface Persistence {\n  /**\n   * Whether or not this persistence instance has been started.\n   */\n  readonly started: boolean;\n\n  readonly referenceDelegate: ReferenceDelegate;\n\n  /** Starts persistence. */\n  start(): Promise<void>;\n\n  /**\n   * Releases any resources held during eager shutdown.\n   */\n  shutdown(): Promise<void>;\n\n  /**\n   * Registers a listener that gets called when the database receives a\n   * version change event indicating that it has deleted.\n   *\n   * PORTING NOTE: This is only used for Web multi-tab.\n   */\n  setDatabaseDeletedListener(\n    databaseDeletedListener: () => Promise<void>\n  ): void;\n\n  /**\n   * Returns a MutationQueue representing the persisted mutations for the\n   * given user.\n   *\n   * Note: The implementation is free to return the same instance every time\n   * this is called for a given user. In particular, the memory-backed\n   * implementation does this to emulate the persisted implementation to the\n   * extent possible (e.g. in the case of uid switching from\n   * sally=>jack=>sally, sally's mutation queue will be preserved).\n   */\n  getMutationQueue(user: User): MutationQueue;\n\n  /**\n   * Returns a TargetCache representing the persisted cache of targets.\n   *\n   * Note: The implementation is free to return the same instance every time\n   * this is called. In particular, the memory-backed implementation does this\n   * to emulate the persisted implementation to the extent possible.\n   */\n  getTargetCache(): TargetCache;\n\n  /**\n   * Returns a RemoteDocumentCache representing the persisted cache of remote\n   * documents.\n   *\n   * Note: The implementation is free to return the same instance every time\n   * this is called. In particular, the memory-backed implementation does this\n   * to emulate the persisted implementation to the extent possible.\n   */\n  getRemoteDocumentCache(): RemoteDocumentCache;\n\n  /**\n   * Returns an IndexManager instance that manages our persisted query indexes.\n   *\n   * Note: The implementation is free to return the same instance every time\n   * this is called. In particular, the memory-backed implementation does this\n   * to emulate the persisted implementation to the extent possible.\n   */\n  getIndexManager(): IndexManager;\n\n  /**\n   * Performs an operation inside a persistence transaction. Any reads or writes\n   * against persistence must be performed within a transaction. Writes will be\n   * committed atomically once the transaction completes.\n   *\n   * Persistence operations are asynchronous and therefore the provided\n   * transactionOperation must return a PersistencePromise. When it is resolved,\n   * the transaction will be committed and the Promise returned by this method\n   * will resolve.\n   *\n   * @param action A description of the action performed by this transaction,\n   * used for logging.\n   * @param mode The underlying mode of the IndexedDb transaction. Can be\n   * 'readonly`, 'readwrite' or 'readwrite-primary'. Transactions marked\n   * 'readwrite-primary' can only be executed by the primary client. In this\n   * mode, the transactionOperation will not be run if the primary lease cannot\n   * be acquired and the returned promise will be rejected with a\n   * FAILED_PRECONDITION error.\n   * @param transactionOperation The operation to run inside a transaction.\n   * @return A promise that is resolved once the transaction completes.\n   */\n  runTransaction<T>(\n    action: string,\n    mode: PersistenceTransactionMode,\n    transactionOperation: (\n      transaction: PersistenceTransaction\n    ) => PersistencePromise<T>\n  ): Promise<T>;\n}\n\n/**\n * Interface implemented by the LRU scheduler to start(), stop() and restart\n * garbage collection.\n */\nexport interface GarbageCollectionScheduler {\n  readonly started: boolean;\n  start(localStore: LocalStore): void;\n  stop(): void;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Target } from '../core/target';\nimport { ListenSequenceNumber, TargetId } from '../core/types';\nimport { ByteString } from '../util/byte_string';\n\n/** An enumeration of the different purposes we have for targets. */\nexport const enum TargetPurpose {\n  /** A regular, normal query target. */\n  Listen,\n\n  /**\n   * The query target was used to refill a query after an existence filter mismatch.\n   */\n  ExistenceFilterMismatch,\n\n  /** The query target was used to resolve a limbo document. */\n  LimboResolution\n}\n\n/**\n * An immutable set of metadata that the local store tracks for each target.\n */\nexport class TargetData {\n  constructor(\n    /** The target being listened to. */\n    readonly target: Target,\n    /**\n     * The target ID to which the target corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    readonly targetId: TargetId,\n    /** The purpose of the target. */\n    readonly purpose: TargetPurpose,\n    /**\n     * The sequence number of the last transaction during which this target data\n     * was modified.\n     */\n    readonly sequenceNumber: ListenSequenceNumber,\n    /** The latest snapshot version seen for this target. */\n    readonly snapshotVersion: SnapshotVersion = SnapshotVersion.min(),\n    /**\n     * The maximum snapshot version at which the associated view\n     * contained no limbo documents.\n     */\n    readonly lastLimboFreeSnapshotVersion: SnapshotVersion = SnapshotVersion.min(),\n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    readonly resumeToken: ByteString = ByteString.EMPTY_BYTE_STRING\n  ) {}\n\n  /** Creates a new target data instance with an updated sequence number. */\n  withSequenceNumber(sequenceNumber: number): TargetData {\n    return new TargetData(\n      this.target,\n      this.targetId,\n      this.purpose,\n      sequenceNumber,\n      this.snapshotVersion,\n      this.lastLimboFreeSnapshotVersion,\n      this.resumeToken\n    );\n  }\n\n  /**\n   * Creates a new target data instance with an updated resume token and\n   * snapshot version.\n   */\n  withResumeToken(\n    resumeToken: ByteString,\n    snapshotVersion: SnapshotVersion\n  ): TargetData {\n    return new TargetData(\n      this.target,\n      this.targetId,\n      this.purpose,\n      this.sequenceNumber,\n      snapshotVersion,\n      this.lastLimboFreeSnapshotVersion,\n      resumeToken\n    );\n  }\n\n  /**\n   * Creates a new target data instance with an updated last limbo free\n   * snapshot version number.\n   */\n  withLastLimboFreeSnapshotVersion(\n    lastLimboFreeSnapshotVersion: SnapshotVersion\n  ): TargetData {\n    return new TargetData(\n      this.target,\n      this.targetId,\n      this.purpose,\n      this.sequenceNumber,\n      this.snapshotVersion,\n      lastLimboFreeSnapshotVersion,\n      this.resumeToken\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface Resolver<R> {\n  (value?: R | Promise<R>): void;\n}\n\nexport interface Rejecter {\n  (reason?: Error): void;\n}\n\nexport class Deferred<R = void> {\n  promise: Promise<R>;\n  // Assigned synchronously in constructor by Promise constructor callback.\n  resolve!: Resolver<R>;\n  reject!: Rejecter;\n\n  constructor() {\n    this.promise = new Promise((resolve: Resolver<R>, reject: Rejecter) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    });\n  }\n}\n\n/**\n * Takes an array of values and a function from a value to a Promise. The function is run on each\n * value sequentially, waiting for the previous promise to resolve before starting the next one.\n * The returned promise resolves once the function has been run on all values.\n */\nexport function sequence<T>(\n  values: T[],\n  fn: (value: T) => Promise<void>\n): Promise<void> {\n  let p = Promise.resolve();\n  for (const value of values) {\n    p = p.then(() => fn(value));\n  }\n  return p;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ResourcePath } from '../model/path';\nimport { debugAssert } from '../util/assert';\nimport { SortedSet } from '../util/sorted_set';\nimport { IndexManager } from './index_manager';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\n\n/**\n * An in-memory implementation of IndexManager.\n */\nexport class MemoryIndexManager implements IndexManager {\n  private collectionParentIndex = new MemoryCollectionParentIndex();\n\n  addToCollectionParentIndex(\n    transaction: PersistenceTransaction,\n    collectionPath: ResourcePath\n  ): PersistencePromise<void> {\n    this.collectionParentIndex.add(collectionPath);\n    return PersistencePromise.resolve();\n  }\n\n  getCollectionParents(\n    transaction: PersistenceTransaction,\n    collectionId: string\n  ): PersistencePromise<ResourcePath[]> {\n    return PersistencePromise.resolve(\n      this.collectionParentIndex.getEntries(collectionId)\n    );\n  }\n}\n\n/**\n * Internal implementation of the collection-parent index exposed by MemoryIndexManager.\n * Also used for in-memory caching by IndexedDbIndexManager and initial index population\n * in indexeddb_schema.ts\n */\nexport class MemoryCollectionParentIndex {\n  private index = {} as {\n    [collectionId: string]: SortedSet<ResourcePath>;\n  };\n\n  // Returns false if the entry already existed.\n  add(collectionPath: ResourcePath): boolean {\n    debugAssert(collectionPath.length % 2 === 1, 'Expected a collection path.');\n    const collectionId = collectionPath.lastSegment();\n    const parentPath = collectionPath.popLast();\n    const existingParents =\n      this.index[collectionId] ||\n      new SortedSet<ResourcePath>(ResourcePath.comparator);\n    const added = !existingParents.has(parentPath);\n    this.index[collectionId] = existingParents.add(parentPath);\n    return added;\n  }\n\n  has(collectionPath: ResourcePath): boolean {\n    const collectionId = collectionPath.lastSegment();\n    const parentPath = collectionPath.popLast();\n    const existingParents = this.index[collectionId];\n    return existingParents && existingParents.has(parentPath);\n  }\n\n  getEntries(collectionId: string): ResourcePath[] {\n    const parentPaths =\n      this.index[collectionId] ||\n      new SortedSet<ResourcePath>(ResourcePath.comparator);\n    return parentPaths.toArray();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentKeySet, NullableMaybeDocumentMap } from '../model/collections';\nimport { MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { debugAssert } from '../util/assert';\nimport { ObjectMap } from '../util/obj_map';\n\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { SnapshotVersion } from '../core/snapshot_version';\n\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * Entries added to the cache *must* be read first. This is to facilitate\n * calculating the size delta of the pending changes.\n *\n * PORTING NOTE: This class was implemented then removed from other platforms.\n * If byte-counting ends up being needed on the other platforms, consider\n * porting this class as part of that implementation work.\n */\nexport abstract class RemoteDocumentChangeBuffer {\n  // A mapping of document key to the new cache entry that should be written (or null if any\n  // existing cache entry should be removed).\n  protected changes: ObjectMap<\n    DocumentKey,\n    MaybeDocument | null\n  > = new ObjectMap(key => key.toString());\n\n  // The read time to use for all added documents in this change buffer.\n  private _readTime: SnapshotVersion | undefined;\n\n  private changesApplied = false;\n\n  protected abstract getFromCache(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null>;\n\n  protected abstract getAllFromCache(\n    transaction: PersistenceTransaction,\n    documentKeys: DocumentKeySet\n  ): PersistencePromise<NullableMaybeDocumentMap>;\n\n  protected abstract applyChanges(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<void>;\n\n  protected set readTime(value: SnapshotVersion) {\n    // Right now (for simplicity) we just track a single readTime for all the\n    // added entries since we expect them to all be the same, but we could\n    // rework to store per-entry readTimes if necessary.\n    debugAssert(\n      this._readTime === undefined || this._readTime.isEqual(value),\n      'All changes in a RemoteDocumentChangeBuffer must have the same read time'\n    );\n    this._readTime = value;\n  }\n\n  protected get readTime(): SnapshotVersion {\n    debugAssert(\n      this._readTime !== undefined,\n      'Read time is not set. All removeEntry() calls must include a readTime if `trackRemovals` is used.'\n    );\n    return this._readTime;\n  }\n\n  /**\n   * Buffers a `RemoteDocumentCache.addEntry()` call.\n   *\n   * You can only modify documents that have already been retrieved via\n   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n   */\n  addEntry(maybeDocument: MaybeDocument, readTime: SnapshotVersion): void {\n    this.assertNotApplied();\n    this.readTime = readTime;\n    this.changes.set(maybeDocument.key, maybeDocument);\n  }\n\n  /**\n   * Buffers a `RemoteDocumentCache.removeEntry()` call.\n   *\n   * You can only remove documents that have already been retrieved via\n   * `getEntry()/getEntries()` (enforced via IndexedDbs `apply()`).\n   */\n  removeEntry(key: DocumentKey, readTime?: SnapshotVersion): void {\n    this.assertNotApplied();\n    if (readTime) {\n      this.readTime = readTime;\n    }\n    this.changes.set(key, null);\n  }\n\n  /**\n   * Looks up an entry in the cache. The buffered changes will first be checked,\n   * and if no buffered change applies, this will forward to\n   * `RemoteDocumentCache.getEntry()`.\n   *\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKey The key of the entry to look up.\n   * @return The cached Document or NoDocument entry, or null if we have nothing\n   * cached.\n   */\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    this.assertNotApplied();\n    const bufferedEntry = this.changes.get(documentKey);\n    if (bufferedEntry !== undefined) {\n      return PersistencePromise.resolve<MaybeDocument | null>(bufferedEntry);\n    } else {\n      return this.getFromCache(transaction, documentKey);\n    }\n  }\n\n  /**\n   * Looks up several entries in the cache, forwarding to\n   * `RemoteDocumentCache.getEntry()`.\n   *\n   * @param transaction The transaction in which to perform any persistence\n   *     operations.\n   * @param documentKeys The keys of the entries to look up.\n   * @return A map of cached `Document`s or `NoDocument`s, indexed by key. If an\n   *     entry cannot be found, the corresponding key will be mapped to a null\n   *     value.\n   */\n  getEntries(\n    transaction: PersistenceTransaction,\n    documentKeys: DocumentKeySet\n  ): PersistencePromise<NullableMaybeDocumentMap> {\n    return this.getAllFromCache(transaction, documentKeys);\n  }\n\n  /**\n   * Applies buffered changes to the underlying RemoteDocumentCache, using\n   * the provided transaction.\n   */\n  apply(transaction: PersistenceTransaction): PersistencePromise<void> {\n    this.assertNotApplied();\n    this.changesApplied = true;\n    return this.applyChanges(transaction);\n  }\n\n  /** Helper to assert this.changes is not null  */\n  protected assertNotApplied(): void {\n    debugAssert(!this.changesApplied, 'Changes have already been applied.');\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TargetId } from './types';\n\n/** Offset to ensure non-overlapping target ids. */\nconst OFFSET = 2;\n\n/**\n * Generates monotonically increasing target IDs for sending targets to the\n * watch stream.\n *\n * The client constructs two generators, one for the target cache, and one for\n * for the sync engine (to generate limbo documents targets). These\n * generators produce non-overlapping IDs (by using even and odd IDs\n * respectively).\n *\n * By separating the target ID space, the query cache can generate target IDs\n * that persist across client restarts, while sync engine can independently\n * generate in-memory target IDs that are transient and can be reused after a\n * restart.\n */\nexport class TargetIdGenerator {\n  constructor(private lastId: number) {}\n\n  next(): TargetId {\n    this.lastId += OFFSET;\n    return this.lastId;\n  }\n\n  static forTargetCache(): TargetIdGenerator {\n    // The target cache generator must return '2' in its first call to `next()`\n    // as there is no differentiation in the protocol layer between an unset\n    // number and the number '0'. If we were to sent a target with target ID\n    // '0', the backend would consider it unset and replace it with its own ID.\n    return new TargetIdGenerator(2 - OFFSET);\n  }\n\n  static forSyncEngine(): TargetIdGenerator {\n    // Sync engine assigns target IDs for limbo document detection.\n    return new TargetIdGenerator(1 - OFFSET);\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ListenSequence } from '../core/listen_sequence';\nimport { ListenSequenceNumber, TargetId } from '../core/types';\nimport { debugAssert } from '../util/assert';\nimport { AsyncQueue, DelayedOperation, TimerId } from '../util/async_queue';\nimport { getLogLevel, logDebug, LogLevel } from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedMap } from '../util/sorted_map';\nimport { SortedSet } from '../util/sorted_set';\nimport { ignoreIfPrimaryLeaseLoss, LocalStore } from './local_store';\nimport {\n  GarbageCollectionScheduler,\n  PersistenceTransaction\n} from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { TargetData } from './target_data';\nimport { isIndexedDbTransactionError } from './simple_db';\n\nconst LOG_TAG = 'LruGarbageCollector';\n\n/**\n * Persistence layers intending to use LRU Garbage collection should have reference delegates that\n * implement this interface. This interface defines the operations that the LRU garbage collector\n * needs from the persistence layer.\n */\nexport interface LruDelegate {\n  readonly garbageCollector: LruGarbageCollector;\n\n  /** Enumerates all the targets in the TargetCache. */\n  forEachTarget(\n    txn: PersistenceTransaction,\n    f: (target: TargetData) => void\n  ): PersistencePromise<void>;\n\n  getSequenceNumberCount(\n    txn: PersistenceTransaction\n  ): PersistencePromise<number>;\n\n  /**\n   * Enumerates sequence numbers for documents not associated with a target.\n   * Note that this may include duplicate sequence numbers.\n   */\n  forEachOrphanedDocumentSequenceNumber(\n    txn: PersistenceTransaction,\n    f: (sequenceNumber: ListenSequenceNumber) => void\n  ): PersistencePromise<void>;\n\n  /**\n   * Removes all targets that have a sequence number less than or equal to `upperBound`, and are not\n   * present in the `activeTargetIds` set.\n   *\n   * @return the number of targets removed.\n   */\n  removeTargets(\n    txn: PersistenceTransaction,\n    upperBound: ListenSequenceNumber,\n    activeTargetIds: ActiveTargets\n  ): PersistencePromise<number>;\n\n  /**\n   * Removes all unreferenced documents from the cache that have a sequence number less than or\n   * equal to the given `upperBound`.\n   *\n   * @return the number of documents removed.\n   */\n  removeOrphanedDocuments(\n    txn: PersistenceTransaction,\n    upperBound: ListenSequenceNumber\n  ): PersistencePromise<number>;\n\n  getCacheSize(txn: PersistenceTransaction): PersistencePromise<number>;\n}\n\n/**\n * Describes a map whose keys are active target ids. We do not care about the type of the\n * values.\n */\nexport type ActiveTargets = SortedMap<TargetId, unknown>;\n\n// The type and comparator for the items contained in the SortedSet used in\n// place of a priority queue for the RollingSequenceNumberBuffer.\ntype BufferEntry = [ListenSequenceNumber, number];\nfunction bufferEntryComparator(\n  [aSequence, aIndex]: BufferEntry,\n  [bSequence, bIndex]: BufferEntry\n): number {\n  const seqCmp = primitiveComparator(aSequence, bSequence);\n  if (seqCmp === 0) {\n    // This order doesn't matter, but we can bias against churn by sorting\n    // entries created earlier as less than newer entries.\n    return primitiveComparator(aIndex, bIndex);\n  } else {\n    return seqCmp;\n  }\n}\n\n/**\n * Used to calculate the nth sequence number. Keeps a rolling buffer of the\n * lowest n values passed to `addElement`, and finally reports the largest of\n * them in `maxValue`.\n */\nclass RollingSequenceNumberBuffer {\n  private buffer: SortedSet<BufferEntry> = new SortedSet<BufferEntry>(\n    bufferEntryComparator\n  );\n\n  private previousIndex = 0;\n\n  constructor(private readonly maxElements: number) {}\n\n  private nextIndex(): number {\n    return ++this.previousIndex;\n  }\n\n  addElement(sequenceNumber: ListenSequenceNumber): void {\n    const entry: BufferEntry = [sequenceNumber, this.nextIndex()];\n    if (this.buffer.size < this.maxElements) {\n      this.buffer = this.buffer.add(entry);\n    } else {\n      const highestValue = this.buffer.last()!;\n      if (bufferEntryComparator(entry, highestValue) < 0) {\n        this.buffer = this.buffer.delete(highestValue).add(entry);\n      }\n    }\n  }\n\n  get maxValue(): ListenSequenceNumber {\n    // Guaranteed to be non-empty. If we decide we are not collecting any\n    // sequence numbers, nthSequenceNumber below short-circuits. If we have\n    // decided that we are collecting n sequence numbers, it's because n is some\n    // percentage of the existing sequence numbers. That means we should never\n    // be in a situation where we are collecting sequence numbers but don't\n    // actually have any.\n    return this.buffer.last()![0];\n  }\n}\n\n/**\n * Describes the results of a garbage collection run. `didRun` will be set to\n * `false` if collection was skipped (either it is disabled or the cache size\n * has not hit the threshold). If collection ran, the other fields will be\n * filled in with the details of the results.\n */\nexport interface LruResults {\n  readonly didRun: boolean;\n  readonly sequenceNumbersCollected: number;\n  readonly targetsRemoved: number;\n  readonly documentsRemoved: number;\n}\n\nconst GC_DID_NOT_RUN: LruResults = {\n  didRun: false,\n  sequenceNumbersCollected: 0,\n  targetsRemoved: 0,\n  documentsRemoved: 0\n};\n\nexport class LruParams {\n  static readonly COLLECTION_DISABLED = -1;\n  static readonly MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;\n  static readonly DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;\n  private static readonly DEFAULT_COLLECTION_PERCENTILE = 10;\n  private static readonly DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1000;\n\n  static withCacheSize(cacheSize: number): LruParams {\n    return new LruParams(\n      cacheSize,\n      LruParams.DEFAULT_COLLECTION_PERCENTILE,\n      LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT\n    );\n  }\n\n  static readonly DEFAULT: LruParams = new LruParams(\n    LruParams.DEFAULT_CACHE_SIZE_BYTES,\n    LruParams.DEFAULT_COLLECTION_PERCENTILE,\n    LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT\n  );\n\n  static readonly DISABLED: LruParams = new LruParams(\n    LruParams.COLLECTION_DISABLED,\n    0,\n    0\n  );\n\n  constructor(\n    // When we attempt to collect, we will only do so if the cache size is greater than this\n    // threshold. Passing `COLLECTION_DISABLED` here will cause collection to always be skipped.\n    readonly cacheSizeCollectionThreshold: number,\n    // The percentage of sequence numbers that we will attempt to collect\n    readonly percentileToCollect: number,\n    // A cap on the total number of sequence numbers that will be collected. This prevents\n    // us from collecting a huge number of sequence numbers if the cache has grown very large.\n    readonly maximumSequenceNumbersToCollect: number\n  ) {}\n}\n\n/** How long we wait to try running LRU GC after SDK initialization. */\nconst INITIAL_GC_DELAY_MS = 1 * 60 * 1000;\n/** Minimum amount of time between GC checks, after the first one. */\nconst REGULAR_GC_DELAY_MS = 5 * 60 * 1000;\n\n/**\n * This class is responsible for the scheduling of LRU garbage collection. It handles checking\n * whether or not GC is enabled, as well as which delay to use before the next run.\n */\nexport class LruScheduler implements GarbageCollectionScheduler {\n  private hasRun: boolean = false;\n  private gcTask: DelayedOperation<void> | null;\n\n  constructor(\n    private readonly garbageCollector: LruGarbageCollector,\n    private readonly asyncQueue: AsyncQueue\n  ) {\n    this.gcTask = null;\n  }\n\n  start(localStore: LocalStore): void {\n    debugAssert(\n      this.gcTask === null,\n      'Cannot start an already started LruScheduler'\n    );\n    if (\n      this.garbageCollector.params.cacheSizeCollectionThreshold !==\n      LruParams.COLLECTION_DISABLED\n    ) {\n      this.scheduleGC(localStore);\n    }\n  }\n\n  stop(): void {\n    if (this.gcTask) {\n      this.gcTask.cancel();\n      this.gcTask = null;\n    }\n  }\n\n  get started(): boolean {\n    return this.gcTask !== null;\n  }\n\n  private scheduleGC(localStore: LocalStore): void {\n    debugAssert(\n      this.gcTask === null,\n      'Cannot schedule GC while a task is pending'\n    );\n    const delay = this.hasRun ? REGULAR_GC_DELAY_MS : INITIAL_GC_DELAY_MS;\n    logDebug(\n      'LruGarbageCollector',\n      `Garbage collection scheduled in ${delay}ms`\n    );\n    this.gcTask = this.asyncQueue.enqueueAfterDelay(\n      TimerId.LruGarbageCollection,\n      delay,\n      async () => {\n        this.gcTask = null;\n        this.hasRun = true;\n        try {\n          await localStore.collectGarbage(this.garbageCollector);\n        } catch (e) {\n          if (isIndexedDbTransactionError(e)) {\n            logDebug(\n              LOG_TAG,\n              'Ignoring IndexedDB error during garbage collection: ',\n              e\n            );\n          } else {\n            await ignoreIfPrimaryLeaseLoss(e);\n          }\n        }\n        await this.scheduleGC(localStore);\n      }\n    );\n  }\n}\n\n/** Implements the steps for LRU garbage collection. */\nexport class LruGarbageCollector {\n  constructor(\n    private readonly delegate: LruDelegate,\n    readonly params: LruParams\n  ) {}\n\n  /** Given a percentile of target to collect, returns the number of targets to collect. */\n  calculateTargetCount(\n    txn: PersistenceTransaction,\n    percentile: number\n  ): PersistencePromise<number> {\n    return this.delegate.getSequenceNumberCount(txn).next(targetCount => {\n      return Math.floor((percentile / 100.0) * targetCount);\n    });\n  }\n\n  /** Returns the nth sequence number, counting in order from the smallest. */\n  nthSequenceNumber(\n    txn: PersistenceTransaction,\n    n: number\n  ): PersistencePromise<ListenSequenceNumber> {\n    if (n === 0) {\n      return PersistencePromise.resolve(ListenSequence.INVALID);\n    }\n\n    const buffer = new RollingSequenceNumberBuffer(n);\n    return this.delegate\n      .forEachTarget(txn, target => buffer.addElement(target.sequenceNumber))\n      .next(() => {\n        return this.delegate.forEachOrphanedDocumentSequenceNumber(\n          txn,\n          sequenceNumber => buffer.addElement(sequenceNumber)\n        );\n      })\n      .next(() => buffer.maxValue);\n  }\n\n  /**\n   * Removes targets with a sequence number equal to or less than the given upper bound, and removes\n   * document associations with those targets.\n   */\n  removeTargets(\n    txn: PersistenceTransaction,\n    upperBound: ListenSequenceNumber,\n    activeTargetIds: ActiveTargets\n  ): PersistencePromise<number> {\n    return this.delegate.removeTargets(txn, upperBound, activeTargetIds);\n  }\n\n  /**\n   * Removes documents that have a sequence number equal to or less than the upper bound and are not\n   * otherwise pinned.\n   */\n  removeOrphanedDocuments(\n    txn: PersistenceTransaction,\n    upperBound: ListenSequenceNumber\n  ): PersistencePromise<number> {\n    return this.delegate.removeOrphanedDocuments(txn, upperBound);\n  }\n\n  collect(\n    txn: PersistenceTransaction,\n    activeTargetIds: ActiveTargets\n  ): PersistencePromise<LruResults> {\n    if (\n      this.params.cacheSizeCollectionThreshold === LruParams.COLLECTION_DISABLED\n    ) {\n      logDebug('LruGarbageCollector', 'Garbage collection skipped; disabled');\n      return PersistencePromise.resolve(GC_DID_NOT_RUN);\n    }\n\n    return this.getCacheSize(txn).next(cacheSize => {\n      if (cacheSize < this.params.cacheSizeCollectionThreshold) {\n        logDebug(\n          'LruGarbageCollector',\n          `Garbage collection skipped; Cache size ${cacheSize} ` +\n            `is lower than threshold ${this.params.cacheSizeCollectionThreshold}`\n        );\n        return GC_DID_NOT_RUN;\n      } else {\n        return this.runGarbageCollection(txn, activeTargetIds);\n      }\n    });\n  }\n\n  getCacheSize(txn: PersistenceTransaction): PersistencePromise<number> {\n    return this.delegate.getCacheSize(txn);\n  }\n\n  private runGarbageCollection(\n    txn: PersistenceTransaction,\n    activeTargetIds: ActiveTargets\n  ): PersistencePromise<LruResults> {\n    let upperBoundSequenceNumber: number;\n    let sequenceNumbersToCollect: number, targetsRemoved: number;\n    // Timestamps for various pieces of the process\n    let countedTargetsTs: number,\n      foundUpperBoundTs: number,\n      removedTargetsTs: number,\n      removedDocumentsTs: number;\n    const startTs = Date.now();\n    return this.calculateTargetCount(txn, this.params.percentileToCollect)\n      .next(sequenceNumbers => {\n        // Cap at the configured max\n        if (sequenceNumbers > this.params.maximumSequenceNumbersToCollect) {\n          logDebug(\n            'LruGarbageCollector',\n            'Capping sequence numbers to collect down ' +\n              `to the maximum of ${this.params.maximumSequenceNumbersToCollect} ` +\n              `from ${sequenceNumbers}`\n          );\n          sequenceNumbersToCollect = this.params\n            .maximumSequenceNumbersToCollect;\n        } else {\n          sequenceNumbersToCollect = sequenceNumbers;\n        }\n        countedTargetsTs = Date.now();\n\n        return this.nthSequenceNumber(txn, sequenceNumbersToCollect);\n      })\n      .next(upperBound => {\n        upperBoundSequenceNumber = upperBound;\n        foundUpperBoundTs = Date.now();\n\n        return this.removeTargets(\n          txn,\n          upperBoundSequenceNumber,\n          activeTargetIds\n        );\n      })\n      .next(numTargetsRemoved => {\n        targetsRemoved = numTargetsRemoved;\n        removedTargetsTs = Date.now();\n\n        return this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);\n      })\n      .next(documentsRemoved => {\n        removedDocumentsTs = Date.now();\n\n        if (getLogLevel() <= LogLevel.DEBUG) {\n          const desc =\n            'LRU Garbage Collection\\n' +\n            `\\tCounted targets in ${countedTargetsTs - startTs}ms\\n` +\n            `\\tDetermined least recently used ${sequenceNumbersToCollect} in ` +\n            `${foundUpperBoundTs - countedTargetsTs}ms\\n` +\n            `\\tRemoved ${targetsRemoved} targets in ` +\n            `${removedTargetsTs - foundUpperBoundTs}ms\\n` +\n            `\\tRemoved ${documentsRemoved} documents in ` +\n            `${removedDocumentsTs - removedTargetsTs}ms\\n` +\n            `Total Duration: ${removedDocumentsTs - startTs}ms`;\n          logDebug('LruGarbageCollector', desc);\n        }\n\n        return PersistencePromise.resolve<LruResults>({\n          didRun: true,\n          sequenceNumbersCollected: sequenceNumbersToCollect,\n          targetsRemoved,\n          documentsRemoved\n        });\n      });\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getUA } from '@firebase/util';\nimport { debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug, logError } from '../util/log';\nimport { Deferred } from '../util/promise';\nimport { SCHEMA_VERSION } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\n\n// References to `window` are guarded by SimpleDb.isAvailable()\n/* eslint-disable no-restricted-globals */\n\nconst LOG_TAG = 'SimpleDb';\n\n/**\n * The maximum number of retry attempts for an IndexedDb transaction that fails\n * with a DOMException.\n */\nconst TRANSACTION_RETRY_COUNT = 3;\n\n// The different modes supported by `SimpleDb.runTransaction()`\ntype SimpleDbTransactionMode = 'readonly' | 'readwrite';\n\nexport interface SimpleDbSchemaConverter {\n  createOrUpgrade(\n    db: IDBDatabase,\n    txn: IDBTransaction,\n    fromVersion: number,\n    toVersion: number\n  ): PersistencePromise<void>;\n}\n\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nexport class SimpleDb {\n  /**\n   * Opens the specified database, creating or upgrading it if necessary.\n   *\n   * Note that `version` must not be a downgrade. IndexedDB does not support downgrading the schema\n   * version. We currently do not support any way to do versioning outside of IndexedDB's versioning\n   * mechanism, as only version-upgrade transactions are allowed to do things like create\n   * objectstores.\n   */\n  static openOrCreate(\n    name: string,\n    version: number,\n    schemaConverter: SimpleDbSchemaConverter\n  ): Promise<SimpleDb> {\n    debugAssert(\n      SimpleDb.isAvailable(),\n      'IndexedDB not supported in current environment.'\n    );\n    logDebug(LOG_TAG, 'Opening database:', name);\n    return new PersistencePromise<SimpleDb>((resolve, reject) => {\n      // TODO(mikelehen): Investigate browser compatibility.\n      // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n      // suggests IE9 and older WebKit browsers handle upgrade\n      // differently. They expect setVersion, as described here:\n      // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n      const request = indexedDB.open(name, version);\n\n      request.onsuccess = (event: Event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        resolve(new SimpleDb(db));\n      };\n\n      request.onblocked = () => {\n        reject(\n          new FirestoreError(\n            Code.FAILED_PRECONDITION,\n            'Cannot upgrade IndexedDB schema while another tab is open. ' +\n              'Close all tabs that access Firestore and reload this page to proceed.'\n          )\n        );\n      };\n\n      request.onerror = (event: Event) => {\n        const error: DOMException = (event.target as IDBOpenDBRequest).error!;\n        if (error.name === 'VersionError') {\n          reject(\n            new FirestoreError(\n              Code.FAILED_PRECONDITION,\n              'A newer version of the Firestore SDK was previously used and so the persisted ' +\n                'data is not compatible with the version of the SDK you are now using. The SDK ' +\n                'will operate with persistence disabled. If you need persistence, please ' +\n                're-upgrade to a newer version of the SDK or else clear the persisted IndexedDB ' +\n                'data for your app to start fresh.'\n            )\n          );\n        } else {\n          reject(error);\n        }\n      };\n\n      request.onupgradeneeded = (event: IDBVersionChangeEvent) => {\n        logDebug(\n          LOG_TAG,\n          'Database \"' + name + '\" requires upgrade from version:',\n          event.oldVersion\n        );\n        const db = (event.target as IDBOpenDBRequest).result;\n        schemaConverter\n          .createOrUpgrade(\n            db,\n            request.transaction!,\n            event.oldVersion,\n            SCHEMA_VERSION\n          )\n          .next(() => {\n            logDebug(\n              LOG_TAG,\n              'Database upgrade to version ' + SCHEMA_VERSION + ' complete'\n            );\n          });\n      };\n    }).toPromise();\n  }\n\n  /** Deletes the specified database. */\n  static delete(name: string): Promise<void> {\n    logDebug(LOG_TAG, 'Removing database:', name);\n    return wrapRequest<void>(window.indexedDB.deleteDatabase(name)).toPromise();\n  }\n\n  /** Returns true if IndexedDB is available in the current environment. */\n  static isAvailable(): boolean {\n    if (typeof indexedDB === 'undefined') {\n      return false;\n    }\n\n    if (SimpleDb.isMockPersistence()) {\n      return true;\n    }\n\n    // We extensively use indexed array values and compound keys,\n    // which IE and Edge do not support. However, they still have indexedDB\n    // defined on the window, so we need to check for them here and make sure\n    // to return that persistence is not enabled for those browsers.\n    // For tracking support of this feature, see here:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n\n    // Check the UA string to find out the browser.\n    const ua = getUA();\n\n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n\n    // Edge\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n    // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n\n    // iOS Safari: Disable for users running iOS version < 10.\n    const iOSVersion = SimpleDb.getIOSVersion(ua);\n    const isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;\n\n    // Android browser: Disable for userse running version < 4.5.\n    const androidVersion = SimpleDb.getAndroidVersion(ua);\n    const isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;\n\n    if (\n      ua.indexOf('MSIE ') > 0 ||\n      ua.indexOf('Trident/') > 0 ||\n      ua.indexOf('Edge/') > 0 ||\n      isUnsupportedIOS ||\n      isUnsupportedAndroid\n    ) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Returns true if the backing IndexedDB store is the Node IndexedDBShim\n   * (see https://github.com/axemclion/IndexedDBShim).\n   */\n  static isMockPersistence(): boolean {\n    return (\n      typeof process !== 'undefined' &&\n      process.env?.USE_MOCK_PERSISTENCE === 'YES'\n    );\n  }\n\n  /** Helper to get a typed SimpleDbStore from a transaction. */\n  static getStore<KeyType extends IDBValidKey, ValueType extends unknown>(\n    txn: SimpleDbTransaction,\n    store: string\n  ): SimpleDbStore<KeyType, ValueType> {\n    return txn.store<KeyType, ValueType>(store);\n  }\n\n  // visible for testing\n  /** Parse User Agent to determine iOS version. Returns -1 if not found. */\n  static getIOSVersion(ua: string): number {\n    const iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\\d_]+)/i);\n    const version = iOSVersionRegex\n      ? iOSVersionRegex[1]\n          .split('_')\n          .slice(0, 2)\n          .join('.')\n      : '-1';\n    return Number(version);\n  }\n\n  // visible for testing\n  /** Parse User Agent to determine Android version. Returns -1 if not found. */\n  static getAndroidVersion(ua: string): number {\n    const androidVersionRegex = ua.match(/Android ([\\d.]+)/i);\n    const version = androidVersionRegex\n      ? androidVersionRegex[1]\n          .split('.')\n          .slice(0, 2)\n          .join('.')\n      : '-1';\n    return Number(version);\n  }\n\n  constructor(private db: IDBDatabase) {\n    const iOSVersion = SimpleDb.getIOSVersion(getUA());\n    // NOTE: According to https://bugs.webkit.org/show_bug.cgi?id=197050, the\n    // bug we're checking for should exist in iOS >= 12.2 and < 13, but for\n    // whatever reason it's much harder to hit after 12.2 so we only proactively\n    // log on 12.2.\n    if (iOSVersion === 12.2) {\n      logError(\n        'Firestore persistence suffers from a bug in iOS 12.2 ' +\n          'Safari that may cause your app to stop working. See ' +\n          'https://stackoverflow.com/q/56496296/110915 for details ' +\n          'and a potential workaround.'\n      );\n    }\n  }\n\n  setVersionChangeListener(\n    versionChangeListener: (event: IDBVersionChangeEvent) => void\n  ): void {\n    this.db.onversionchange = (event: IDBVersionChangeEvent) => {\n      return versionChangeListener(event);\n    };\n  }\n\n  async runTransaction<T>(\n    mode: SimpleDbTransactionMode,\n    objectStores: string[],\n    transactionFn: (transaction: SimpleDbTransaction) => PersistencePromise<T>\n  ): Promise<T> {\n    const readonly = mode === 'readonly';\n    let attemptNumber = 0;\n\n    while (true) {\n      ++attemptNumber;\n\n      const transaction = SimpleDbTransaction.open(\n        this.db,\n        readonly ? 'readonly' : 'readwrite',\n        objectStores\n      );\n      try {\n        const transactionFnResult = transactionFn(transaction)\n          .catch(error => {\n            // Abort the transaction if there was an error.\n            transaction.abort(error);\n            // We cannot actually recover, and calling `abort()` will cause the transaction's\n            // completion promise to be rejected. This in turn means that we won't use\n            // `transactionFnResult` below. We return a rejection here so that we don't add the\n            // possibility of returning `void` to the type of `transactionFnResult`.\n            return PersistencePromise.reject<T>(error);\n          })\n          .toPromise();\n\n        // As noted above, errors are propagated by aborting the transaction. So\n        // we swallow any error here to avoid the browser logging it as unhandled.\n        transactionFnResult.catch(() => {});\n\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        await transaction.completionPromise;\n        return transactionFnResult;\n      } catch (error) {\n        // TODO(schmidt-sebastian): We could probably be smarter about this and\n        // not retry exceptions that are likely unrecoverable (such as quota\n        // exceeded errors).\n\n        // Note: We cannot use an instanceof check for FirestoreException, since the\n        // exception is wrapped in a generic error by our async/await handling.\n        const retryable =\n          error.name !== 'FirebaseError' &&\n          attemptNumber < TRANSACTION_RETRY_COUNT;\n        logDebug(\n          LOG_TAG,\n          'Transaction failed with error: %s. Retrying: %s.',\n          error.message,\n          retryable\n        );\n\n        if (!retryable) {\n          return Promise.reject(error);\n        }\n      }\n    }\n  }\n\n  close(): void {\n    this.db.close();\n  }\n}\n\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nexport class IterationController {\n  private shouldStop = false;\n  private nextKey: IDBValidKey | null = null;\n\n  constructor(private dbCursor: IDBCursorWithValue) {}\n\n  get isDone(): boolean {\n    return this.shouldStop;\n  }\n\n  get skipToKey(): IDBValidKey | null {\n    return this.nextKey;\n  }\n\n  set cursor(value: IDBCursorWithValue) {\n    this.dbCursor = value;\n  }\n\n  /**\n   * This function can be called to stop iteration at any point.\n   */\n  done(): void {\n    this.shouldStop = true;\n  }\n\n  /**\n   * This function can be called to skip to that next key, which could be\n   * an index or a primary key.\n   */\n  skip(key: IDBValidKey): void {\n    this.nextKey = key;\n  }\n\n  /**\n   * Delete the current cursor value from the object store.\n   *\n   * NOTE: You CANNOT do this with a keysOnly query.\n   */\n  delete(): PersistencePromise<void> {\n    return wrapRequest<void>(this.dbCursor.delete());\n  }\n}\n\n/**\n * Callback used with iterate() method.\n */\nexport type IterateCallback<KeyType, ValueType> = (\n  key: KeyType,\n  value: ValueType,\n  control: IterationController\n) => void | PersistencePromise<void>;\n\n/** Options available to the iterate() method. */\nexport interface IterateOptions {\n  /** Index to iterate over (else primary keys will be iterated) */\n  index?: string;\n\n  /** IndxedDB Range to iterate over (else entire store will be iterated) */\n  range?: IDBKeyRange;\n\n  /** If true, values aren't read while iterating. */\n  keysOnly?: boolean;\n\n  /** If true, iterate over the store in reverse. */\n  reverse?: boolean;\n}\n\n/** An error that wraps exceptions that thrown during IndexedDB execution. */\nexport class IndexedDbTransactionError extends FirestoreError {\n  name = 'IndexedDbTransactionError';\n\n  constructor(cause: Error) {\n    super(Code.UNAVAILABLE, 'IndexedDB transaction failed: ' + cause);\n  }\n}\n\n/** Verifies whether `e` is an IndexedDbTransactionError. */\nexport function isIndexedDbTransactionError(e: Error): boolean {\n  // Use name equality, as instanceof checks on errors don't work with errors\n  // that wrap other errors.\n  return e.name === 'IndexedDbTransactionError';\n}\n\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nexport class SimpleDbTransaction {\n  private aborted = false;\n\n  /**\n   * A promise that resolves with the result of the IndexedDb transaction.\n   */\n  private readonly completionDeferred = new Deferred<void>();\n\n  static open(\n    db: IDBDatabase,\n    mode: IDBTransactionMode,\n    objectStoreNames: string[]\n  ): SimpleDbTransaction {\n    return new SimpleDbTransaction(db.transaction(objectStoreNames, mode));\n  }\n\n  constructor(private readonly transaction: IDBTransaction) {\n    this.transaction.oncomplete = () => {\n      this.completionDeferred.resolve();\n    };\n    this.transaction.onabort = () => {\n      if (transaction.error) {\n        this.completionDeferred.reject(\n          new IndexedDbTransactionError(transaction.error)\n        );\n      } else {\n        this.completionDeferred.resolve();\n      }\n    };\n    this.transaction.onerror = (event: Event) => {\n      const error = checkForAndReportiOSError(\n        (event.target as IDBRequest).error!\n      );\n      this.completionDeferred.reject(new IndexedDbTransactionError(error));\n    };\n  }\n\n  get completionPromise(): Promise<void> {\n    return this.completionDeferred.promise;\n  }\n\n  abort(error?: Error): void {\n    if (error) {\n      this.completionDeferred.reject(error);\n    }\n\n    if (!this.aborted) {\n      logDebug(\n        LOG_TAG,\n        'Aborting transaction:',\n        error ? error.message : 'Client-initiated abort'\n      );\n      this.aborted = true;\n      this.transaction.abort();\n    }\n  }\n\n  /**\n   * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n   * operations performed on the SimpleDbStore happen within the context of this\n   * transaction and it cannot be used anymore once the transaction is\n   * completed.\n   *\n   * Note that we can't actually enforce that the KeyType and ValueType are\n   * correct, but they allow type safety through the rest of the consuming code.\n   */\n  store<KeyType extends IDBValidKey, ValueType extends unknown>(\n    storeName: string\n  ): SimpleDbStore<KeyType, ValueType> {\n    const store = this.transaction.objectStore(storeName);\n    debugAssert(!!store, 'Object store not part of transaction: ' + storeName);\n    return new SimpleDbStore<KeyType, ValueType>(store);\n  }\n}\n\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nexport class SimpleDbStore<\n  KeyType extends IDBValidKey,\n  ValueType extends unknown\n> {\n  constructor(private store: IDBObjectStore) {}\n\n  /**\n   * Writes a value into the Object Store.\n   *\n   * @param key Optional explicit key to use when writing the object, else the\n   * key will be auto-assigned (e.g. via the defined keyPath for the store).\n   * @param value The object to write.\n   */\n  put(value: ValueType): PersistencePromise<void>;\n  put(key: KeyType, value: ValueType): PersistencePromise<void>;\n  put(\n    keyOrValue: KeyType | ValueType,\n    value?: ValueType\n  ): PersistencePromise<void> {\n    let request;\n    if (value !== undefined) {\n      logDebug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n      request = this.store.put(value, keyOrValue as KeyType);\n    } else {\n      logDebug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n      request = this.store.put(keyOrValue as ValueType);\n    }\n    return wrapRequest<void>(request);\n  }\n\n  /**\n   * Adds a new value into an Object Store and returns the new key. Similar to\n   * IndexedDb's `add()`, this method will fail on primary key collisions.\n   *\n   * @param value The object to write.\n   * @return The key of the value to add.\n   */\n  add(value: ValueType): PersistencePromise<KeyType> {\n    logDebug(LOG_TAG, 'ADD', this.store.name, value, value);\n    const request = this.store.add(value as ValueType);\n    return wrapRequest<KeyType>(request);\n  }\n\n  /**\n   * Gets the object with the specified key from the specified store, or null\n   * if no object exists with the specified key.\n   *\n   * @key The key of the object to get.\n   * @return The object with the specified key or null if no object exists.\n   */\n  get(key: KeyType): PersistencePromise<ValueType | null> {\n    const request = this.store.get(key);\n    // We're doing an unsafe cast to ValueType.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return wrapRequest<any>(request).next(result => {\n      // Normalize nonexistence to null.\n      if (result === undefined) {\n        result = null;\n      }\n      logDebug(LOG_TAG, 'GET', this.store.name, key, result);\n      return result;\n    });\n  }\n\n  delete(key: KeyType | IDBKeyRange): PersistencePromise<void> {\n    logDebug(LOG_TAG, 'DELETE', this.store.name, key);\n    const request = this.store.delete(key);\n    return wrapRequest<void>(request);\n  }\n\n  /**\n   * If we ever need more of the count variants, we can add overloads. For now,\n   * all we need is to count everything in a store.\n   *\n   * Returns the number of rows in the store.\n   */\n  count(): PersistencePromise<number> {\n    logDebug(LOG_TAG, 'COUNT', this.store.name);\n    const request = this.store.count();\n    return wrapRequest<number>(request);\n  }\n\n  loadAll(): PersistencePromise<ValueType[]>;\n  loadAll(range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(index: string, range: IDBKeyRange): PersistencePromise<ValueType[]>;\n  loadAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<ValueType[]> {\n    const cursor = this.cursor(this.options(indexOrRange, range));\n    const results: ValueType[] = [];\n    return this.iterateCursor(cursor, (key, value) => {\n      results.push(value);\n    }).next(() => {\n      return results;\n    });\n  }\n\n  deleteAll(): PersistencePromise<void>;\n  deleteAll(range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(index: string, range: IDBKeyRange): PersistencePromise<void>;\n  deleteAll(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): PersistencePromise<void> {\n    logDebug(LOG_TAG, 'DELETE ALL', this.store.name);\n    const options = this.options(indexOrRange, range);\n    options.keysOnly = false;\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, (key, value, control) => {\n      // NOTE: Calling delete() on a cursor is documented as more efficient than\n      // calling delete() on an object store with a single key\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n      // however, this requires us *not* to use a keysOnly cursor\n      // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n      // may want to compare the performance of each method.\n      return control.delete();\n    });\n  }\n\n  /**\n   * Iterates over keys and values in an object store.\n   *\n   * @param options Options specifying how to iterate the objects in the store.\n   * @param callback will be called for each iterated object. Iteration can be\n   * canceled at any point by calling the doneFn passed to the callback.\n   * The callback can return a PersistencePromise if it performs async\n   * operations but note that iteration will continue without waiting for them\n   * to complete.\n   * @returns A PersistencePromise that resolves once all PersistencePromises\n   * returned by callbacks resolve.\n   */\n  iterate(\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    options: IterateOptions,\n    callback: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void>;\n  iterate(\n    optionsOrCallback: IterateOptions | IterateCallback<KeyType, ValueType>,\n    callback?: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    let options;\n    if (!callback) {\n      options = {};\n      callback = optionsOrCallback as IterateCallback<KeyType, ValueType>;\n    } else {\n      options = optionsOrCallback as IterateOptions;\n    }\n    const cursor = this.cursor(options);\n    return this.iterateCursor(cursor, callback);\n  }\n\n  /**\n   * Iterates over a store, but waits for the given callback to complete for\n   * each entry before iterating the next entry. This allows the callback to do\n   * asynchronous work to determine if this iteration should continue.\n   *\n   * The provided callback should return `true` to continue iteration, and\n   * `false` otherwise.\n   */\n  iterateSerial(\n    callback: (k: KeyType, v: ValueType) => PersistencePromise<boolean>\n  ): PersistencePromise<void> {\n    const cursorRequest = this.cursor({});\n    return new PersistencePromise((resolve, reject) => {\n      cursorRequest.onerror = (event: Event) => {\n        const error = checkForAndReportiOSError(\n          (event.target as IDBRequest).error!\n        );\n        reject(error);\n      };\n      cursorRequest.onsuccess = (event: Event) => {\n        const cursor: IDBCursorWithValue = (event.target as IDBRequest).result;\n        if (!cursor) {\n          resolve();\n          return;\n        }\n\n        callback(cursor.primaryKey as KeyType, cursor.value).next(\n          shouldContinue => {\n            if (shouldContinue) {\n              cursor.continue();\n            } else {\n              resolve();\n            }\n          }\n        );\n      };\n    });\n  }\n\n  private iterateCursor(\n    cursorRequest: IDBRequest,\n    fn: IterateCallback<KeyType, ValueType>\n  ): PersistencePromise<void> {\n    const results: Array<PersistencePromise<void>> = [];\n    return new PersistencePromise((resolve, reject) => {\n      cursorRequest.onerror = (event: Event) => {\n        reject((event.target as IDBRequest).error!);\n      };\n      cursorRequest.onsuccess = (event: Event) => {\n        const cursor: IDBCursorWithValue = (event.target as IDBRequest).result;\n        if (!cursor) {\n          resolve();\n          return;\n        }\n        const controller = new IterationController(cursor);\n        const userResult = fn(\n          cursor.primaryKey as KeyType,\n          cursor.value,\n          controller\n        );\n        if (userResult instanceof PersistencePromise) {\n          const userPromise: PersistencePromise<void> = userResult.catch(\n            err => {\n              controller.done();\n              return PersistencePromise.reject(err);\n            }\n          );\n          results.push(userPromise);\n        }\n        if (controller.isDone) {\n          resolve();\n        } else if (controller.skipToKey === null) {\n          cursor.continue();\n        } else {\n          cursor.continue(controller.skipToKey);\n        }\n      };\n    }).next(() => {\n      return PersistencePromise.waitFor(results);\n    });\n  }\n\n  private options(\n    indexOrRange?: string | IDBKeyRange,\n    range?: IDBKeyRange\n  ): IterateOptions {\n    let indexName: string | undefined = undefined;\n    if (indexOrRange !== undefined) {\n      if (typeof indexOrRange === 'string') {\n        indexName = indexOrRange;\n      } else {\n        debugAssert(\n          range === undefined,\n          '3rd argument must not be defined if 2nd is a range.'\n        );\n        range = indexOrRange;\n      }\n    }\n    return { index: indexName, range };\n  }\n\n  private cursor(options: IterateOptions): IDBRequest {\n    let direction: IDBCursorDirection = 'next';\n    if (options.reverse) {\n      direction = 'prev';\n    }\n    if (options.index) {\n      const index = this.store.index(options.index);\n      if (options.keysOnly) {\n        return index.openKeyCursor(options.range, direction);\n      } else {\n        return index.openCursor(options.range, direction);\n      }\n    } else {\n      return this.store.openCursor(options.range, direction);\n    }\n  }\n}\n\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest<R>(request: IDBRequest): PersistencePromise<R> {\n  return new PersistencePromise<R>((resolve, reject) => {\n    request.onsuccess = (event: Event) => {\n      const result = (event.target as IDBRequest).result;\n      resolve(result);\n    };\n\n    request.onerror = (event: Event) => {\n      const error = checkForAndReportiOSError(\n        (event.target as IDBRequest).error!\n      );\n      reject(error);\n    };\n  });\n}\n\n// Guard so we only report the error once.\nlet reportedIOSError = false;\nfunction checkForAndReportiOSError(error: DOMException): Error {\n  const iOSVersion = SimpleDb.getIOSVersion(getUA());\n  if (iOSVersion >= 12.2 && iOSVersion < 13) {\n    const IOS_ERROR =\n      'An internal error was encountered in the Indexed Database server';\n    if (error.message.indexOf(IOS_ERROR) >= 0) {\n      // Wrap error in a more descriptive one.\n      const newError = new FirestoreError(\n        'internal',\n        `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${IOS_ERROR}'. This is likely ` +\n          `due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 ` +\n          `for details and a potential workaround.`\n      );\n      if (!reportedIOSError) {\n        reportedIOSError = true;\n        // Throw a global exception outside of this promise chain, for the user to\n        // potentially catch.\n        setTimeout(() => {\n          throw newError;\n        }, 0);\n      }\n      return newError;\n    }\n  }\n  return error;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../api/timestamp';\nimport { User } from '../auth/user';\nimport { Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Target } from '../core/target';\nimport { BatchId, TargetId } from '../core/types';\nimport {\n  DocumentKeySet,\n  documentKeySet,\n  DocumentMap,\n  maybeDocumentMap,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation, PatchMutation, Precondition } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport { RemoteEvent, TargetChange } from '../remote/remote_event';\nimport { hardAssert, debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport { ObjectMap } from '../util/obj_map';\nimport { SortedMap } from '../util/sorted_map';\n\nimport { LocalDocumentsView } from './local_documents_view';\nimport { LocalViewChanges } from './local_view_changes';\nimport { LruGarbageCollector, LruResults } from './lru_garbage_collector';\nimport { MutationQueue } from './mutation_queue';\nimport {\n  Persistence,\n  PersistenceTransaction,\n  PRIMARY_LEASE_LOST_ERROR_MSG\n} from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { TargetCache } from './target_cache';\nimport { QueryEngine } from './query_engine';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\nimport { ClientId } from './shared_client_state';\nimport { TargetData, TargetPurpose } from './target_data';\nimport { IndexedDbPersistence } from './indexeddb_persistence';\nimport { IndexedDbMutationQueue } from './indexeddb_mutation_queue';\nimport { IndexedDbRemoteDocumentCache } from './indexeddb_remote_document_cache';\nimport { IndexedDbTargetCache } from './indexeddb_target_cache';\nimport { extractFieldMask } from '../model/object_value';\nimport { isIndexedDbTransactionError } from './simple_db';\n\nconst LOG_TAG = 'LocalStore';\n\n/** The result of a write to the local store. */\nexport interface LocalWriteResult {\n  batchId: BatchId;\n  changes: MaybeDocumentMap;\n}\n\n/** The result of a user-change operation in the local store. */\nexport interface UserChangeResult {\n  readonly affectedDocuments: MaybeDocumentMap;\n  readonly removedBatchIds: BatchId[];\n  readonly addedBatchIds: BatchId[];\n}\n\n/** The result of executing a query against the local store. */\nexport interface QueryResult {\n  readonly documents: DocumentMap;\n  readonly remoteKeys: DocumentKeySet;\n}\n\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nexport class LocalStore {\n  /**\n   * The maximum time to leave a resume token buffered without writing it out.\n   * This value is arbitrary: it's long enough to avoid several writes\n   * (possibly indefinitely if updates come more frequently than this) but\n   * short enough that restarting after crashing will still have a pretty\n   * recent resume token.\n   */\n  private static readonly RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;\n\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  protected mutationQueue: MutationQueue;\n\n  /** The set of all cached remote documents. */\n  protected remoteDocuments: RemoteDocumentCache;\n\n  /**\n   * The \"local\" view of all documents (layering mutationQueue on top of\n   * remoteDocumentCache).\n   */\n  protected localDocuments: LocalDocumentsView;\n\n  /** Maps a target to its `TargetData`. */\n  protected targetCache: TargetCache;\n\n  /**\n   * Maps a targetID to data about its target.\n   *\n   * PORTING NOTE: We are using an immutable data structure on Web to make re-runs\n   * of `applyRemoteEvent()` idempotent.\n   */\n  protected targetDataByTarget = new SortedMap<TargetId, TargetData>(\n    primitiveComparator\n  );\n\n  /** Maps a target to its targetID. */\n  // TODO(wuandy): Evaluate if TargetId can be part of Target.\n  private targetIdByTarget = new ObjectMap<Target, TargetId>(t =>\n    t.canonicalId()\n  );\n\n  /**\n   * The read time of the last entry processed by `getNewDocumentChanges()`.\n   *\n   * PORTING NOTE: This is only used for multi-tab synchronization.\n   */\n  protected lastDocumentChangeReadTime = SnapshotVersion.min();\n\n  constructor(\n    /** Manages our in-memory or durable persistence. */\n    protected persistence: Persistence,\n    private queryEngine: QueryEngine,\n    initialUser: User\n  ) {\n    debugAssert(\n      persistence.started,\n      'LocalStore was passed an unstarted persistence implementation'\n    );\n    this.mutationQueue = persistence.getMutationQueue(initialUser);\n    this.remoteDocuments = persistence.getRemoteDocumentCache();\n    this.targetCache = persistence.getTargetCache();\n    this.localDocuments = new LocalDocumentsView(\n      this.remoteDocuments,\n      this.mutationQueue,\n      this.persistence.getIndexManager()\n    );\n    this.queryEngine.setLocalDocumentsView(this.localDocuments);\n  }\n\n  /** Starts the LocalStore. */\n  start(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  /**\n   * Tells the LocalStore that the currently authenticated user has changed.\n   *\n   * In response the local store switches the mutation queue to the new user and\n   * returns any resulting document changes.\n   */\n  // PORTING NOTE: Android and iOS only return the documents affected by the\n  // change.\n  async handleUserChange(user: User): Promise<UserChangeResult> {\n    let newMutationQueue = this.mutationQueue;\n    let newLocalDocuments = this.localDocuments;\n\n    const result = await this.persistence.runTransaction(\n      'Handle user change',\n      'readonly',\n      txn => {\n        // Swap out the mutation queue, grabbing the pending mutation batches\n        // before and after.\n        let oldBatches: MutationBatch[];\n        return this.mutationQueue\n          .getAllMutationBatches(txn)\n          .next(promisedOldBatches => {\n            oldBatches = promisedOldBatches;\n\n            newMutationQueue = this.persistence.getMutationQueue(user);\n\n            // Recreate our LocalDocumentsView using the new\n            // MutationQueue.\n            newLocalDocuments = new LocalDocumentsView(\n              this.remoteDocuments,\n              newMutationQueue,\n              this.persistence.getIndexManager()\n            );\n            return newMutationQueue.getAllMutationBatches(txn);\n          })\n          .next(newBatches => {\n            const removedBatchIds: BatchId[] = [];\n            const addedBatchIds: BatchId[] = [];\n\n            // Union the old/new changed keys.\n            let changedKeys = documentKeySet();\n\n            for (const batch of oldBatches) {\n              removedBatchIds.push(batch.batchId);\n              for (const mutation of batch.mutations) {\n                changedKeys = changedKeys.add(mutation.key);\n              }\n            }\n\n            for (const batch of newBatches) {\n              addedBatchIds.push(batch.batchId);\n              for (const mutation of batch.mutations) {\n                changedKeys = changedKeys.add(mutation.key);\n              }\n            }\n\n            // Return the set of all (potentially) changed documents and the list\n            // of mutation batch IDs that were affected by change.\n            return newLocalDocuments\n              .getDocuments(txn, changedKeys)\n              .next(affectedDocuments => {\n                return {\n                  affectedDocuments,\n                  removedBatchIds,\n                  addedBatchIds\n                };\n              });\n          });\n      }\n    );\n\n    this.mutationQueue = newMutationQueue;\n    this.localDocuments = newLocalDocuments;\n    this.queryEngine.setLocalDocumentsView(this.localDocuments);\n\n    return result;\n  }\n\n  /* Accept locally generated Mutations and commit them to storage. */\n  localWrite(mutations: Mutation[]): Promise<LocalWriteResult> {\n    const localWriteTime = Timestamp.now();\n    const keys = mutations.reduce(\n      (keys, m) => keys.add(m.key),\n      documentKeySet()\n    );\n\n    let existingDocs: MaybeDocumentMap;\n\n    return this.persistence\n      .runTransaction('Locally write mutations', 'readwrite', txn => {\n        // Load and apply all existing mutations. This lets us compute the\n        // current base state for all non-idempotent transforms before applying\n        // any additional user-provided writes.\n        return this.localDocuments.getDocuments(txn, keys).next(docs => {\n          existingDocs = docs;\n\n          // For non-idempotent mutations (such as `FieldValue.increment()`),\n          // we record the base state in a separate patch mutation. This is\n          // later used to guarantee consistent values and prevents flicker\n          // even if the backend sends us an update that already includes our\n          // transform.\n          const baseMutations: Mutation[] = [];\n\n          for (const mutation of mutations) {\n            const baseValue = mutation.extractBaseValue(\n              existingDocs.get(mutation.key)\n            );\n            if (baseValue != null) {\n              // NOTE: The base state should only be applied if there's some\n              // existing document to override, so use a Precondition of\n              // exists=true\n              baseMutations.push(\n                new PatchMutation(\n                  mutation.key,\n                  baseValue,\n                  extractFieldMask(baseValue.proto.mapValue!),\n                  Precondition.exists(true)\n                )\n              );\n            }\n          }\n\n          return this.mutationQueue.addMutationBatch(\n            txn,\n            localWriteTime,\n            baseMutations,\n            mutations\n          );\n        });\n      })\n      .then(batch => {\n        const changes = batch.applyToLocalDocumentSet(existingDocs);\n        return { batchId: batch.batchId, changes };\n      });\n  }\n\n  /**\n   * Acknowledge the given batch.\n   *\n   * On the happy path when a batch is acknowledged, the local store will\n   *\n   *  + remove the batch from the mutation queue;\n   *  + apply the changes to the remote document cache;\n   *  + recalculate the latency compensated view implied by those changes (there\n   *    may be mutations in the queue that affect the documents but haven't been\n   *    acknowledged yet); and\n   *  + give the changed documents back the sync engine\n   *\n   * @returns The resulting (modified) documents.\n   */\n  acknowledgeBatch(\n    batchResult: MutationBatchResult\n  ): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction(\n      'Acknowledge batch',\n      'readwrite-primary',\n      txn => {\n        const affected = batchResult.batch.keys();\n        const documentBuffer = this.remoteDocuments.newChangeBuffer({\n          trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n        return this.applyWriteToRemoteDocuments(\n          txn,\n          batchResult,\n          documentBuffer\n        )\n          .next(() => documentBuffer.apply(txn))\n          .next(() => this.mutationQueue.performConsistencyCheck(txn))\n          .next(() => this.localDocuments.getDocuments(txn, affected));\n      }\n    );\n  }\n\n  /**\n   * Remove mutations from the MutationQueue for the specified batch;\n   * LocalDocuments will be recalculated.\n   *\n   * @returns The resulting modified documents.\n   */\n  rejectBatch(batchId: BatchId): Promise<MaybeDocumentMap> {\n    return this.persistence.runTransaction(\n      'Reject batch',\n      'readwrite-primary',\n      txn => {\n        let affectedKeys: DocumentKeySet;\n        return this.mutationQueue\n          .lookupMutationBatch(txn, batchId)\n          .next((batch: MutationBatch | null) => {\n            hardAssert(batch !== null, 'Attempt to reject nonexistent batch!');\n            affectedKeys = batch.keys();\n            return this.mutationQueue.removeMutationBatch(txn, batch);\n          })\n          .next(() => {\n            return this.mutationQueue.performConsistencyCheck(txn);\n          })\n          .next(() => {\n            return this.localDocuments.getDocuments(txn, affectedKeys);\n          });\n      }\n    );\n  }\n\n  /**\n   * Returns the largest (latest) batch id in mutation queue that is pending server response.\n   * Returns `BATCHID_UNKNOWN` if the queue is empty.\n   */\n  getHighestUnacknowledgedBatchId(): Promise<BatchId> {\n    return this.persistence.runTransaction(\n      'Get highest unacknowledged batch id',\n      'readonly',\n      txn => {\n        return this.mutationQueue.getHighestUnacknowledgedBatchId(txn);\n      }\n    );\n  }\n\n  /**\n   * Returns the last consistent snapshot processed (used by the RemoteStore to\n   * determine whether to buffer incoming snapshots from the backend).\n   */\n  getLastRemoteSnapshotVersion(): Promise<SnapshotVersion> {\n    return this.persistence.runTransaction(\n      'Get last remote snapshot version',\n      'readonly',\n      txn => this.targetCache.getLastRemoteSnapshotVersion(txn)\n    );\n  }\n\n  /**\n   * Update the \"ground-state\" (remote) documents. We assume that the remote\n   * event reflects any write batches that have been acknowledged or rejected\n   * (i.e. we do not re-apply local mutations to updates from this event).\n   *\n   * LocalDocuments are re-calculated if there are remaining mutations in the\n   * queue.\n   */\n  applyRemoteEvent(remoteEvent: RemoteEvent): Promise<MaybeDocumentMap> {\n    const remoteVersion = remoteEvent.snapshotVersion;\n    let newTargetDataByTargetMap = this.targetDataByTarget;\n\n    return this.persistence\n      .runTransaction('Apply remote event', 'readwrite-primary', txn => {\n        const documentBuffer = this.remoteDocuments.newChangeBuffer({\n          trackRemovals: true // Make sure document removals show up in `getNewDocumentChanges()`\n        });\n\n        // Reset newTargetDataByTargetMap in case this transaction gets re-run.\n        newTargetDataByTargetMap = this.targetDataByTarget;\n\n        const promises = [] as Array<PersistencePromise<void>>;\n        remoteEvent.targetChanges.forEach((change, targetId) => {\n          const oldTargetData = newTargetDataByTargetMap.get(targetId);\n          if (!oldTargetData) {\n            return;\n          }\n\n          // Only update the remote keys if the target is still active. This\n          // ensures that we can persist the updated target data along with\n          // the updated assignment.\n          promises.push(\n            this.targetCache\n              .removeMatchingKeys(txn, change.removedDocuments, targetId)\n              .next(() => {\n                return this.targetCache.addMatchingKeys(\n                  txn,\n                  change.addedDocuments,\n                  targetId\n                );\n              })\n          );\n\n          const resumeToken = change.resumeToken;\n          // Update the resume token if the change includes one.\n          if (resumeToken.approximateByteSize() > 0) {\n            const newTargetData = oldTargetData\n              .withResumeToken(resumeToken, remoteVersion)\n              .withSequenceNumber(txn.currentSequenceNumber);\n            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(\n              targetId,\n              newTargetData\n            );\n\n            // Update the target data if there are target changes (or if\n            // sufficient time has passed since the last update).\n            if (\n              LocalStore.shouldPersistTargetData(\n                oldTargetData,\n                newTargetData,\n                change\n              )\n            ) {\n              promises.push(\n                this.targetCache.updateTargetData(txn, newTargetData)\n              );\n            }\n          }\n        });\n\n        let changedDocs = maybeDocumentMap();\n        let updatedKeys = documentKeySet();\n        remoteEvent.documentUpdates.forEach((key, doc) => {\n          updatedKeys = updatedKeys.add(key);\n        });\n\n        // Each loop iteration only affects its \"own\" doc, so it's safe to get all the remote\n        // documents in advance in a single call.\n        promises.push(\n          documentBuffer.getEntries(txn, updatedKeys).next(existingDocs => {\n            remoteEvent.documentUpdates.forEach((key, doc) => {\n              const existingDoc = existingDocs.get(key);\n\n              // Note: The order of the steps below is important, since we want\n              // to ensure that rejected limbo resolutions (which fabricate\n              // NoDocuments with SnapshotVersion.min()) never add documents to\n              // cache.\n              if (\n                doc instanceof NoDocument &&\n                doc.version.isEqual(SnapshotVersion.min())\n              ) {\n                // NoDocuments with SnapshotVersion.min() are used in manufactured\n                // events. We remove these documents from cache since we lost\n                // access.\n                documentBuffer.removeEntry(key, remoteVersion);\n                changedDocs = changedDocs.insert(key, doc);\n              } else if (\n                existingDoc == null ||\n                doc.version.compareTo(existingDoc.version) > 0 ||\n                (doc.version.compareTo(existingDoc.version) === 0 &&\n                  existingDoc.hasPendingWrites)\n              ) {\n                debugAssert(\n                  !SnapshotVersion.min().isEqual(remoteVersion),\n                  'Cannot add a document when the remote version is zero'\n                );\n                documentBuffer.addEntry(doc, remoteVersion);\n                changedDocs = changedDocs.insert(key, doc);\n              } else {\n                logDebug(\n                  LOG_TAG,\n                  'Ignoring outdated watch update for ',\n                  key,\n                  '. Current version:',\n                  existingDoc.version,\n                  ' Watch version:',\n                  doc.version\n                );\n              }\n\n              if (remoteEvent.resolvedLimboDocuments.has(key)) {\n                promises.push(\n                  this.persistence.referenceDelegate.updateLimboDocument(\n                    txn,\n                    key\n                  )\n                );\n              }\n            });\n          })\n        );\n\n        // HACK: The only reason we allow a null snapshot version is so that we\n        // can synthesize remote events when we get permission denied errors while\n        // trying to resolve the state of a locally cached document that is in\n        // limbo.\n        if (!remoteVersion.isEqual(SnapshotVersion.min())) {\n          const updateRemoteVersion = this.targetCache\n            .getLastRemoteSnapshotVersion(txn)\n            .next(lastRemoteSnapshotVersion => {\n              debugAssert(\n                remoteVersion.compareTo(lastRemoteSnapshotVersion) >= 0,\n                'Watch stream reverted to previous snapshot?? ' +\n                  remoteVersion +\n                  ' < ' +\n                  lastRemoteSnapshotVersion\n              );\n              return this.targetCache.setTargetsMetadata(\n                txn,\n                txn.currentSequenceNumber,\n                remoteVersion\n              );\n            });\n          promises.push(updateRemoteVersion);\n        }\n\n        return PersistencePromise.waitFor(promises)\n          .next(() => documentBuffer.apply(txn))\n          .next(() => {\n            return this.localDocuments.getLocalViewOfDocuments(\n              txn,\n              changedDocs\n            );\n          });\n      })\n      .then(changedDocs => {\n        this.targetDataByTarget = newTargetDataByTargetMap;\n        return changedDocs;\n      });\n  }\n\n  /**\n   * Returns true if the newTargetData should be persisted during an update of\n   * an active target. TargetData should always be persisted when a target is\n   * being released and should not call this function.\n   *\n   * While the target is active, TargetData updates can be omitted when nothing\n   * about the target has changed except metadata like the resume token or\n   * snapshot version. Occasionally it's worth the extra write to prevent these\n   * values from getting too stale after a crash, but this doesn't have to be\n   * too frequent.\n   */\n  private static shouldPersistTargetData(\n    oldTargetData: TargetData,\n    newTargetData: TargetData,\n    change: TargetChange\n  ): boolean {\n    hardAssert(\n      newTargetData.resumeToken.approximateByteSize() > 0,\n      'Attempted to persist target data with no resume token'\n    );\n\n    // Always persist target data if we don't already have a resume token.\n    if (oldTargetData.resumeToken.approximateByteSize() === 0) {\n      return true;\n    }\n\n    // Don't allow resume token changes to be buffered indefinitely. This\n    // allows us to be reasonably up-to-date after a crash and avoids needing\n    // to loop over all active queries on shutdown. Especially in the browser\n    // we may not get time to do anything interesting while the current tab is\n    // closing.\n    const timeDelta =\n      newTargetData.snapshotVersion.toMicroseconds() -\n      oldTargetData.snapshotVersion.toMicroseconds();\n    if (timeDelta >= this.RESUME_TOKEN_MAX_AGE_MICROS) {\n      return true;\n    }\n\n    // Otherwise if the only thing that has changed about a target is its resume\n    // token it's not worth persisting. Note that the RemoteStore keeps an\n    // in-memory view of the currently active targets which includes the current\n    // resume token, so stream failure or user changes will still use an\n    // up-to-date resume token regardless of what we do here.\n    const changes =\n      change.addedDocuments.size +\n      change.modifiedDocuments.size +\n      change.removedDocuments.size;\n    return changes > 0;\n  }\n\n  /**\n   * Notify local store of the changed views to locally pin documents.\n   */\n  async notifyLocalViewChanges(viewChanges: LocalViewChanges[]): Promise<void> {\n    try {\n      await this.persistence.runTransaction(\n        'notifyLocalViewChanges',\n        'readwrite',\n        txn => {\n          return PersistencePromise.forEach(\n            viewChanges,\n            (viewChange: LocalViewChanges) => {\n              return PersistencePromise.forEach(\n                viewChange.addedKeys,\n                (key: DocumentKey) =>\n                  this.persistence.referenceDelegate.addReference(\n                    txn,\n                    viewChange.targetId,\n                    key\n                  )\n              ).next(() =>\n                PersistencePromise.forEach(\n                  viewChange.removedKeys,\n                  (key: DocumentKey) =>\n                    this.persistence.referenceDelegate.removeReference(\n                      txn,\n                      viewChange.targetId,\n                      key\n                    )\n                )\n              );\n            }\n          );\n        }\n      );\n    } catch (e) {\n      if (isIndexedDbTransactionError(e)) {\n        // If `notifyLocalViewChanges` fails, we did not advance the sequence\n        // number for the documents that were included in this transaction.\n        // This might trigger them to be deleted earlier than they otherwise\n        // would have, but it should not invalidate the integrity of the data.\n        logDebug(LOG_TAG, 'Failed to update sequence numbers: ' + e);\n      } else {\n        throw e;\n      }\n    }\n\n    for (const viewChange of viewChanges) {\n      const targetId = viewChange.targetId;\n\n      if (!viewChange.fromCache) {\n        const targetData = this.targetDataByTarget.get(targetId);\n        debugAssert(\n          targetData !== null,\n          `Can't set limbo-free snapshot version for unknown target: ${targetId}`\n        );\n\n        // Advance the last limbo free snapshot version\n        const lastLimboFreeSnapshotVersion = targetData.snapshotVersion;\n        const updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(\n          lastLimboFreeSnapshotVersion\n        );\n        this.targetDataByTarget = this.targetDataByTarget.insert(\n          targetId,\n          updatedTargetData\n        );\n      }\n    }\n  }\n\n  /**\n   * Gets the mutation batch after the passed in batchId in the mutation queue\n   * or null if empty.\n   * @param afterBatchId If provided, the batch to search after.\n   * @returns The next mutation or null if there wasn't one.\n   */\n  nextMutationBatch(afterBatchId?: BatchId): Promise<MutationBatch | null> {\n    return this.persistence.runTransaction(\n      'Get next mutation batch',\n      'readonly',\n      txn => {\n        if (afterBatchId === undefined) {\n          afterBatchId = BATCHID_UNKNOWN;\n        }\n        return this.mutationQueue.getNextMutationBatchAfterBatchId(\n          txn,\n          afterBatchId\n        );\n      }\n    );\n  }\n\n  /**\n   * Read the current value of a Document with a given key or null if not\n   * found - used for testing.\n   */\n  readDocument(key: DocumentKey): Promise<MaybeDocument | null> {\n    return this.persistence.runTransaction('read document', 'readonly', txn => {\n      return this.localDocuments.getDocument(txn, key);\n    });\n  }\n\n  /**\n   * Assigns the given target an internal ID so that its results can be pinned so\n   * they don't get GC'd. A target must be allocated in the local store before\n   * the store can be used to manage its view.\n   *\n   * Allocating an already allocated `Target` will return the existing `TargetData`\n   * for that `Target`.\n   */\n  allocateTarget(target: Target): Promise<TargetData> {\n    return this.persistence\n      .runTransaction('Allocate target', 'readwrite', txn => {\n        let targetData: TargetData;\n        return this.targetCache\n          .getTargetData(txn, target)\n          .next((cached: TargetData | null) => {\n            if (cached) {\n              // This target has been listened to previously, so reuse the\n              // previous targetID.\n              // TODO(mcg): freshen last accessed date?\n              targetData = cached;\n              return PersistencePromise.resolve(targetData);\n            } else {\n              return this.targetCache.allocateTargetId(txn).next(targetId => {\n                targetData = new TargetData(\n                  target,\n                  targetId,\n                  TargetPurpose.Listen,\n                  txn.currentSequenceNumber\n                );\n                return this.targetCache\n                  .addTargetData(txn, targetData)\n                  .next(() => targetData);\n              });\n            }\n          });\n      })\n      .then(targetData => {\n        // If Multi-Tab is enabled, the existing target data may be newer than\n        // the in-memory data\n        const cachedTargetData = this.targetDataByTarget.get(\n          targetData.targetId\n        );\n        if (\n          cachedTargetData === null ||\n          targetData.snapshotVersion.compareTo(\n            cachedTargetData.snapshotVersion\n          ) > 0\n        ) {\n          this.targetDataByTarget = this.targetDataByTarget.insert(\n            targetData.targetId,\n            targetData\n          );\n          this.targetIdByTarget.set(target, targetData.targetId);\n        }\n        return targetData;\n      });\n  }\n\n  /**\n   * Returns the TargetData as seen by the LocalStore, including updates that may\n   * have not yet been persisted to the TargetCache.\n   */\n  // Visible for testing.\n  getTargetData(\n    transaction: PersistenceTransaction,\n    target: Target\n  ): PersistencePromise<TargetData | null> {\n    const targetId = this.targetIdByTarget.get(target);\n    if (targetId !== undefined) {\n      return PersistencePromise.resolve<TargetData | null>(\n        this.targetDataByTarget.get(targetId)\n      );\n    } else {\n      return this.targetCache.getTargetData(transaction, target);\n    }\n  }\n\n  /**\n   * Unpin all the documents associated with the given target. If\n   * `keepPersistedTargetData` is set to false and Eager GC enabled, the method\n   * directly removes the associated target data from the target cache.\n   *\n   * Releasing a non-existing `Target` is a no-op.\n   */\n  // PORTING NOTE: `keepPersistedTargetData` is multi-tab only.\n  releaseTarget(\n    targetId: number,\n    keepPersistedTargetData: boolean\n  ): Promise<void> {\n    const targetData = this.targetDataByTarget.get(targetId);\n    debugAssert(\n      targetData !== null,\n      `Tried to release nonexistent target: ${targetId}`\n    );\n\n    const mode = keepPersistedTargetData ? 'readwrite' : 'readwrite-primary';\n    return this.persistence\n      .runTransaction('Release target', mode, txn => {\n        if (!keepPersistedTargetData) {\n          return this.persistence.referenceDelegate.removeTarget(\n            txn,\n            targetData!\n          );\n        } else {\n          return PersistencePromise.resolve();\n        }\n      })\n      .then(() => {\n        this.targetDataByTarget = this.targetDataByTarget.remove(targetId);\n        this.targetIdByTarget.delete(targetData!.target);\n      });\n  }\n\n  /**\n   * Runs the specified query against the local store and returns the results,\n   * potentially taking advantage of query data from previous executions (such\n   * as the set of remote keys).\n   *\n   * @param usePreviousResults Whether results from previous executions can\n   * be used to optimize this query execution.\n   */\n  executeQuery(\n    query: Query,\n    usePreviousResults: boolean\n  ): Promise<QueryResult> {\n    let lastLimboFreeSnapshotVersion = SnapshotVersion.min();\n    let remoteKeys = documentKeySet();\n\n    return this.persistence.runTransaction('Execute query', 'readonly', txn => {\n      return this.getTargetData(txn, query.toTarget())\n        .next(targetData => {\n          if (targetData) {\n            lastLimboFreeSnapshotVersion =\n              targetData.lastLimboFreeSnapshotVersion;\n            return this.targetCache\n              .getMatchingKeysForTargetId(txn, targetData.targetId)\n              .next(result => {\n                remoteKeys = result;\n              });\n          }\n        })\n        .next(() =>\n          this.queryEngine.getDocumentsMatchingQuery(\n            txn,\n            query,\n            usePreviousResults\n              ? lastLimboFreeSnapshotVersion\n              : SnapshotVersion.min(),\n            usePreviousResults ? remoteKeys : documentKeySet()\n          )\n        )\n        .next(documents => {\n          return { documents, remoteKeys };\n        });\n    });\n  }\n\n  private applyWriteToRemoteDocuments(\n    txn: PersistenceTransaction,\n    batchResult: MutationBatchResult,\n    documentBuffer: RemoteDocumentChangeBuffer\n  ): PersistencePromise<void> {\n    const batch = batchResult.batch;\n    const docKeys = batch.keys();\n    let promiseChain = PersistencePromise.resolve();\n    docKeys.forEach(docKey => {\n      promiseChain = promiseChain\n        .next(() => {\n          return documentBuffer.getEntry(txn, docKey);\n        })\n        .next((remoteDoc: MaybeDocument | null) => {\n          let doc = remoteDoc;\n          const ackVersion = batchResult.docVersions.get(docKey);\n          hardAssert(\n            ackVersion !== null,\n            'ackVersions should contain every doc in the write.'\n          );\n          if (!doc || doc.version.compareTo(ackVersion!) < 0) {\n            doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n            if (!doc) {\n              debugAssert(\n                !remoteDoc,\n                'Mutation batch ' +\n                  batch +\n                  ' applied to document ' +\n                  remoteDoc +\n                  ' resulted in null'\n              );\n            } else {\n              // We use the commitVersion as the readTime rather than the\n              // document's updateTime since the updateTime is not advanced\n              // for updates that do not modify the underlying document.\n              documentBuffer.addEntry(doc, batchResult.commitVersion);\n            }\n          }\n        });\n    });\n    return promiseChain.next(() =>\n      this.mutationQueue.removeMutationBatch(txn, batch)\n    );\n  }\n\n  collectGarbage(garbageCollector: LruGarbageCollector): Promise<LruResults> {\n    return this.persistence.runTransaction(\n      'Collect garbage',\n      'readwrite-primary',\n      txn => garbageCollector.collect(txn, this.targetDataByTarget)\n    );\n  }\n}\n\n/**\n * An implementation of LocalStore that provides additional functionality\n * for MultiTabSyncEngine.\n */\n// PORTING NOTE: Web only.\nexport class MultiTabLocalStore extends LocalStore {\n  protected mutationQueue: IndexedDbMutationQueue;\n  protected remoteDocuments: IndexedDbRemoteDocumentCache;\n  protected targetCache: IndexedDbTargetCache;\n\n  constructor(\n    protected persistence: IndexedDbPersistence,\n    queryEngine: QueryEngine,\n    initialUser: User\n  ) {\n    super(persistence, queryEngine, initialUser);\n\n    this.mutationQueue = persistence.getMutationQueue(initialUser);\n    this.remoteDocuments = persistence.getRemoteDocumentCache();\n    this.targetCache = persistence.getTargetCache();\n  }\n\n  /** Starts the LocalStore. */\n  start(): Promise<void> {\n    return this.synchronizeLastDocumentChangeReadTime();\n  }\n\n  /** Returns the local view of the documents affected by a mutation batch. */\n  lookupMutationDocuments(batchId: BatchId): Promise<MaybeDocumentMap | null> {\n    return this.persistence.runTransaction(\n      'Lookup mutation documents',\n      'readonly',\n      txn => {\n        return this.mutationQueue\n          .lookupMutationKeys(txn, batchId)\n          .next(keys => {\n            if (keys) {\n              return this.localDocuments.getDocuments(\n                txn,\n                keys\n              ) as PersistencePromise<MaybeDocumentMap | null>;\n            } else {\n              return PersistencePromise.resolve<MaybeDocumentMap | null>(null);\n            }\n          });\n      }\n    );\n  }\n\n  removeCachedMutationBatchMetadata(batchId: BatchId): void {\n    this.mutationQueue.removeCachedMutationKeys(batchId);\n  }\n\n  setNetworkEnabled(networkEnabled: boolean): void {\n    this.persistence.setNetworkEnabled(networkEnabled);\n  }\n\n  getActiveClients(): Promise<ClientId[]> {\n    return this.persistence.getActiveClients();\n  }\n\n  getTarget(targetId: TargetId): Promise<Target | null> {\n    const cachedTargetData = this.targetDataByTarget.get(targetId);\n\n    if (cachedTargetData) {\n      return Promise.resolve(cachedTargetData.target);\n    } else {\n      return this.persistence.runTransaction(\n        'Get target data',\n        'readonly',\n        txn => {\n          return this.targetCache\n            .getTargetDataForTarget(txn, targetId)\n            .next(targetData => (targetData ? targetData.target : null));\n        }\n      );\n    }\n  }\n\n  /**\n   * Returns the set of documents that have been updated since the last call.\n   * If this is the first call, returns the set of changes since client\n   * initialization. Further invocations will return document changes since\n   * the point of rejection.\n   */\n  getNewDocumentChanges(): Promise<MaybeDocumentMap> {\n    return this.persistence\n      .runTransaction('Get new document changes', 'readonly', txn =>\n        this.remoteDocuments.getNewDocumentChanges(\n          txn,\n          this.lastDocumentChangeReadTime\n        )\n      )\n      .then(({ changedDocs, readTime }) => {\n        this.lastDocumentChangeReadTime = readTime;\n        return changedDocs;\n      });\n  }\n\n  /**\n   * Reads the newest document change from persistence and forwards the internal\n   * synchronization marker so that calls to `getNewDocumentChanges()`\n   * only return changes that happened after client initialization.\n   */\n  async synchronizeLastDocumentChangeReadTime(): Promise<void> {\n    this.lastDocumentChangeReadTime = await this.persistence.runTransaction(\n      'Synchronize last document change read time',\n      'readonly',\n      txn => this.remoteDocuments.getLastReadTime(txn)\n    );\n  }\n}\n\n/**\n * Verifies the error thrown by a LocalStore operation. If a LocalStore\n * operation fails because the primary lease has been taken by another client,\n * we ignore the error (the persistence layer will immediately call\n * `applyPrimaryLease` to propagate the primary state change). All other errors\n * are re-thrown.\n *\n * @param err An error returned by a LocalStore operation.\n * @return A Promise that resolves after we recovered, or the original error.\n */\nexport async function ignoreIfPrimaryLeaseLoss(\n  err: FirestoreError\n): Promise<void> {\n  if (\n    err.code === Code.FAILED_PRECONDITION &&\n    err.message === PRIMARY_LEASE_LOST_ERROR_MSG\n  ) {\n    logDebug(LOG_TAG, 'Unexpectedly lost primary lease');\n  } else {\n    throw err;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TargetId } from '../core/types';\nimport { ChangeType, ViewSnapshot } from '../core/view_snapshot';\nimport { documentKeySet, DocumentKeySet } from '../model/collections';\n\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nexport class LocalViewChanges {\n  constructor(\n    readonly targetId: TargetId,\n    readonly fromCache: boolean,\n    readonly addedKeys: DocumentKeySet,\n    readonly removedKeys: DocumentKeySet\n  ) {}\n\n  static fromSnapshot(\n    targetId: TargetId,\n    viewSnapshot: ViewSnapshot\n  ): LocalViewChanges {\n    let addedKeys = documentKeySet();\n    let removedKeys = documentKeySet();\n\n    for (const docChange of viewSnapshot.docChanges) {\n      switch (docChange.type) {\n        case ChangeType.Added:\n          addedKeys = addedKeys.add(docChange.doc.key);\n          break;\n        case ChangeType.Removed:\n          removedKeys = removedKeys.add(docChange.doc.key);\n          break;\n        default:\n        // do nothing\n      }\n    }\n\n    return new LocalViewChanges(\n      targetId,\n      viewSnapshot.fromCache,\n      addedKeys,\n      removedKeys\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BatchId, TargetId } from '../core/types';\nimport { documentKeySet, DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\n\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nexport class ReferenceSet {\n  // A set of outstanding references to a document sorted by key.\n  private refsByKey = new SortedSet(DocReference.compareByKey);\n\n  // A set of outstanding references to a document sorted by target id.\n  private refsByTarget = new SortedSet(DocReference.compareByTargetId);\n\n  /** Returns true if the reference set contains no references. */\n  isEmpty(): boolean {\n    return this.refsByKey.isEmpty();\n  }\n\n  /** Adds a reference to the given document key for the given ID. */\n  addReference(key: DocumentKey, id: TargetId | BatchId): void {\n    const ref = new DocReference(key, id);\n    this.refsByKey = this.refsByKey.add(ref);\n    this.refsByTarget = this.refsByTarget.add(ref);\n  }\n\n  /** Add references to the given document keys for the given ID. */\n  addReferences(keys: DocumentKeySet, id: TargetId | BatchId): void {\n    keys.forEach(key => this.addReference(key, id));\n  }\n\n  /**\n   * Removes a reference to the given document key for the given\n   * ID.\n   */\n  removeReference(key: DocumentKey, id: TargetId | BatchId): void {\n    this.removeRef(new DocReference(key, id));\n  }\n\n  removeReferences(keys: DocumentKeySet, id: TargetId | BatchId): void {\n    keys.forEach(key => this.removeReference(key, id));\n  }\n\n  /**\n   * Clears all references with a given ID. Calls removeRef() for each key\n   * removed.\n   */\n  removeReferencesForId(id: TargetId | BatchId): DocumentKey[] {\n    const emptyKey = DocumentKey.EMPTY;\n    const startRef = new DocReference(emptyKey, id);\n    const endRef = new DocReference(emptyKey, id + 1);\n    const keys: DocumentKey[] = [];\n    this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n      this.removeRef(ref);\n      keys.push(ref.key);\n    });\n    return keys;\n  }\n\n  removeAllReferences(): void {\n    this.refsByKey.forEach(ref => this.removeRef(ref));\n  }\n\n  private removeRef(ref: DocReference): void {\n    this.refsByKey = this.refsByKey.delete(ref);\n    this.refsByTarget = this.refsByTarget.delete(ref);\n  }\n\n  referencesForId(id: TargetId | BatchId): DocumentKeySet {\n    const emptyKey = DocumentKey.EMPTY;\n    const startRef = new DocReference(emptyKey, id);\n    const endRef = new DocReference(emptyKey, id + 1);\n    let keys = documentKeySet();\n    this.refsByTarget.forEachInRange([startRef, endRef], ref => {\n      keys = keys.add(ref.key);\n    });\n    return keys;\n  }\n\n  containsKey(key: DocumentKey): boolean {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.refsByKey.firstAfterOrEqual(ref);\n    return firstRef !== null && key.isEqual(firstRef.key);\n  }\n}\n\nexport class DocReference {\n  constructor(\n    public key: DocumentKey,\n    public targetOrBatchId: TargetId | BatchId\n  ) {}\n\n  /** Compare by key then by ID */\n  static compareByKey(left: DocReference, right: DocReference): number {\n    return (\n      DocumentKey.comparator(left.key, right.key) ||\n      primitiveComparator(left.targetOrBatchId, right.targetOrBatchId)\n    );\n  }\n\n  /** Compare by ID then by key */\n  static compareByTargetId(left: DocReference, right: DocReference): number {\n    return (\n      primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n      DocumentKey.comparator(left.key, right.key)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetId } from '../core/types';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  maybeDocumentMap,\n  MaybeDocumentMap,\n  targetIdSet\n} from '../model/collections';\nimport { SortedSet } from '../util/sorted_set';\nimport { ByteString } from '../util/byte_string';\n\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nexport class RemoteEvent {\n  constructor(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    readonly snapshotVersion: SnapshotVersion,\n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    readonly targetChanges: Map<TargetId, TargetChange>,\n    /**\n     * A set of targets that is known to be inconsistent. Listens for these\n     * targets should be re-established without resume tokens.\n     */\n    readonly targetMismatches: SortedSet<TargetId>,\n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    readonly documentUpdates: MaybeDocumentMap,\n    /**\n     * A set of which document updates are due only to limbo resolution targets.\n     */\n    readonly resolvedLimboDocuments: DocumentKeySet\n  ) {}\n\n  /**\n   * HACK: Views require RemoteEvents in order to determine whether the view is\n   * CURRENT, but secondary tabs don't receive remote events. So this method is\n   * used to create a synthesized RemoteEvent that can be used to apply a\n   * CURRENT status change to a View, for queries executed in a different tab.\n   */\n  // PORTING NOTE: Multi-tab only\n  static createSynthesizedRemoteEventForCurrentChange(\n    targetId: TargetId,\n    current: boolean\n  ): RemoteEvent {\n    const targetChanges = new Map<TargetId, TargetChange>();\n    targetChanges.set(\n      targetId,\n      TargetChange.createSynthesizedTargetChangeForCurrentChange(\n        targetId,\n        current\n      )\n    );\n    return new RemoteEvent(\n      SnapshotVersion.min(),\n      targetChanges,\n      targetIdSet(),\n      maybeDocumentMap(),\n      documentKeySet()\n    );\n  }\n}\n\n/**\n * A TargetChange specifies the set of changes for a specific target as part of\n * a RemoteEvent. These changes track which documents are added, modified or\n * removed, as well as the target's resume token and whether the target is\n * marked CURRENT.\n * The actual changes *to* documents are not part of the TargetChange since\n * documents may be part of multiple targets.\n */\nexport class TargetChange {\n  constructor(\n    /**\n     * An opaque, server-assigned token that allows watching a query to be resumed\n     * after disconnecting without retransmitting all the data that matches the\n     * query. The resume token essentially identifies a point in time from which\n     * the server should resume sending results.\n     */\n    readonly resumeToken: ByteString,\n    /**\n     * The \"current\" (synced) status of this target. Note that \"current\"\n     * has special meaning in the RPC protocol that implies that a target is\n     * both up-to-date and consistent with the rest of the watch stream.\n     */\n    readonly current: boolean,\n    /**\n     * The set of documents that were newly assigned to this target as part of\n     * this remote event.\n     */\n    readonly addedDocuments: DocumentKeySet,\n    /**\n     * The set of documents that were already assigned to this target but received\n     * an update during this remote event.\n     */\n    readonly modifiedDocuments: DocumentKeySet,\n    /**\n     * The set of documents that were removed from this target as part of this\n     * remote event.\n     */\n    readonly removedDocuments: DocumentKeySet\n  ) {}\n\n  /**\n   * This method is used to create a synthesized TargetChanges that can be used to\n   * apply a CURRENT status change to a View (for queries executed in a different\n   * tab) or for new queries (to raise snapshots with correct CURRENT status).\n   */\n  static createSynthesizedTargetChangeForCurrentChange(\n    targetId: TargetId,\n    current: boolean\n  ): TargetChange {\n    return new TargetChange(\n      ByteString.EMPTY_BYTE_STRING,\n      current,\n      documentKeySet(),\n      documentKeySet(),\n      documentKeySet()\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DocumentKey } from '../model/document_key';\nimport { ResourcePath } from '../model/path';\nimport { isNullOrUndefined } from '../util/types';\nimport { Bound, Filter, OrderBy } from './query';\n\n/**\n * A Target represents the WatchTarget representation of a Query, which is used\n * by the LocalStore and the RemoteStore to keep track of and to execute\n * backend queries. While a Query can represent multiple Targets, each Targets\n * maps to a single WatchTarget in RemoteStore and a single TargetData entry\n * in persistence.\n */\nexport class Target {\n  private memoizedCanonicalId: string | null = null;\n\n  /**\n   * Initializes a Target with a path and optional additional query constraints.\n   * Path must currently be empty if this is a collection group query.\n   *\n   * NOTE: you should always construct `Target` from `Query.toTarget` instead of\n   * using this constructor, because `Query` provides an implicit `orderBy`\n   * property.\n   */\n  constructor(\n    readonly path: ResourcePath,\n    readonly collectionGroup: string | null = null,\n    readonly orderBy: OrderBy[] = [],\n    readonly filters: Filter[] = [],\n    readonly limit: number | null = null,\n    readonly startAt: Bound | null = null,\n    readonly endAt: Bound | null = null\n  ) {}\n\n  canonicalId(): string {\n    if (this.memoizedCanonicalId === null) {\n      let canonicalId = this.path.canonicalString();\n      if (this.collectionGroup !== null) {\n        canonicalId += '|cg:' + this.collectionGroup;\n      }\n      canonicalId += '|f:';\n      canonicalId += this.filters.map(f => f.canonicalId()).join(',');\n      canonicalId += '|ob:';\n      canonicalId += this.orderBy.map(o => o.canonicalId()).join(',');\n\n      if (!isNullOrUndefined(this.limit)) {\n        canonicalId += '|l:';\n        canonicalId += this.limit!;\n      }\n      if (this.startAt) {\n        canonicalId += '|lb:';\n        canonicalId += this.startAt.canonicalId();\n      }\n      if (this.endAt) {\n        canonicalId += '|ub:';\n        canonicalId += this.endAt.canonicalId();\n      }\n      this.memoizedCanonicalId = canonicalId;\n    }\n    return this.memoizedCanonicalId;\n  }\n\n  toString(): string {\n    let str = this.path.canonicalString();\n    if (this.collectionGroup !== null) {\n      str += ' collectionGroup=' + this.collectionGroup;\n    }\n    if (this.filters.length > 0) {\n      str += `, filters: [${this.filters.join(', ')}]`;\n    }\n    if (!isNullOrUndefined(this.limit)) {\n      str += ', limit: ' + this.limit;\n    }\n    if (this.orderBy.length > 0) {\n      str += `, orderBy: [${this.orderBy.join(', ')}]`;\n    }\n    if (this.startAt) {\n      str += ', startAt: ' + this.startAt.canonicalId();\n    }\n    if (this.endAt) {\n      str += ', endAt: ' + this.endAt.canonicalId();\n    }\n    return `Target(${str})`;\n  }\n\n  isEqual(other: Target): boolean {\n    if (this.limit !== other.limit) {\n      return false;\n    }\n\n    if (this.orderBy.length !== other.orderBy.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.orderBy.length; i++) {\n      if (!this.orderBy[i].isEqual(other.orderBy[i])) {\n        return false;\n      }\n    }\n\n    if (this.filters.length !== other.filters.length) {\n      return false;\n    }\n\n    for (let i = 0; i < this.filters.length; i++) {\n      if (!this.filters[i].isEqual(other.filters[i])) {\n        return false;\n      }\n    }\n\n    if (this.collectionGroup !== other.collectionGroup) {\n      return false;\n    }\n\n    if (!this.path.isEqual(other.path)) {\n      return false;\n    }\n\n    if (\n      this.startAt !== null\n        ? !this.startAt.isEqual(other.startAt)\n        : other.startAt !== null\n    ) {\n      return false;\n    }\n\n    return this.endAt !== null\n      ? this.endAt.isEqual(other.endAt)\n      : other.endAt === null;\n  }\n\n  isDocumentQuery(): boolean {\n    return (\n      DocumentKey.isDocumentKey(this.path) &&\n      this.collectionGroup === null &&\n      this.filters.length === 0\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { compareDocumentsByField, Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  canonicalId,\n  valueCompare,\n  arrayValueContains,\n  valueEquals,\n  isArray,\n  isNanValue,\n  isNullValue,\n  isReferenceValue,\n  typeOrder\n} from '../model/values';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { debugAssert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\nimport { Target } from './target';\n\nexport const enum LimitType {\n  First = 'F',\n  Last = 'L'\n}\n\n/**\n * Query encapsulates all the query attributes we support in the SDK. It can\n * be run against the LocalStore, as well as be converted to a `Target` to\n * query the RemoteStore results.\n */\nexport class Query {\n  static atPath(path: ResourcePath): Query {\n    return new Query(path);\n  }\n\n  private memoizedOrderBy: OrderBy[] | null = null;\n\n  // The corresponding `Target` of this `Query` instance.\n  private memoizedTarget: Target | null = null;\n\n  /**\n   * Initializes a Query with a path and optional additional query constraints.\n   * Path must currently be empty if this is a collection group query.\n   */\n  constructor(\n    readonly path: ResourcePath,\n    readonly collectionGroup: string | null = null,\n    readonly explicitOrderBy: OrderBy[] = [],\n    readonly filters: Filter[] = [],\n    readonly limit: number | null = null,\n    readonly limitType: LimitType = LimitType.First,\n    readonly startAt: Bound | null = null,\n    readonly endAt: Bound | null = null\n  ) {\n    if (this.startAt) {\n      this.assertValidBound(this.startAt);\n    }\n    if (this.endAt) {\n      this.assertValidBound(this.endAt);\n    }\n  }\n\n  get orderBy(): OrderBy[] {\n    if (this.memoizedOrderBy === null) {\n      this.memoizedOrderBy = [];\n\n      const inequalityField = this.getInequalityFilterField();\n      const firstOrderByField = this.getFirstOrderByField();\n      if (inequalityField !== null && firstOrderByField === null) {\n        // In order to implicitly add key ordering, we must also add the\n        // inequality filter field for it to be a valid query.\n        // Note that the default inequality field and key ordering is ascending.\n        if (!inequalityField.isKeyField()) {\n          this.memoizedOrderBy.push(new OrderBy(inequalityField));\n        }\n        this.memoizedOrderBy.push(\n          new OrderBy(FieldPath.keyField(), Direction.ASCENDING)\n        );\n      } else {\n        debugAssert(\n          inequalityField === null ||\n            (firstOrderByField !== null &&\n              inequalityField.isEqual(firstOrderByField)),\n          'First orderBy should match inequality field.'\n        );\n        let foundKeyOrdering = false;\n        for (const orderBy of this.explicitOrderBy) {\n          this.memoizedOrderBy.push(orderBy);\n          if (orderBy.field.isKeyField()) {\n            foundKeyOrdering = true;\n          }\n        }\n        if (!foundKeyOrdering) {\n          // The order of the implicit key ordering always matches the last\n          // explicit order by\n          const lastDirection =\n            this.explicitOrderBy.length > 0\n              ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n              : Direction.ASCENDING;\n          this.memoizedOrderBy.push(\n            new OrderBy(FieldPath.keyField(), lastDirection)\n          );\n        }\n      }\n    }\n    return this.memoizedOrderBy;\n  }\n\n  addFilter(filter: Filter): Query {\n    debugAssert(\n      this.getInequalityFilterField() == null ||\n        !(filter instanceof FieldFilter) ||\n        !filter.isInequality() ||\n        filter.field.isEqual(this.getInequalityFilterField()!),\n      'Query must only have one inequality field.'\n    );\n\n    debugAssert(\n      !this.isDocumentQuery(),\n      'No filtering allowed for document query'\n    );\n\n    const newFilters = this.filters.concat([filter]);\n    return new Query(\n      this.path,\n      this.collectionGroup,\n      this.explicitOrderBy.slice(),\n      newFilters,\n      this.limit,\n      this.limitType,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  addOrderBy(orderBy: OrderBy): Query {\n    debugAssert(\n      !this.startAt && !this.endAt,\n      'Bounds must be set after orderBy'\n    );\n    // TODO(dimond): validate that orderBy does not list the same key twice.\n    const newOrderBy = this.explicitOrderBy.concat([orderBy]);\n    return new Query(\n      this.path,\n      this.collectionGroup,\n      newOrderBy,\n      this.filters.slice(),\n      this.limit,\n      this.limitType,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withLimitToFirst(limit: number | null): Query {\n    return new Query(\n      this.path,\n      this.collectionGroup,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      limit,\n      LimitType.First,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withLimitToLast(limit: number | null): Query {\n    return new Query(\n      this.path,\n      this.collectionGroup,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      limit,\n      LimitType.Last,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  withStartAt(bound: Bound): Query {\n    return new Query(\n      this.path,\n      this.collectionGroup,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      this.limitType,\n      bound,\n      this.endAt\n    );\n  }\n\n  withEndAt(bound: Bound): Query {\n    return new Query(\n      this.path,\n      this.collectionGroup,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      this.limitType,\n      this.startAt,\n      bound\n    );\n  }\n\n  /**\n   * Helper to convert a collection group query into a collection query at a\n   * specific path. This is used when executing collection group queries, since\n   * we have to split the query into a set of collection queries at multiple\n   * paths.\n   */\n  asCollectionQueryAtPath(path: ResourcePath): Query {\n    return new Query(\n      path,\n      /*collectionGroup=*/ null,\n      this.explicitOrderBy.slice(),\n      this.filters.slice(),\n      this.limit,\n      this.limitType,\n      this.startAt,\n      this.endAt\n    );\n  }\n\n  /**\n   * Returns true if this query does not specify any query constraints that\n   * could remove results.\n   */\n  matchesAllDocuments(): boolean {\n    return (\n      this.filters.length === 0 &&\n      this.limit === null &&\n      this.startAt == null &&\n      this.endAt == null &&\n      (this.explicitOrderBy.length === 0 ||\n        (this.explicitOrderBy.length === 1 &&\n          this.explicitOrderBy[0].field.isKeyField()))\n    );\n  }\n\n  // TODO(b/29183165): This is used to get a unique string from a query to, for\n  // example, use as a dictionary key, but the implementation is subject to\n  // collisions. Make it collision-free.\n  canonicalId(): string {\n    return `${this.toTarget().canonicalId()}|lt:${this.limitType}`;\n  }\n\n  toString(): string {\n    return `Query(target=${this.toTarget().toString()}; limitType=${\n      this.limitType\n    })`;\n  }\n\n  isEqual(other: Query): boolean {\n    return (\n      this.toTarget().isEqual(other.toTarget()) &&\n      this.limitType === other.limitType\n    );\n  }\n\n  docComparator(d1: Document, d2: Document): number {\n    let comparedOnKeyField = false;\n    for (const orderBy of this.orderBy) {\n      const comp = orderBy.compare(d1, d2);\n      if (comp !== 0) {\n        return comp;\n      }\n      comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n    }\n    // Assert that we actually compared by key\n    debugAssert(\n      comparedOnKeyField,\n      \"orderBy used that doesn't compare on key field\"\n    );\n    return 0;\n  }\n\n  matches(doc: Document): boolean {\n    return (\n      this.matchesPathAndCollectionGroup(doc) &&\n      this.matchesOrderBy(doc) &&\n      this.matchesFilters(doc) &&\n      this.matchesBounds(doc)\n    );\n  }\n\n  hasLimitToFirst(): boolean {\n    return !isNullOrUndefined(this.limit) && this.limitType === LimitType.First;\n  }\n\n  hasLimitToLast(): boolean {\n    return !isNullOrUndefined(this.limit) && this.limitType === LimitType.Last;\n  }\n\n  getFirstOrderByField(): FieldPath | null {\n    return this.explicitOrderBy.length > 0\n      ? this.explicitOrderBy[0].field\n      : null;\n  }\n\n  getInequalityFilterField(): FieldPath | null {\n    for (const filter of this.filters) {\n      if (filter instanceof FieldFilter && filter.isInequality()) {\n        return filter.field;\n      }\n    }\n    return null;\n  }\n\n  // Checks if any of the provided Operators are included in the query and\n  // returns the first one that is, or null if none are.\n  findFilterOperator(operators: Operator[]): Operator | null {\n    for (const filter of this.filters) {\n      if (filter instanceof FieldFilter) {\n        if (operators.indexOf(filter.op) >= 0) {\n          return filter.op;\n        }\n      }\n    }\n    return null;\n  }\n\n  isDocumentQuery(): boolean {\n    return this.toTarget().isDocumentQuery();\n  }\n\n  isCollectionGroupQuery(): boolean {\n    return this.collectionGroup !== null;\n  }\n\n  /**\n   * Converts this `Query` instance to it's corresponding `Target`\n   * representation.\n   */\n  toTarget(): Target {\n    if (!this.memoizedTarget) {\n      if (this.limitType === LimitType.First) {\n        this.memoizedTarget = new Target(\n          this.path,\n          this.collectionGroup,\n          this.orderBy,\n          this.filters,\n          this.limit,\n          this.startAt,\n          this.endAt\n        );\n      } else {\n        // Flip the orderBy directions since we want the last results\n        const orderBys = [] as OrderBy[];\n        for (const orderBy of this.orderBy) {\n          const dir =\n            orderBy.dir === Direction.DESCENDING\n              ? Direction.ASCENDING\n              : Direction.DESCENDING;\n          orderBys.push(new OrderBy(orderBy.field, dir));\n        }\n\n        // We need to swap the cursors to match the now-flipped query ordering.\n        const startAt = this.endAt\n          ? new Bound(this.endAt.position, !this.endAt.before)\n          : null;\n        const endAt = this.startAt\n          ? new Bound(this.startAt.position, !this.startAt.before)\n          : null;\n\n        // Now return as a LimitType.First query.\n        this.memoizedTarget = new Target(\n          this.path,\n          this.collectionGroup,\n          orderBys,\n          this.filters,\n          this.limit,\n          startAt,\n          endAt\n        );\n      }\n    }\n    return this.memoizedTarget!;\n  }\n\n  private matchesPathAndCollectionGroup(doc: Document): boolean {\n    const docPath = doc.key.path;\n    if (this.collectionGroup !== null) {\n      // NOTE: this.path is currently always empty since we don't expose Collection\n      // Group queries rooted at a document path yet.\n      return (\n        doc.key.hasCollectionId(this.collectionGroup) &&\n        this.path.isPrefixOf(docPath)\n      );\n    } else if (DocumentKey.isDocumentKey(this.path)) {\n      // exact match for document queries\n      return this.path.isEqual(docPath);\n    } else {\n      // shallow ancestor queries by default\n      return this.path.isImmediateParentOf(docPath);\n    }\n  }\n\n  /**\n   * A document must have a value for every ordering clause in order to show up\n   * in the results.\n   */\n  private matchesOrderBy(doc: Document): boolean {\n    for (const orderBy of this.explicitOrderBy) {\n      // order by key always matches\n      if (!orderBy.field.isKeyField() && doc.field(orderBy.field) === null) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private matchesFilters(doc: Document): boolean {\n    for (const filter of this.filters) {\n      if (!filter.matches(doc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Makes sure a document is within the bounds, if provided.\n   */\n  private matchesBounds(doc: Document): boolean {\n    if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n    if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n      return false;\n    }\n    return true;\n  }\n\n  private assertValidBound(bound: Bound): void {\n    debugAssert(\n      bound.position.length <= this.orderBy.length,\n      'Bound is longer than orderBy'\n    );\n  }\n}\n\nexport abstract class Filter {\n  abstract matches(doc: Document): boolean;\n  abstract canonicalId(): string;\n  abstract isEqual(filter: Filter): boolean;\n}\n\nexport const enum Operator {\n  LESS_THAN = '<',\n  LESS_THAN_OR_EQUAL = '<=',\n  EQUAL = '==',\n  GREATER_THAN = '>',\n  GREATER_THAN_OR_EQUAL = '>=',\n  ARRAY_CONTAINS = 'array-contains',\n  IN = 'in',\n  ARRAY_CONTAINS_ANY = 'array-contains-any'\n}\n\nexport class FieldFilter extends Filter {\n  protected constructor(\n    public field: FieldPath,\n    public op: Operator,\n    public value: api.Value\n  ) {\n    super();\n  }\n\n  /**\n   * Creates a filter based on the provided arguments.\n   */\n  static create(field: FieldPath, op: Operator, value: api.Value): FieldFilter {\n    if (field.isKeyField()) {\n      if (op === Operator.IN) {\n        debugAssert(\n          isArray(value),\n          'Comparing on key with IN, but filter value not an ArrayValue'\n        );\n        debugAssert(\n          (value.arrayValue.values || []).every(elem => isReferenceValue(elem)),\n          'Comparing on key with IN, but an array value was not a RefValue'\n        );\n        return new KeyFieldInFilter(field, value);\n      } else {\n        debugAssert(\n          isReferenceValue(value),\n          'Comparing on key, but filter value not a RefValue'\n        );\n        debugAssert(\n          op !== Operator.ARRAY_CONTAINS && op !== Operator.ARRAY_CONTAINS_ANY,\n          `'${op.toString()}' queries don't make sense on document keys.`\n        );\n        return new KeyFieldFilter(field, op, value);\n      }\n    } else if (isNullValue(value)) {\n      if (op !== Operator.EQUAL) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. Null supports only equality comparisons.'\n        );\n      }\n      return new FieldFilter(field, op, value);\n    } else if (isNanValue(value)) {\n      if (op !== Operator.EQUAL) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. NaN supports only equality comparisons.'\n        );\n      }\n      return new FieldFilter(field, op, value);\n    } else if (op === Operator.ARRAY_CONTAINS) {\n      return new ArrayContainsFilter(field, value);\n    } else if (op === Operator.IN) {\n      debugAssert(\n        isArray(value),\n        'IN filter has invalid value: ' + value.toString()\n      );\n      return new InFilter(field, value);\n    } else if (op === Operator.ARRAY_CONTAINS_ANY) {\n      debugAssert(\n        isArray(value),\n        'ARRAY_CONTAINS_ANY filter has invalid value: ' + value.toString()\n      );\n      return new ArrayContainsAnyFilter(field, value);\n    } else {\n      return new FieldFilter(field, op, value);\n    }\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.field(this.field);\n\n    // Only compare types with matching backend order (such as double and int).\n    return (\n      other !== null &&\n      typeOrder(this.value) === typeOrder(other) &&\n      this.matchesComparison(valueCompare(other, this.value))\n    );\n  }\n\n  protected matchesComparison(comparison: number): boolean {\n    switch (this.op) {\n      case Operator.LESS_THAN:\n        return comparison < 0;\n      case Operator.LESS_THAN_OR_EQUAL:\n        return comparison <= 0;\n      case Operator.EQUAL:\n        return comparison === 0;\n      case Operator.GREATER_THAN:\n        return comparison > 0;\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return comparison >= 0;\n      default:\n        return fail('Unknown FieldFilter operator: ' + this.op);\n    }\n  }\n\n  isInequality(): boolean {\n    return (\n      [\n        Operator.LESS_THAN,\n        Operator.LESS_THAN_OR_EQUAL,\n        Operator.GREATER_THAN,\n        Operator.GREATER_THAN_OR_EQUAL\n      ].indexOf(this.op) >= 0\n    );\n  }\n\n  canonicalId(): string {\n    // TODO(b/29183165): Technically, this won't be unique if two values have\n    // the same description, such as the int 3 and the string \"3\". So we should\n    // add the types in here somehow, too.\n    return (\n      this.field.canonicalString() +\n      this.op.toString() +\n      canonicalId(this.value)\n    );\n  }\n\n  isEqual(other: Filter): boolean {\n    if (other instanceof FieldFilter) {\n      return (\n        this.op === other.op &&\n        this.field.isEqual(other.field) &&\n        valueEquals(this.value, other.value)\n      );\n    } else {\n      return false;\n    }\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} ${this.op} ${canonicalId(\n      this.value\n    )}`;\n  }\n}\n\n/** Filter that matches on key fields (i.e. '__name__'). */\nexport class KeyFieldFilter extends FieldFilter {\n  private readonly key: DocumentKey;\n\n  constructor(field: FieldPath, op: Operator, value: api.Value) {\n    super(field, op, value);\n    debugAssert(\n      isReferenceValue(value),\n      'KeyFieldFilter expects a ReferenceValue'\n    );\n    this.key = DocumentKey.fromName(value.referenceValue);\n  }\n\n  matches(doc: Document): boolean {\n    const comparison = DocumentKey.comparator(doc.key, this.key);\n    return this.matchesComparison(comparison);\n  }\n}\n\n/** Filter that matches on key fields within an array. */\nexport class KeyFieldInFilter extends FieldFilter {\n  private readonly keys: DocumentKey[];\n\n  constructor(field: FieldPath, value: api.Value) {\n    super(field, Operator.IN, value);\n    debugAssert(isArray(value), 'KeyFieldInFilter expects an ArrayValue');\n    this.keys = (value.arrayValue.values || []).map(v => {\n      debugAssert(\n        isReferenceValue(v),\n        'Comparing on key with IN, but an array value was not a ReferenceValue'\n      );\n      return DocumentKey.fromName(v.referenceValue);\n    });\n  }\n\n  matches(doc: Document): boolean {\n    return this.keys.some(key => key.isEqual(doc.key));\n  }\n}\n\n/** A Filter that implements the array-contains operator. */\nexport class ArrayContainsFilter extends FieldFilter {\n  constructor(field: FieldPath, value: api.Value) {\n    super(field, Operator.ARRAY_CONTAINS, value);\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.field(this.field);\n    return isArray(other) && arrayValueContains(other.arrayValue, this.value);\n  }\n}\n\n/** A Filter that implements the IN operator. */\nexport class InFilter extends FieldFilter {\n  constructor(field: FieldPath, value: api.Value) {\n    super(field, Operator.IN, value);\n    debugAssert(isArray(value), 'InFilter expects an ArrayValue');\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.field(this.field);\n    return other !== null && arrayValueContains(this.value.arrayValue!, other);\n  }\n}\n\n/** A Filter that implements the array-contains-any operator. */\nexport class ArrayContainsAnyFilter extends FieldFilter {\n  constructor(field: FieldPath, value: api.Value) {\n    super(field, Operator.ARRAY_CONTAINS_ANY, value);\n    debugAssert(isArray(value), 'ArrayContainsAnyFilter expects an ArrayValue');\n  }\n\n  matches(doc: Document): boolean {\n    const other = doc.field(this.field);\n    if (!isArray(other) || !other.arrayValue.values) {\n      return false;\n    }\n    return other.arrayValue.values.some(val =>\n      arrayValueContains(this.value.arrayValue!, val)\n    );\n  }\n}\n\n/**\n * The direction of sorting in an order by.\n */\nexport const enum Direction {\n  ASCENDING = 'asc',\n  DESCENDING = 'desc'\n}\n\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nexport class Bound {\n  constructor(readonly position: api.Value[], readonly before: boolean) {}\n\n  canonicalId(): string {\n    // TODO(b/29183165): Make this collision robust.\n    return `${this.before ? 'b' : 'a'}:${this.position\n      .map(p => canonicalId(p))\n      .join(',')}`;\n  }\n\n  /**\n   * Returns true if a document sorts before a bound using the provided sort\n   * order.\n   */\n  sortsBeforeDocument(orderBy: OrderBy[], doc: Document): boolean {\n    debugAssert(\n      this.position.length <= orderBy.length,\n      \"Bound has more components than query's orderBy\"\n    );\n    let comparison = 0;\n    for (let i = 0; i < this.position.length; i++) {\n      const orderByComponent = orderBy[i];\n      const component = this.position[i];\n      if (orderByComponent.field.isKeyField()) {\n        debugAssert(\n          isReferenceValue(component),\n          'Bound has a non-key value where the key path is being used.'\n        );\n        comparison = DocumentKey.comparator(\n          DocumentKey.fromName(component.referenceValue),\n          doc.key\n        );\n      } else {\n        const docValue = doc.field(orderByComponent.field);\n        debugAssert(\n          docValue !== null,\n          'Field should exist since document matched the orderBy already.'\n        );\n        comparison = valueCompare(component, docValue);\n      }\n      if (orderByComponent.dir === Direction.DESCENDING) {\n        comparison = comparison * -1;\n      }\n      if (comparison !== 0) {\n        break;\n      }\n    }\n    return this.before ? comparison <= 0 : comparison < 0;\n  }\n\n  isEqual(other: Bound | null): boolean {\n    if (other === null) {\n      return false;\n    }\n    if (\n      this.before !== other.before ||\n      this.position.length !== other.position.length\n    ) {\n      return false;\n    }\n    for (let i = 0; i < this.position.length; i++) {\n      const thisPosition = this.position[i];\n      const otherPosition = other.position[i];\n      if (!valueEquals(thisPosition, otherPosition)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nexport class OrderBy {\n  readonly dir: Direction;\n  private readonly isKeyOrderBy: boolean;\n\n  constructor(readonly field: FieldPath, dir?: Direction) {\n    if (dir === undefined) {\n      dir = Direction.ASCENDING;\n    }\n    this.dir = dir;\n    this.isKeyOrderBy = field.isKeyField();\n  }\n\n  compare(d1: Document, d2: Document): number {\n    const comparison = this.isKeyOrderBy\n      ? DocumentKey.comparator(d1.key, d2.key)\n      : compareDocumentsByField(this.field, d1, d2);\n    switch (this.dir) {\n      case Direction.ASCENDING:\n        return comparison;\n      case Direction.DESCENDING:\n        return -1 * comparison;\n      default:\n        return fail('Unknown direction: ' + this.dir);\n    }\n  }\n\n  canonicalId(): string {\n    // TODO(b/29183165): Make this collision robust.\n    return this.field.canonicalString() + this.dir.toString();\n  }\n\n  toString(): string {\n    return `${this.field.canonicalString()} (${this.dir})`;\n  }\n\n  isEqual(other: OrderBy): boolean {\n    return this.dir === other.dir && this.field.isEqual(other.field);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SortedMap } from '../util/sorted_map';\n\nimport { documentMap } from './collections';\nimport { Document } from './document';\nimport { DocumentComparator } from './document_comparator';\nimport { DocumentKey } from './document_key';\n\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\n\nexport class DocumentSet {\n  /**\n   * Returns an empty copy of the existing DocumentSet, using the same\n   * comparator.\n   */\n  static emptySet(oldSet: DocumentSet): DocumentSet {\n    return new DocumentSet(oldSet.comparator);\n  }\n\n  private comparator: DocumentComparator;\n  private keyedMap: SortedMap<DocumentKey, Document>;\n  private sortedSet: SortedMap<Document, null>;\n\n  /** The default ordering is by key if the comparator is omitted */\n  constructor(comp?: DocumentComparator) {\n    // We are adding document key comparator to the end as it's the only\n    // guaranteed unique property of a document.\n    if (comp) {\n      this.comparator = (d1: Document, d2: Document) =>\n        comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n    } else {\n      this.comparator = (d1: Document, d2: Document) =>\n        DocumentKey.comparator(d1.key, d2.key);\n    }\n\n    this.keyedMap = documentMap();\n    this.sortedSet = new SortedMap<Document, null>(this.comparator);\n  }\n\n  has(key: DocumentKey): boolean {\n    return this.keyedMap.get(key) != null;\n  }\n\n  get(key: DocumentKey): Document | null {\n    return this.keyedMap.get(key);\n  }\n\n  first(): Document | null {\n    return this.sortedSet.minKey();\n  }\n\n  last(): Document | null {\n    return this.sortedSet.maxKey();\n  }\n\n  isEmpty(): boolean {\n    return this.sortedSet.isEmpty();\n  }\n\n  /**\n   * Returns the index of the provided key in the document set, or -1 if the\n   * document key is not present in the set;\n   */\n  indexOf(key: DocumentKey): number {\n    const doc = this.keyedMap.get(key);\n    return doc ? this.sortedSet.indexOf(doc) : -1;\n  }\n\n  get size(): number {\n    return this.sortedSet.size;\n  }\n\n  /** Iterates documents in order defined by \"comparator\" */\n  forEach(cb: (doc: Document) => void): void {\n    this.sortedSet.inorderTraversal((k, v) => {\n      cb(k);\n      return false;\n    });\n  }\n\n  /** Inserts or updates a document with the same key */\n  add(doc: Document): DocumentSet {\n    // First remove the element if we have it.\n    const set = this.delete(doc.key);\n    return set.copy(\n      set.keyedMap.insert(doc.key, doc),\n      set.sortedSet.insert(doc, null)\n    );\n  }\n\n  /** Deletes a document with a given key */\n  delete(key: DocumentKey): DocumentSet {\n    const doc = this.get(key);\n    if (!doc) {\n      return this;\n    }\n\n    return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n  }\n\n  isEqual(other: DocumentSet | null | undefined): boolean {\n    if (!(other instanceof DocumentSet)) {\n      return false;\n    }\n    if (this.size !== other.size) {\n      return false;\n    }\n\n    const thisIt = this.sortedSet.getIterator();\n    const otherIt = other.sortedSet.getIterator();\n    while (thisIt.hasNext()) {\n      const thisDoc = thisIt.getNext().key;\n      const otherDoc = otherIt.getNext().key;\n      if (!thisDoc.isEqual(otherDoc)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  toString(): string {\n    const docStrings: string[] = [];\n    this.forEach(doc => {\n      docStrings.push(doc.toString());\n    });\n    if (docStrings.length === 0) {\n      return 'DocumentSet ()';\n    } else {\n      return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n    }\n  }\n\n  private copy(\n    keyedMap: SortedMap<DocumentKey, Document>,\n    sortedSet: SortedMap<Document, null>\n  ): DocumentSet {\n    const newSet = new DocumentSet();\n    newSet.comparator = this.comparator;\n    newSet.keyedMap = keyedMap;\n    newSet.sortedSet = sortedSet;\n    return newSet;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport { fail } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\n\nimport { DocumentKeySet } from '../model/collections';\nimport { Query } from './query';\n\nexport const enum ChangeType {\n  Added,\n  Removed,\n  Modified,\n  Metadata\n}\n\nexport interface DocumentViewChange {\n  type: ChangeType;\n  doc: Document;\n}\n\nexport const enum SyncState {\n  Local,\n  Synced\n}\n\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nexport class DocumentChangeSet {\n  private changeMap = new SortedMap<DocumentKey, DocumentViewChange>(\n    DocumentKey.comparator\n  );\n\n  track(change: DocumentViewChange): void {\n    const key = change.doc.key;\n    const oldChange = this.changeMap.get(key);\n    if (!oldChange) {\n      this.changeMap = this.changeMap.insert(key, change);\n      return;\n    }\n\n    // Merge the new change with the existing change.\n    if (\n      change.type !== ChangeType.Added &&\n      oldChange.type === ChangeType.Metadata\n    ) {\n      this.changeMap = this.changeMap.insert(key, change);\n    } else if (\n      change.type === ChangeType.Metadata &&\n      oldChange.type !== ChangeType.Removed\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: oldChange.type,\n        doc: change.doc\n      });\n    } else if (\n      change.type === ChangeType.Modified &&\n      oldChange.type === ChangeType.Modified\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Modified,\n        doc: change.doc\n      });\n    } else if (\n      change.type === ChangeType.Modified &&\n      oldChange.type === ChangeType.Added\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Added,\n        doc: change.doc\n      });\n    } else if (\n      change.type === ChangeType.Removed &&\n      oldChange.type === ChangeType.Added\n    ) {\n      this.changeMap = this.changeMap.remove(key);\n    } else if (\n      change.type === ChangeType.Removed &&\n      oldChange.type === ChangeType.Modified\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Removed,\n        doc: oldChange.doc\n      });\n    } else if (\n      change.type === ChangeType.Added &&\n      oldChange.type === ChangeType.Removed\n    ) {\n      this.changeMap = this.changeMap.insert(key, {\n        type: ChangeType.Modified,\n        doc: change.doc\n      });\n    } else {\n      // This includes these cases, which don't make sense:\n      // Added->Added\n      // Removed->Removed\n      // Modified->Added\n      // Removed->Modified\n      // Metadata->Added\n      // Removed->Metadata\n      fail(\n        'unsupported combination of changes: ' +\n          JSON.stringify(change) +\n          ' after ' +\n          JSON.stringify(oldChange)\n      );\n    }\n  }\n\n  getChanges(): DocumentViewChange[] {\n    const changes: DocumentViewChange[] = [];\n    this.changeMap.inorderTraversal(\n      (key: DocumentKey, change: DocumentViewChange) => {\n        changes.push(change);\n      }\n    );\n    return changes;\n  }\n}\n\nexport class ViewSnapshot {\n  constructor(\n    readonly query: Query,\n    readonly docs: DocumentSet,\n    readonly oldDocs: DocumentSet,\n    readonly docChanges: DocumentViewChange[],\n    readonly mutatedKeys: DocumentKeySet,\n    readonly fromCache: boolean,\n    readonly syncStateChanged: boolean,\n    readonly excludesMetadataChanges: boolean\n  ) {}\n\n  /** Returns a view snapshot as if all documents in the snapshot were added. */\n  static fromInitialDocuments(\n    query: Query,\n    documents: DocumentSet,\n    mutatedKeys: DocumentKeySet,\n    fromCache: boolean\n  ): ViewSnapshot {\n    const changes: DocumentViewChange[] = [];\n    documents.forEach(doc => {\n      changes.push({ type: ChangeType.Added, doc });\n    });\n\n    return new ViewSnapshot(\n      query,\n      documents,\n      DocumentSet.emptySet(documents),\n      changes,\n      mutatedKeys,\n      fromCache,\n      /* syncStateChanged= */ true,\n      /* excludesMetadataChanges= */ false\n    );\n  }\n\n  get hasPendingWrites(): boolean {\n    return !this.mutatedKeys.isEmpty();\n  }\n\n  isEqual(other: ViewSnapshot): boolean {\n    if (\n      this.fromCache !== other.fromCache ||\n      this.syncStateChanged !== other.syncStateChanged ||\n      !this.mutatedKeys.isEqual(other.mutatedKeys) ||\n      !this.query.isEqual(other.query) ||\n      !this.docs.isEqual(other.docs) ||\n      !this.oldDocs.isEqual(other.oldDocs)\n    ) {\n      return false;\n    }\n    const changes: DocumentViewChange[] = this.docChanges;\n    const otherChanges: DocumentViewChange[] = other.docChanges;\n    if (changes.length !== otherChanges.length) {\n      return false;\n    }\n    for (let i = 0; i < changes.length; i++) {\n      if (\n        changes[i].type !== otherChanges[i].type ||\n        !changes[i].doc.isEqual(otherChanges[i].doc)\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { QueryResult } from '../local/local_store';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DocumentSet } from '../model/document_set';\nimport { TargetChange } from '../remote/remote_event';\nimport { debugAssert, fail } from '../util/assert';\n\nimport { Query } from './query';\nimport { OnlineState } from './types';\nimport {\n  ChangeType,\n  DocumentChangeSet,\n  SyncState,\n  ViewSnapshot\n} from './view_snapshot';\n\nexport type LimboDocumentChange = AddedLimboDocument | RemovedLimboDocument;\nexport class AddedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\nexport class RemovedLimboDocument {\n  constructor(public key: DocumentKey) {}\n}\n\n/** The result of applying a set of doc changes to a view. */\nexport interface ViewDocumentChanges {\n  /** The new set of docs that should be in the view. */\n  documentSet: DocumentSet;\n  /** The diff of these docs with the previous set of docs. */\n  changeSet: DocumentChangeSet;\n  /**\n   * Whether the set of documents passed in was not sufficient to calculate the\n   * new state of the view and there needs to be another pass based on the\n   * local cache.\n   */\n  needsRefill: boolean;\n\n  mutatedKeys: DocumentKeySet;\n}\n\nexport interface ViewChange {\n  snapshot?: ViewSnapshot;\n  limboChanges: LimboDocumentChange[];\n}\n\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nexport class View {\n  private syncState: SyncState | null = null;\n  /**\n   * A flag whether the view is current with the backend. A view is considered\n   * current after it has seen the current flag from the backend and did not\n   * lose consistency within the watch stream (e.g. because of an existence\n   * filter mismatch).\n   */\n  private current = false;\n  private documentSet: DocumentSet;\n  /** Documents in the view but not in the remote target */\n  private limboDocuments = documentKeySet();\n  /** Document Keys that have local changes */\n  private mutatedKeys = documentKeySet();\n\n  constructor(\n    private query: Query,\n    /** Documents included in the remote target */\n    private _syncedDocuments: DocumentKeySet\n  ) {\n    this.documentSet = new DocumentSet(query.docComparator.bind(query));\n  }\n\n  /**\n   * The set of remote documents that the server has told us belongs to the target associated with\n   * this view.\n   */\n  get syncedDocuments(): DocumentKeySet {\n    return this._syncedDocuments;\n  }\n\n  /**\n   * Iterates over a set of doc changes, applies the query limit, and computes\n   * what the new results should be, what the changes were, and whether we may\n   * need to go back to the local cache for more results. Does not make any\n   * changes to the view.\n   * @param docChanges The doc changes to apply to this view.\n   * @param previousChanges If this is being called with a refill, then start\n   *        with this set of docs and changes instead of the current view.\n   * @return a new set of docs, changes, and refill flag.\n   */\n  computeDocChanges(\n    docChanges: MaybeDocumentMap,\n    previousChanges?: ViewDocumentChanges\n  ): ViewDocumentChanges {\n    const changeSet = previousChanges\n      ? previousChanges.changeSet\n      : new DocumentChangeSet();\n    const oldDocumentSet = previousChanges\n      ? previousChanges.documentSet\n      : this.documentSet;\n    let newMutatedKeys = previousChanges\n      ? previousChanges.mutatedKeys\n      : this.mutatedKeys;\n    let newDocumentSet = oldDocumentSet;\n    let needsRefill = false;\n\n    // Track the last doc in a (full) limit. This is necessary, because some\n    // update (a delete, or an update moving a doc past the old limit) might\n    // mean there is some other document in the local cache that either should\n    // come (1) between the old last limit doc and the new last document, in the\n    // case of updates, or (2) after the new last document, in the case of\n    // deletes. So we keep this doc at the old limit to compare the updates to.\n    //\n    // Note that this should never get used in a refill (when previousChanges is\n    // set), because there will only be adds -- no deletes or updates.\n    const lastDocInLimit =\n      this.query.hasLimitToFirst() && oldDocumentSet.size === this.query.limit\n        ? oldDocumentSet.last()\n        : null;\n    const firstDocInLimit =\n      this.query.hasLimitToLast() && oldDocumentSet.size === this.query.limit\n        ? oldDocumentSet.first()\n        : null;\n\n    docChanges.inorderTraversal(\n      (key: DocumentKey, newMaybeDoc: MaybeDocument) => {\n        const oldDoc = oldDocumentSet.get(key);\n        let newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n        if (newDoc) {\n          debugAssert(\n            key.isEqual(newDoc.key),\n            'Mismatching keys found in document changes: ' +\n              key +\n              ' != ' +\n              newDoc.key\n          );\n          newDoc = this.query.matches(newDoc) ? newDoc : null;\n        }\n\n        const oldDocHadPendingMutations = oldDoc\n          ? this.mutatedKeys.has(oldDoc.key)\n          : false;\n        const newDocHasPendingMutations = newDoc\n          ? newDoc.hasLocalMutations ||\n            // We only consider committed mutations for documents that were\n            // mutated during the lifetime of the view.\n            (this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations)\n          : false;\n\n        let changeApplied = false;\n\n        // Calculate change\n        if (oldDoc && newDoc) {\n          const docsEqual = oldDoc.data().isEqual(newDoc.data());\n          if (!docsEqual) {\n            if (!this.shouldWaitForSyncedDocument(oldDoc, newDoc)) {\n              changeSet.track({\n                type: ChangeType.Modified,\n                doc: newDoc\n              });\n              changeApplied = true;\n\n              if (\n                (lastDocInLimit &&\n                  this.query.docComparator(newDoc, lastDocInLimit) > 0) ||\n                (firstDocInLimit &&\n                  this.query.docComparator(newDoc, firstDocInLimit) < 0)\n              ) {\n                // This doc moved from inside the limit to outside the limit.\n                // That means there may be some other doc in the local cache\n                // that should be included instead.\n                needsRefill = true;\n              }\n            }\n          } else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {\n            changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n            changeApplied = true;\n          }\n        } else if (!oldDoc && newDoc) {\n          changeSet.track({ type: ChangeType.Added, doc: newDoc });\n          changeApplied = true;\n        } else if (oldDoc && !newDoc) {\n          changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n          changeApplied = true;\n\n          if (lastDocInLimit || firstDocInLimit) {\n            // A doc was removed from a full limit query. We'll need to\n            // requery from the local cache to see if we know about some other\n            // doc that should be in the results.\n            needsRefill = true;\n          }\n        }\n\n        if (changeApplied) {\n          if (newDoc) {\n            newDocumentSet = newDocumentSet.add(newDoc);\n            if (newDocHasPendingMutations) {\n              newMutatedKeys = newMutatedKeys.add(key);\n            } else {\n              newMutatedKeys = newMutatedKeys.delete(key);\n            }\n          } else {\n            newDocumentSet = newDocumentSet.delete(key);\n            newMutatedKeys = newMutatedKeys.delete(key);\n          }\n        }\n      }\n    );\n\n    // Drop documents out to meet limit/limitToLast requirement.\n    if (this.query.hasLimitToFirst() || this.query.hasLimitToLast()) {\n      while (newDocumentSet.size > this.query.limit!) {\n        const oldDoc = this.query.hasLimitToFirst()\n          ? newDocumentSet.last()\n          : newDocumentSet.first();\n        newDocumentSet = newDocumentSet.delete(oldDoc!.key);\n        newMutatedKeys = newMutatedKeys.delete(oldDoc!.key);\n        changeSet.track({ type: ChangeType.Removed, doc: oldDoc! });\n      }\n    }\n\n    debugAssert(\n      !needsRefill || !previousChanges,\n      'View was refilled using docs that themselves needed refilling.'\n    );\n    return {\n      documentSet: newDocumentSet,\n      changeSet,\n      needsRefill,\n      mutatedKeys: newMutatedKeys\n    };\n  }\n\n  private shouldWaitForSyncedDocument(\n    oldDoc: Document,\n    newDoc: Document\n  ): boolean {\n    // We suppress the initial change event for documents that were modified as\n    // part of a write acknowledgment (e.g. when the value of a server transform\n    // is applied) as Watch will send us the same document again.\n    // By suppressing the event, we only raise two user visible events (one with\n    // `hasPendingWrites` and the final state of the document) instead of three\n    // (one with `hasPendingWrites`, the modified document with\n    // `hasPendingWrites` and the final state of the document).\n    return (\n      oldDoc.hasLocalMutations &&\n      newDoc.hasCommittedMutations &&\n      !newDoc.hasLocalMutations\n    );\n  }\n\n  /**\n   * Updates the view with the given ViewDocumentChanges and optionally updates\n   * limbo docs and sync state from the provided target change.\n   * @param docChanges The set of changes to make to the view's docs.\n   * @param updateLimboDocuments Whether to update limbo documents based on this\n   *        change.\n   * @param targetChange A target change to apply for computing limbo docs and\n   *        sync state.\n   * @return A new ViewChange with the given docs, changes, and sync state.\n   */\n  // PORTING NOTE: The iOS/Android clients always compute limbo document changes.\n  applyChanges(\n    docChanges: ViewDocumentChanges,\n    updateLimboDocuments: boolean,\n    targetChange?: TargetChange\n  ): ViewChange {\n    debugAssert(\n      !docChanges.needsRefill,\n      'Cannot apply changes that need a refill'\n    );\n    const oldDocs = this.documentSet;\n    this.documentSet = docChanges.documentSet;\n    this.mutatedKeys = docChanges.mutatedKeys;\n    // Sort changes based on type and query comparator\n    const changes = docChanges.changeSet.getChanges();\n    changes.sort((c1, c2) => {\n      return (\n        compareChangeType(c1.type, c2.type) ||\n        this.query.docComparator(c1.doc, c2.doc)\n      );\n    });\n\n    this.applyTargetChange(targetChange);\n    const limboChanges = updateLimboDocuments\n      ? this.updateLimboDocuments()\n      : [];\n    const synced = this.limboDocuments.size === 0 && this.current;\n    const newSyncState = synced ? SyncState.Synced : SyncState.Local;\n    const syncStateChanged = newSyncState !== this.syncState;\n    this.syncState = newSyncState;\n\n    if (changes.length === 0 && !syncStateChanged) {\n      // no changes\n      return { limboChanges };\n    } else {\n      const snap: ViewSnapshot = new ViewSnapshot(\n        this.query,\n        docChanges.documentSet,\n        oldDocs,\n        changes,\n        docChanges.mutatedKeys,\n        newSyncState === SyncState.Local,\n        syncStateChanged,\n        /* excludesMetadataChanges= */ false\n      );\n      return {\n        snapshot: snap,\n        limboChanges\n      };\n    }\n  }\n\n  /**\n   * Applies an OnlineState change to the view, potentially generating a\n   * ViewChange if the view's syncState changes as a result.\n   */\n  applyOnlineStateChange(onlineState: OnlineState): ViewChange {\n    if (this.current && onlineState === OnlineState.Offline) {\n      // If we're offline, set `current` to false and then call applyChanges()\n      // to refresh our syncState and generate a ViewChange as appropriate. We\n      // are guaranteed to get a new TargetChange that sets `current` back to\n      // true once the client is back online.\n      this.current = false;\n      return this.applyChanges(\n        {\n          documentSet: this.documentSet,\n          changeSet: new DocumentChangeSet(),\n          mutatedKeys: this.mutatedKeys,\n          needsRefill: false\n        },\n        /* updateLimboDocuments= */ false\n      );\n    } else {\n      // No effect, just return a no-op ViewChange.\n      return { limboChanges: [] };\n    }\n  }\n\n  /**\n   * Returns whether the doc for the given key should be in limbo.\n   */\n  private shouldBeInLimbo(key: DocumentKey): boolean {\n    // If the remote end says it's part of this query, it's not in limbo.\n    if (this._syncedDocuments.has(key)) {\n      return false;\n    }\n    // The local store doesn't think it's a result, so it shouldn't be in limbo.\n    if (!this.documentSet.has(key)) {\n      return false;\n    }\n    // If there are local changes to the doc, they might explain why the server\n    // doesn't know that it's part of the query. So don't put it in limbo.\n    // TODO(klimt): Ideally, we would only consider changes that might actually\n    // affect this specific query.\n    if (this.documentSet.get(key)!.hasLocalMutations) {\n      return false;\n    }\n    // Everything else is in limbo.\n    return true;\n  }\n\n  /**\n   * Updates syncedDocuments, current, and limbo docs based on the given change.\n   * Returns the list of changes to which docs are in limbo.\n   */\n  private applyTargetChange(targetChange?: TargetChange): void {\n    if (targetChange) {\n      targetChange.addedDocuments.forEach(\n        key => (this._syncedDocuments = this._syncedDocuments.add(key))\n      );\n      targetChange.modifiedDocuments.forEach(key => {\n        debugAssert(\n          this._syncedDocuments.has(key),\n          `Modified document ${key} not found in view.`\n        );\n      });\n      targetChange.removedDocuments.forEach(\n        key => (this._syncedDocuments = this._syncedDocuments.delete(key))\n      );\n      this.current = targetChange.current;\n    }\n  }\n\n  private updateLimboDocuments(): LimboDocumentChange[] {\n    // We can only determine limbo documents when we're in-sync with the server.\n    if (!this.current) {\n      return [];\n    }\n\n    // TODO(klimt): Do this incrementally so that it's not quadratic when\n    // updating many documents.\n    const oldLimboDocuments = this.limboDocuments;\n    this.limboDocuments = documentKeySet();\n    this.documentSet.forEach(doc => {\n      if (this.shouldBeInLimbo(doc.key)) {\n        this.limboDocuments = this.limboDocuments.add(doc.key);\n      }\n    });\n\n    // Diff the new limbo docs with the old limbo docs.\n    const changes: LimboDocumentChange[] = [];\n    oldLimboDocuments.forEach(key => {\n      if (!this.limboDocuments.has(key)) {\n        changes.push(new RemovedLimboDocument(key));\n      }\n    });\n    this.limboDocuments.forEach(key => {\n      if (!oldLimboDocuments.has(key)) {\n        changes.push(new AddedLimboDocument(key));\n      }\n    });\n    return changes;\n  }\n\n  /**\n   * Update the in-memory state of the current view with the state read from\n   * persistence.\n   *\n   * We update the query view whenever a client's primary status changes:\n   * - When a client transitions from primary to secondary, it can miss\n   *   LocalStorage updates and its query views may temporarily not be\n   *   synchronized with the state on disk.\n   * - For secondary to primary transitions, the client needs to update the list\n   *   of `syncedDocuments` since secondary clients update their query views\n   *   based purely on synthesized RemoteEvents.\n   *\n   * @param queryResult.documents - The documents that match the query according\n   * to the LocalStore.\n   * @param queryResult.remoteKeys - The keys of the documents that match the\n   * query according to the backend.\n   *\n   * @return The ViewChange that resulted from this synchronization.\n   */\n  // PORTING NOTE: Multi-tab only.\n  synchronizeWithPersistedState(queryResult: QueryResult): ViewChange {\n    this._syncedDocuments = queryResult.remoteKeys;\n    this.limboDocuments = documentKeySet();\n    const docChanges = this.computeDocChanges(queryResult.documents);\n    return this.applyChanges(docChanges, /*updateLimboDocuments=*/ true);\n  }\n\n  /**\n   * Returns a view snapshot as if this query was just listened to. Contains\n   * a document add for every existing document and the `fromCache` and\n   * `hasPendingWrites` status of the already established view.\n   */\n  // PORTING NOTE: Multi-tab only.\n  computeInitialSnapshot(): ViewSnapshot {\n    return ViewSnapshot.fromInitialDocuments(\n      this.query,\n      this.documentSet,\n      this.mutatedKeys,\n      this.syncState === SyncState.Local\n    );\n  }\n}\n\nfunction compareChangeType(c1: ChangeType, c2: ChangeType): number {\n  const order = (change: ChangeType): 0 | 1 | 2 => {\n    switch (change) {\n      case ChangeType.Added:\n        return 1;\n      case ChangeType.Modified:\n        return 2;\n      case ChangeType.Metadata:\n        // A metadata change is converted to a modified change at the public\n        // api layer.  Since we sort by document key and then change type,\n        // metadata and modified changes must be sorted equivalently.\n        return 2;\n      case ChangeType.Removed:\n        return 0;\n      default:\n        return fail('Unknown ChangeType: ' + change);\n    }\n  };\n\n  return order(c1) - order(c2);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AsyncQueue, DelayedOperation, TimerId } from '../util/async_queue';\nimport { logDebug } from '../util/log';\n\nconst LOG_TAG = 'ExponentialBackoff';\n\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nconst DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\n\nconst DEFAULT_BACKOFF_FACTOR = 1.5;\n\n/** Maximum backoff time in milliseconds */\nconst DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nexport class ExponentialBackoff {\n  private currentBaseMs: number = 0;\n  private timerPromise: DelayedOperation<void> | null = null;\n  /** The last backoff attempt, as epoch milliseconds. */\n  private lastAttemptTime = Date.now();\n\n  constructor(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    private readonly queue: AsyncQueue,\n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    private readonly timerId: TimerId,\n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    private readonly initialDelayMs: number = DEFAULT_BACKOFF_INITIAL_DELAY_MS,\n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    private readonly backoffFactor: number = DEFAULT_BACKOFF_FACTOR,\n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    private readonly maxDelayMs: number = DEFAULT_BACKOFF_MAX_DELAY_MS\n  ) {\n    this.reset();\n  }\n\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n  reset(): void {\n    this.currentBaseMs = 0;\n  }\n\n  /**\n   * Resets the backoff delay to the maximum delay (e.g. for use after a\n   * RESOURCE_EXHAUSTED error).\n   */\n  resetToMax(): void {\n    this.currentBaseMs = this.maxDelayMs;\n  }\n\n  /**\n   * Returns a promise that resolves after currentDelayMs, and increases the\n   * delay for any subsequent attempts. If there was a pending backoff operation\n   * already, it will be canceled.\n   */\n  backoffAndRun(op: () => Promise<void>): void {\n    // Cancel any pending backoff operation.\n    this.cancel();\n\n    // First schedule using the current base (which may be 0 and should be\n    // honored as such).\n    const desiredDelayWithJitterMs = Math.floor(\n      this.currentBaseMs + this.jitterDelayMs()\n    );\n\n    // Guard against lastAttemptTime being in the future due to a clock change.\n    const delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);\n\n    // Guard against the backoff delay already being past.\n    const remainingDelayMs = Math.max(\n      0,\n      desiredDelayWithJitterMs - delaySoFarMs\n    );\n\n    if (remainingDelayMs > 0) {\n      logDebug(\n        LOG_TAG,\n        `Backing off for ${remainingDelayMs} ms ` +\n          `(base delay: ${this.currentBaseMs} ms, ` +\n          `delay with jitter: ${desiredDelayWithJitterMs} ms, ` +\n          `last attempt: ${delaySoFarMs} ms ago)`\n      );\n    }\n\n    this.timerPromise = this.queue.enqueueAfterDelay(\n      this.timerId,\n      remainingDelayMs,\n      () => {\n        this.lastAttemptTime = Date.now();\n        return op();\n      }\n    );\n\n    // Apply backoff factor to determine next delay and ensure it is within\n    // bounds.\n    this.currentBaseMs *= this.backoffFactor;\n    if (this.currentBaseMs < this.initialDelayMs) {\n      this.currentBaseMs = this.initialDelayMs;\n    }\n    if (this.currentBaseMs > this.maxDelayMs) {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n  }\n\n  skipBackoff(): void {\n    if (this.timerPromise !== null) {\n      this.timerPromise.skipDelay();\n      this.timerPromise = null;\n    }\n  }\n\n  cancel(): void {\n    if (this.timerPromise !== null) {\n      this.timerPromise.cancel();\n      this.timerPromise = null;\n    }\n  }\n\n  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n  private jitterDelayMs(): number {\n    return (Math.random() - 0.5) * this.currentBaseMs;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert, fail } from './assert';\nimport { Code, FirestoreError } from './error';\nimport { logDebug, logError } from './log';\nimport { Deferred } from './promise';\nimport { ExponentialBackoff } from '../remote/backoff';\nimport { PlatformSupport } from '../platform/platform';\nimport { isIndexedDbTransactionError } from '../local/simple_db';\n\nconst LOG_TAG = 'AsyncQueue';\n\n// Accept any return type from setTimeout().\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype TimerHandle = any;\n\n/**\n * Wellknown \"timer\" IDs used when scheduling delayed operations on the\n * AsyncQueue. These IDs can then be used from tests to check for the presence\n * of operations or to run them early.\n *\n * The string values are used when encoding these timer IDs in JSON spec tests.\n */\nexport const enum TimerId {\n  /** All can be used with runDelayedOperationsEarly() to run all timers. */\n  All = 'all',\n\n  /**\n   * The following 4 timers are used in persistent_stream.ts for the listen and\n   * write streams. The \"Idle\" timer is used to close the stream due to\n   * inactivity. The \"ConnectionBackoff\" timer is used to restart a stream once\n   * the appropriate backoff delay has elapsed.\n   */\n  ListenStreamIdle = 'listen_stream_idle',\n  ListenStreamConnectionBackoff = 'listen_stream_connection_backoff',\n  WriteStreamIdle = 'write_stream_idle',\n  WriteStreamConnectionBackoff = 'write_stream_connection_backoff',\n\n  /**\n   * A timer used in online_state_tracker.ts to transition from\n   * OnlineState.Unknown to Offline after a set timeout, rather than waiting\n   * indefinitely for success or failure.\n   */\n  OnlineStateTimeout = 'online_state_timeout',\n\n  /**\n   * A timer used to update the client metadata in IndexedDb, which is used\n   * to determine the primary leaseholder.\n   */\n  ClientMetadataRefresh = 'client_metadata_refresh',\n\n  /** A timer used to periodically attempt LRU Garbage collection */\n  LruGarbageCollection = 'lru_garbage_collection',\n\n  /**\n   * A timer used to retry transactions. Since there can be multiple concurrent\n   * transactions, multiple of these may be in the queue at a given time.\n   */\n  TransactionRetry = 'transaction_retry',\n\n  /**\n   * A timer used to retry operations scheduled via retryable AsyncQueue\n   * operations.\n   */\n  AsyncQueueRetry = 'async_queue_retry'\n}\n\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n *\n * Note: We implement `PromiseLike` instead of `Promise`, as the `Promise` type\n * in newer versions of TypeScript defines `finally`, which is not available in\n * IE.\n */\nexport class DelayedOperation<T extends unknown> implements PromiseLike<T> {\n  // handle for use with clearTimeout(), or null if the operation has been\n  // executed or canceled already.\n  private timerHandle: TimerHandle | null;\n\n  private readonly deferred = new Deferred<T>();\n\n  private constructor(\n    private readonly asyncQueue: AsyncQueue,\n    readonly timerId: TimerId,\n    readonly targetTimeMs: number,\n    private readonly op: () => Promise<T>,\n    private readonly removalCallback: (op: DelayedOperation<T>) => void\n  ) {\n    // It's normal for the deferred promise to be canceled (due to cancellation)\n    // and so we attach a dummy catch callback to avoid\n    // 'UnhandledPromiseRejectionWarning' log spam.\n    this.deferred.promise.catch(err => {});\n  }\n\n  /**\n   * Creates and returns a DelayedOperation that has been scheduled to be\n   * executed on the provided asyncQueue after the provided delayMs.\n   *\n   * @param asyncQueue The queue to schedule the operation on.\n   * @param id A Timer ID identifying the type of operation this is.\n   * @param delayMs The delay (ms) before the operation should be scheduled.\n   * @param op The operation to run.\n   * @param removalCallback A callback to be called synchronously once the\n   *   operation is executed or canceled, notifying the AsyncQueue to remove it\n   *   from its delayedOperations list.\n   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n   *   the DelayedOperation class public.\n   */\n  static createAndSchedule<R extends unknown>(\n    asyncQueue: AsyncQueue,\n    timerId: TimerId,\n    delayMs: number,\n    op: () => Promise<R>,\n    removalCallback: (op: DelayedOperation<R>) => void\n  ): DelayedOperation<R> {\n    const targetTime = Date.now() + delayMs;\n    const delayedOp = new DelayedOperation(\n      asyncQueue,\n      timerId,\n      targetTime,\n      op,\n      removalCallback\n    );\n    delayedOp.start(delayMs);\n    return delayedOp;\n  }\n\n  /**\n   * Starts the timer. This is called immediately after construction by\n   * createAndSchedule().\n   */\n  private start(delayMs: number): void {\n    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), delayMs);\n  }\n\n  /**\n   * Queues the operation to run immediately (if it hasn't already been run or\n   * canceled).\n   */\n  skipDelay(): void {\n    return this.handleDelayElapsed();\n  }\n\n  /**\n   * Cancels the operation if it hasn't already been executed or canceled. The\n   * promise will be rejected.\n   *\n   * As long as the operation has not yet been run, calling cancel() provides a\n   * guarantee that the operation will not be run.\n   */\n  cancel(reason?: string): void {\n    if (this.timerHandle !== null) {\n      this.clearTimeout();\n      this.deferred.reject(\n        new FirestoreError(\n          Code.CANCELLED,\n          'Operation cancelled' + (reason ? ': ' + reason : '')\n        )\n      );\n    }\n  }\n\n  then = this.deferred.promise.then.bind(this.deferred.promise);\n\n  private handleDelayElapsed(): void {\n    this.asyncQueue.enqueueAndForget(() => {\n      if (this.timerHandle !== null) {\n        this.clearTimeout();\n        return this.op().then(result => {\n          return this.deferred.resolve(result);\n        });\n      } else {\n        return Promise.resolve();\n      }\n    });\n  }\n\n  private clearTimeout(): void {\n    if (this.timerHandle !== null) {\n      this.removalCallback(this);\n      clearTimeout(this.timerHandle);\n      this.timerHandle = null;\n    }\n  }\n}\n\nexport class AsyncQueue {\n  // The last promise in the queue.\n  private tail: Promise<unknown> = Promise.resolve();\n\n  // The last retryable operation. Retryable operation are run in order and\n  // retried with backoff.\n  private retryableTail: Promise<void> = Promise.resolve();\n\n  // Is this AsyncQueue being shut down? Once it is set to true, it will not\n  // be changed again.\n  private _isShuttingDown: boolean = false;\n\n  // Operations scheduled to be queued in the future. Operations are\n  // automatically removed after they are run or canceled.\n  private delayedOperations: Array<DelayedOperation<unknown>> = [];\n\n  // visible for testing\n  failure: Error | null = null;\n\n  // Flag set while there's an outstanding AsyncQueue operation, used for\n  // assertion sanity-checks.\n  private operationInProgress = false;\n\n  // List of TimerIds to fast-forward delays for.\n  private timerIdsToSkip: TimerId[] = [];\n\n  // Backoff timer used to schedule retries for retryable operations\n  private backoff = new ExponentialBackoff(this, TimerId.AsyncQueueRetry);\n\n  // Visibility handler that triggers an immediate retry of all retryable\n  // operations. Meant to speed up recovery when we regain file system access\n  // after page comes into foreground.\n  private visibilityHandler = (): void => this.backoff.skipBackoff();\n\n  constructor() {\n    const window = PlatformSupport.getPlatform().window;\n    if (window && typeof window.addEventListener === 'function') {\n      window.addEventListener('visibilitychange', this.visibilityHandler);\n    }\n  }\n\n  // Is this AsyncQueue being shut down? If true, this instance will not enqueue\n  // any new operations, Promises from enqueue requests will not resolve.\n  get isShuttingDown(): boolean {\n    return this._isShuttingDown;\n  }\n\n  /**\n   * Adds a new operation to the queue without waiting for it to complete (i.e.\n   * we ignore the Promise result).\n   */\n  enqueueAndForget<T extends unknown>(op: () => Promise<T>): void {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.enqueue(op);\n  }\n\n  /**\n   * Regardless if the queue has initialized shutdown, adds a new operation to the\n   * queue without waiting for it to complete (i.e. we ignore the Promise result).\n   */\n  enqueueAndForgetEvenAfterShutdown<T extends unknown>(\n    op: () => Promise<T>\n  ): void {\n    this.verifyNotFailed();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.enqueueInternal(op);\n  }\n\n  /**\n   * Regardless if the queue has initialized shutdown, adds a new operation to the\n   * queue.\n   */\n  private enqueueEvenAfterShutdown<T extends unknown>(\n    op: () => Promise<T>\n  ): Promise<T> {\n    this.verifyNotFailed();\n    return this.enqueueInternal(op);\n  }\n\n  /**\n   * Adds a new operation to the queue and initialize the shut down of this queue.\n   * Returns a promise that will be resolved when the promise returned by the new\n   * operation is (with its value).\n   * Once this method is called, the only possible way to request running an operation\n   * is through `enqueueAndForgetEvenAfterShutdown`.\n   */\n  async enqueueAndInitiateShutdown(op: () => Promise<void>): Promise<void> {\n    this.verifyNotFailed();\n    if (!this._isShuttingDown) {\n      this._isShuttingDown = true;\n      const window = PlatformSupport.getPlatform().window;\n      if (window) {\n        window.removeEventListener('visibilitychange', this.visibilityHandler);\n      }\n      await this.enqueueEvenAfterShutdown(op);\n    }\n  }\n\n  /**\n   * Adds a new operation to the queue. Returns a promise that will be resolved\n   * when the promise returned by the new operation is (with its value).\n   */\n  enqueue<T extends unknown>(op: () => Promise<T>): Promise<T> {\n    this.verifyNotFailed();\n    if (this._isShuttingDown) {\n      // Return a Promise which never resolves.\n      return new Promise<T>(resolve => {});\n    }\n    return this.enqueueInternal(op);\n  }\n\n  /**\n   * Enqueue a retryable operation.\n   *\n   * A retryable operation is rescheduled with backoff if it fails with a\n   * IndexedDbTransactionError (the error type used by SimpleDb). All\n   * retryable operations are executed in order and only run if all prior\n   * operations were retried successfully.\n   */\n  enqueueRetryable(op: () => Promise<void>): void {\n    this.verifyNotFailed();\n\n    if (this._isShuttingDown) {\n      return;\n    }\n\n    this.retryableTail = this.retryableTail.then(() => {\n      const deferred = new Deferred<void>();\n      const retryingOp = async (): Promise<void> => {\n        try {\n          await op();\n          deferred.resolve();\n          this.backoff.reset();\n        } catch (e) {\n          if (isIndexedDbTransactionError(e)) {\n            logDebug(LOG_TAG, 'Operation failed with retryable error: ' + e);\n            this.backoff.backoffAndRun(retryingOp);\n          } else {\n            deferred.resolve();\n            throw e; // Failure will be handled by AsyncQueue\n          }\n        }\n      };\n      this.enqueueAndForget(retryingOp);\n      return deferred.promise;\n    });\n  }\n\n  private enqueueInternal<T extends unknown>(op: () => Promise<T>): Promise<T> {\n    const newTail = this.tail.then(() => {\n      this.operationInProgress = true;\n      return op()\n        .catch((error: FirestoreError) => {\n          this.failure = error;\n          this.operationInProgress = false;\n          const message = getMessageOrStack(error);\n          logError('INTERNAL UNHANDLED ERROR: ', message);\n\n          // Re-throw the error so that this.tail becomes a rejected Promise and\n          // all further attempts to chain (via .then) will just short-circuit\n          // and return the rejected Promise.\n          throw error;\n        })\n        .then(result => {\n          this.operationInProgress = false;\n          return result;\n        });\n    });\n    this.tail = newTail;\n    return newTail;\n  }\n\n  /**\n   * Schedules an operation to be queued on the AsyncQueue once the specified\n   * `delayMs` has elapsed. The returned DelayedOperation can be used to cancel\n   * or fast-forward the operation prior to its running.\n   */\n  enqueueAfterDelay<T extends unknown>(\n    timerId: TimerId,\n    delayMs: number,\n    op: () => Promise<T>\n  ): DelayedOperation<T> {\n    this.verifyNotFailed();\n\n    debugAssert(\n      delayMs >= 0,\n      `Attempted to schedule an operation with a negative delay of ${delayMs}`\n    );\n\n    // Fast-forward delays for timerIds that have been overriden.\n    if (this.timerIdsToSkip.indexOf(timerId) > -1) {\n      delayMs = 0;\n    }\n\n    const delayedOp = DelayedOperation.createAndSchedule<T>(\n      this,\n      timerId,\n      delayMs,\n      op,\n      removedOp =>\n        this.removeDelayedOperation(removedOp as DelayedOperation<unknown>)\n    );\n    this.delayedOperations.push(delayedOp as DelayedOperation<unknown>);\n    return delayedOp;\n  }\n\n  private verifyNotFailed(): void {\n    if (this.failure) {\n      fail('AsyncQueue is already failed: ' + getMessageOrStack(this.failure));\n    }\n  }\n\n  /**\n   * Verifies there's an operation currently in-progress on the AsyncQueue.\n   * Unfortunately we can't verify that the running code is in the promise chain\n   * of that operation, so this isn't a foolproof check, but it should be enough\n   * to catch some bugs.\n   */\n  verifyOperationInProgress(): void {\n    debugAssert(\n      this.operationInProgress,\n      'verifyOpInProgress() called when no op in progress on this queue.'\n    );\n  }\n\n  /**\n   * Waits until all currently queued tasks are finished executing. Delayed\n   * operations are not run.\n   */\n  async drain(): Promise<void> {\n    // Operations in the queue prior to draining may have enqueued additional\n    // operations. Keep draining the queue until the tail is no longer advanced,\n    // which indicates that no more new operations were enqueued and that all\n    // operations were executed.\n    let currentTail: Promise<unknown>;\n    do {\n      currentTail = this.tail;\n      await currentTail;\n    } while (currentTail !== this.tail);\n  }\n\n  /**\n   * For Tests: Determine if a delayed operation with a particular TimerId\n   * exists.\n   */\n  containsDelayedOperation(timerId: TimerId): boolean {\n    for (const op of this.delayedOperations) {\n      if (op.timerId === timerId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * For Tests: Runs some or all delayed operations early.\n   *\n   * @param lastTimerId Delayed operations up to and including this TimerId will\n   *  be drained. Pass TimerId.All to run all delayed operations.\n   * @returns a Promise that resolves once all operations have been run.\n   */\n  runAllDelayedOperationsUntil(lastTimerId: TimerId): Promise<void> {\n    // Note that draining may generate more delayed ops, so we do that first.\n    return this.drain().then(() => {\n      // Run ops in the same order they'd run if they ran naturally.\n      this.delayedOperations.sort((a, b) => a.targetTimeMs - b.targetTimeMs);\n\n      for (const op of this.delayedOperations) {\n        op.skipDelay();\n        if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {\n          break;\n        }\n      }\n\n      return this.drain();\n    });\n  }\n\n  /**\n   * For Tests: Skip all subsequent delays for a timer id.\n   */\n  skipDelaysForTimerId(timerId: TimerId): void {\n    this.timerIdsToSkip.push(timerId);\n  }\n\n  /** Called once a DelayedOperation is run or canceled. */\n  private removeDelayedOperation(op: DelayedOperation<unknown>): void {\n    // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n    const index = this.delayedOperations.indexOf(op);\n    debugAssert(index >= 0, 'Delayed operation not found.');\n    this.delayedOperations.splice(index, 1);\n  }\n}\n\n/**\n * Returns a FirestoreError that can be surfaced to the user if the provided\n * error is an IndexedDbTransactionError. Re-throws the error otherwise.\n */\nexport function wrapInUserErrorIfRecoverable(\n  e: Error,\n  msg: string\n): FirestoreError {\n  logError(LOG_TAG, `${msg}: ${e}`);\n  if (isIndexedDbTransactionError(e)) {\n    return new FirestoreError(Code.UNAVAILABLE, `${msg}: ${e}`);\n  } else {\n    throw e;\n  }\n}\n\n/**\n * Chrome includes Error.message in Error.stack. Other browsers do not.\n * This returns expected output of message + stack when available.\n * @param error Error or FirestoreError\n */\nfunction getMessageOrStack(error: Error): string {\n  let message = error.message || '';\n  if (error.stack) {\n    if (error.stack.includes(error.message)) {\n      message = error.stack;\n    } else {\n      message = error.message + '\\n' + error.stack;\n    }\n  }\n  return message;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CredentialsProvider, Token } from '../api/credentials';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetId } from '../core/types';\nimport { TargetData } from '../local/target_data';\nimport { Mutation, MutationResult } from '../model/mutation';\nimport * as api from '../protos/firestore_proto_api';\nimport { hardAssert, debugAssert } from '../util/assert';\nimport { AsyncQueue, DelayedOperation, TimerId } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { logError, logDebug } from '../util/log';\n\nimport { isNullOrUndefined } from '../util/types';\nimport { ExponentialBackoff } from './backoff';\nimport { Connection, Stream } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport { WatchChange } from './watch_change';\nimport { ByteString } from '../util/byte_string';\n\nconst LOG_TAG = 'PersistentStream';\n\n// The generated proto interfaces for these class are missing the database\n// field. So we add it here.\n// TODO(b/36015800): Remove this once the api generator is fixed.\ninterface ListenRequest extends api.ListenRequest {\n  database?: string;\n}\nexport interface WriteRequest extends api.WriteRequest {\n  database?: string;\n}\n/**\n * PersistentStream can be in one of 5 states (each described in detail below)\n * based on the following state transition diagram:\n *\n *          start() called             auth & connection succeeded\n * INITIAL ----------------> STARTING -----------------------------> OPEN\n *                             ^  |                                   |\n *                             |  |                    error occurred |\n *                             |  \\-----------------------------v-----/\n *                             |                                |\n *                    backoff  |                                |\n *                    elapsed  |              start() called    |\n *                             \\--- BACKOFF <---------------- ERROR\n *\n * [any state] --------------------------> INITIAL\n *               stop() called or\n *               idle timer expired\n */\nconst enum PersistentStreamState {\n  /**\n   * The streaming RPC is not yet running and there's no error condition.\n   * Calling start() will start the stream immediately without backoff.\n   * While in this state isStarted() will return false.\n   */\n  Initial,\n\n  /**\n   * The stream is starting, either waiting for an auth token or for the stream\n   * to successfully open. While in this state, isStarted() will return true but\n   * isOpen() will return false.\n   */\n  Starting,\n\n  /**\n   * The streaming RPC is up and running. Requests and responses can flow\n   * freely. Both isStarted() and isOpen() will return true.\n   */\n  Open,\n\n  /**\n   * The stream encountered an error. The next start attempt will back off.\n   * While in this state isStarted() will return false.\n   */\n  Error,\n\n  /**\n   * An in-between state after an error where the stream is waiting before\n   * re-starting. After waiting is complete, the stream will try to open.\n   * While in this state isStarted() will return true but isOpen() will return\n   * false.\n   */\n  Backoff\n}\n\n/**\n * Provides a common interface that is shared by the listeners for stream\n * events by the concrete implementation classes.\n */\nexport interface PersistentStreamListener {\n  /**\n   * Called after the stream was established and can accept outgoing\n   * messages\n   */\n  onOpen: () => Promise<void>;\n  /**\n   * Called after the stream has closed. If there was an error, the\n   * FirestoreError will be set.\n   */\n  onClose: (err?: FirestoreError) => Promise<void>;\n}\n\n/** The time a stream stays open after it is marked idle. */\nconst IDLE_TIMEOUT_MS = 60 * 1000;\n\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *   - Closing idle streams after 60 seconds of inactivity\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be start()ed before messages can\n * be sent and received. The PersistentStream will call the onOpen() function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a start() fail, PersistentStream will call the registered onClose()\n * listener with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nexport abstract class PersistentStream<\n  SendType,\n  ReceiveType,\n  ListenerType extends PersistentStreamListener\n> {\n  private state = PersistentStreamState.Initial;\n  /**\n   * A close count that's incremented every time the stream is closed; used by\n   * getCloseGuardedDispatcher() to invalidate callbacks that happen after\n   * close.\n   */\n  private closeCount = 0;\n\n  private idleTimer: DelayedOperation<void> | null = null;\n  private stream: Stream<SendType, ReceiveType> | null = null;\n\n  protected backoff: ExponentialBackoff;\n\n  constructor(\n    private queue: AsyncQueue,\n    connectionTimerId: TimerId,\n    private idleTimerId: TimerId,\n    protected connection: Connection,\n    private credentialsProvider: CredentialsProvider,\n    protected listener: ListenerType\n  ) {\n    this.backoff = new ExponentialBackoff(queue, connectionTimerId);\n  }\n\n  /**\n   * Returns true if start() has been called and no error has occurred. True\n   * indicates the stream is open or in the process of opening (which\n   * encompasses respecting backoff, getting auth tokens, and starting the\n   * actual RPC). Use isOpen() to determine if the stream is open and ready for\n   * outbound requests.\n   */\n  isStarted(): boolean {\n    return (\n      this.state === PersistentStreamState.Starting ||\n      this.state === PersistentStreamState.Open ||\n      this.state === PersistentStreamState.Backoff\n    );\n  }\n\n  /**\n   * Returns true if the underlying RPC is open (the onOpen() listener has been\n   * called) and the stream is ready for outbound requests.\n   */\n  isOpen(): boolean {\n    return this.state === PersistentStreamState.Open;\n  }\n\n  /**\n   * Starts the RPC. Only allowed if isStarted() returns false. The stream is\n   * not immediately ready for use: onOpen() will be invoked when the RPC is\n   * ready for outbound requests, at which point isOpen() will return true.\n   *\n   * When start returns, isStarted() will return true.\n   */\n  start(): void {\n    if (this.state === PersistentStreamState.Error) {\n      this.performBackoff();\n      return;\n    }\n\n    debugAssert(\n      this.state === PersistentStreamState.Initial,\n      'Already started'\n    );\n    this.auth();\n  }\n\n  /**\n   * Stops the RPC. This call is idempotent and allowed regardless of the\n   * current isStarted() state.\n   *\n   * When stop returns, isStarted() and isOpen() will both return false.\n   */\n  async stop(): Promise<void> {\n    if (this.isStarted()) {\n      await this.close(PersistentStreamState.Initial);\n    }\n  }\n\n  /**\n   * After an error the stream will usually back off on the next attempt to\n   * start it. If the error warrants an immediate restart of the stream, the\n   * sender can use this to indicate that the receiver should not back off.\n   *\n   * Each error will call the onClose() listener. That function can decide to\n   * inhibit backoff if required.\n   */\n  inhibitBackoff(): void {\n    debugAssert(\n      !this.isStarted(),\n      'Can only inhibit backoff in a stopped state'\n    );\n\n    this.state = PersistentStreamState.Initial;\n    this.backoff.reset();\n  }\n\n  /**\n   * Marks this stream as idle. If no further actions are performed on the\n   * stream for one minute, the stream will automatically close itself and\n   * notify the stream's onClose() handler with Status.OK. The stream will then\n   * be in a !isStarted() state, requiring the caller to start the stream again\n   * before further use.\n   *\n   * Only streams that are in state 'Open' can be marked idle, as all other\n   * states imply pending network operations.\n   */\n  markIdle(): void {\n    // Starts the idle time if we are in state 'Open' and are not yet already\n    // running a timer (in which case the previous idle timeout still applies).\n    if (this.isOpen() && this.idleTimer === null) {\n      this.idleTimer = this.queue.enqueueAfterDelay(\n        this.idleTimerId,\n        IDLE_TIMEOUT_MS,\n        () => this.handleIdleCloseTimer()\n      );\n    }\n  }\n\n  /** Sends a message to the underlying stream. */\n  protected sendRequest(msg: SendType): void {\n    this.cancelIdleCheck();\n    this.stream!.send(msg);\n  }\n\n  /** Called by the idle timer when the stream should close due to inactivity. */\n  private async handleIdleCloseTimer(): Promise<void> {\n    if (this.isOpen()) {\n      // When timing out an idle stream there's no reason to force the stream into backoff when\n      // it restarts so set the stream state to Initial instead of Error.\n      return this.close(PersistentStreamState.Initial);\n    }\n  }\n\n  /** Marks the stream as active again. */\n  private cancelIdleCheck(): void {\n    if (this.idleTimer) {\n      this.idleTimer.cancel();\n      this.idleTimer = null;\n    }\n  }\n\n  /**\n   * Closes the stream and cleans up as necessary:\n   *\n   * * closes the underlying GRPC stream;\n   * * calls the onClose handler with the given 'error';\n   * * sets internal stream state to 'finalState';\n   * * adjusts the backoff timer based on the error\n   *\n   * A new stream can be opened by calling start().\n   *\n   * @param finalState the intended state of the stream after closing.\n   * @param error the error the connection was closed with.\n   */\n  private async close(\n    finalState: PersistentStreamState,\n    error?: FirestoreError\n  ): Promise<void> {\n    debugAssert(this.isStarted(), 'Only started streams should be closed.');\n    debugAssert(\n      finalState === PersistentStreamState.Error || isNullOrUndefined(error),\n      \"Can't provide an error when not in an error state.\"\n    );\n\n    // Cancel any outstanding timers (they're guaranteed not to execute).\n    this.cancelIdleCheck();\n    this.backoff.cancel();\n\n    // Invalidates any stream-related callbacks (e.g. from auth or the\n    // underlying stream), guaranteeing they won't execute.\n    this.closeCount++;\n\n    if (finalState !== PersistentStreamState.Error) {\n      // If this is an intentional close ensure we don't delay our next connection attempt.\n      this.backoff.reset();\n    } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n      // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n      logError(error.toString());\n      logError(\n        'Using maximum backoff delay to prevent overloading the backend.'\n      );\n      this.backoff.resetToMax();\n    } else if (error && error.code === Code.UNAUTHENTICATED) {\n      // \"unauthenticated\" error means the token was rejected. Try force refreshing it in case it\n      // just expired.\n      this.credentialsProvider.invalidateToken();\n    }\n\n    // Clean up the underlying stream because we are no longer interested in events.\n    if (this.stream !== null) {\n      this.tearDown();\n      this.stream.close();\n      this.stream = null;\n    }\n\n    // This state must be assigned before calling onClose() to allow the callback to\n    // inhibit backoff or otherwise manipulate the state in its non-started state.\n    this.state = finalState;\n\n    // Notify the listener that the stream closed.\n    await this.listener.onClose(error);\n  }\n\n  /**\n   * Can be overridden to perform additional cleanup before the stream is closed.\n   * Calling super.tearDown() is not required.\n   */\n  protected tearDown(): void {}\n\n  /**\n   * Used by subclasses to start the concrete RPC and return the underlying\n   * connection stream.\n   */\n  protected abstract startRpc(\n    token: Token | null\n  ): Stream<SendType, ReceiveType>;\n\n  /**\n   * Called after the stream has received a message. The function will be\n   * called on the right queue and must return a Promise.\n   * @param message The message received from the stream.\n   */\n  protected abstract onMessage(message: ReceiveType): Promise<void>;\n\n  private auth(): void {\n    debugAssert(\n      this.state === PersistentStreamState.Initial,\n      'Must be in initial state to auth'\n    );\n\n    this.state = PersistentStreamState.Starting;\n\n    const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n\n    // TODO(mikelehen): Just use dispatchIfNotClosed, but see TODO below.\n    const closeCount = this.closeCount;\n\n    this.credentialsProvider.getToken().then(\n      token => {\n        // Stream can be stopped while waiting for authentication.\n        // TODO(mikelehen): We really should just use dispatchIfNotClosed\n        // and let this dispatch onto the queue, but that opened a spec test can\n        // of worms that I don't want to deal with in this PR.\n        if (this.closeCount === closeCount) {\n          // Normally we'd have to schedule the callback on the AsyncQueue.\n          // However, the following calls are safe to be called outside the\n          // AsyncQueue since they don't chain asynchronous calls\n          this.startStream(token);\n        }\n      },\n      (error: Error) => {\n        dispatchIfNotClosed(() => {\n          const rpcError = new FirestoreError(\n            Code.UNKNOWN,\n            'Fetching auth token failed: ' + error.message\n          );\n          return this.handleStreamClose(rpcError);\n        });\n      }\n    );\n  }\n\n  private startStream(token: Token | null): void {\n    debugAssert(\n      this.state === PersistentStreamState.Starting,\n      'Trying to start stream in a non-starting state'\n    );\n\n    const dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);\n\n    this.stream = this.startRpc(token);\n    this.stream.onOpen(() => {\n      dispatchIfNotClosed(() => {\n        debugAssert(\n          this.state === PersistentStreamState.Starting,\n          'Expected stream to be in state Starting, but was ' + this.state\n        );\n        this.state = PersistentStreamState.Open;\n        return this.listener!.onOpen();\n      });\n    });\n    this.stream.onClose((error?: FirestoreError) => {\n      dispatchIfNotClosed(() => {\n        return this.handleStreamClose(error);\n      });\n    });\n    this.stream.onMessage((msg: ReceiveType) => {\n      dispatchIfNotClosed(() => {\n        return this.onMessage(msg);\n      });\n    });\n  }\n\n  private performBackoff(): void {\n    debugAssert(\n      this.state === PersistentStreamState.Error,\n      'Should only perform backoff when in Error state'\n    );\n    this.state = PersistentStreamState.Backoff;\n\n    this.backoff.backoffAndRun(async () => {\n      debugAssert(\n        this.state === PersistentStreamState.Backoff,\n        'Backoff elapsed but state is now: ' + this.state\n      );\n\n      this.state = PersistentStreamState.Initial;\n      this.start();\n      debugAssert(this.isStarted(), 'PersistentStream should have started');\n    });\n  }\n\n  // Visible for tests\n  handleStreamClose(error?: FirestoreError): Promise<void> {\n    debugAssert(\n      this.isStarted(),\n      \"Can't handle server close on non-started stream\"\n    );\n    logDebug(LOG_TAG, `close with error: ${error}`);\n\n    this.stream = null;\n\n    // In theory the stream could close cleanly, however, in our current model\n    // we never expect this to happen because if we stop a stream ourselves,\n    // this callback will never be called. To prevent cases where we retry\n    // without a backoff accidentally, we set the stream to error in all cases.\n    return this.close(PersistentStreamState.Error, error);\n  }\n\n  /**\n   * Returns a \"dispatcher\" function that dispatches operations onto the\n   * AsyncQueue but only runs them if closeCount remains unchanged. This allows\n   * us to turn auth / stream callbacks into no-ops if the stream is closed /\n   * re-opened, etc.\n   */\n  private getCloseGuardedDispatcher(\n    startCloseCount: number\n  ): (fn: () => Promise<void>) => void {\n    return (fn: () => Promise<void>): void => {\n      this.queue.enqueueAndForget(() => {\n        if (this.closeCount === startCloseCount) {\n          return fn();\n        } else {\n          logDebug(\n            LOG_TAG,\n            'stream callback skipped by getCloseGuardedDispatcher.'\n          );\n          return Promise.resolve();\n        }\n      });\n    };\n  }\n}\n\n/** Listener for the PersistentWatchStream */\nexport interface WatchStreamListener extends PersistentStreamListener {\n  /**\n   * Called on a watchChange. The snapshot parameter will be MIN if the watch\n   * change did not have a snapshot associated with it.\n   */\n  onWatchChange: (\n    watchChange: WatchChange,\n    snapshot: SnapshotVersion\n  ) => Promise<void>;\n}\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the onOpen() listener, any number of\n * listen() and unlisten() calls can be made to control what changes will be\n * sent from the server for ListenResponses.\n */\nexport class PersistentListenStream extends PersistentStream<\n  api.ListenRequest,\n  api.ListenResponse,\n  WatchStreamListener\n> {\n  constructor(\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    listener: WatchStreamListener\n  ) {\n    super(\n      queue,\n      TimerId.ListenStreamConnectionBackoff,\n      TimerId.ListenStreamIdle,\n      connection,\n      credentials,\n      listener\n    );\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.ListenRequest, api.ListenResponse> {\n    return this.connection.openStream<api.ListenRequest, api.ListenResponse>(\n      'Listen',\n      token\n    );\n  }\n\n  protected onMessage(watchChangeProto: api.ListenResponse): Promise<void> {\n    // A successful response means the stream is healthy\n    this.backoff.reset();\n\n    const watchChange = this.serializer.fromWatchChange(watchChangeProto);\n    const snapshot = this.serializer.versionFromListenResponse(\n      watchChangeProto\n    );\n    return this.listener!.onWatchChange(watchChange, snapshot);\n  }\n\n  /**\n   * Registers interest in the results of the given target. If the target\n   * includes a resumeToken it will be included in the request. Results that\n   * affect the target will be streamed back as WatchChange messages that\n   * reference the targetId.\n   */\n  watch(targetData: TargetData): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.addTarget = this.serializer.toTarget(targetData);\n\n    const labels = this.serializer.toListenRequestLabels(targetData);\n    if (labels) {\n      request.labels = labels;\n    }\n\n    this.sendRequest(request);\n  }\n\n  /**\n   * Unregisters interest in the results of the target associated with the\n   * given targetId.\n   */\n  unwatch(targetId: TargetId): void {\n    const request: ListenRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    request.removeTarget = targetId;\n    this.sendRequest(request);\n  }\n}\n\n/** Listener for the PersistentWriteStream */\nexport interface WriteStreamListener extends PersistentStreamListener {\n  /**\n   * Called by the PersistentWriteStream upon a successful handshake response\n   * from the server, which is the receiver's cue to send any pending writes.\n   */\n  onHandshakeComplete: () => Promise<void>;\n\n  /**\n   * Called by the PersistentWriteStream upon receiving a StreamingWriteResponse\n   * from the server that contains a mutation result.\n   */\n  onMutationResult: (\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ) => Promise<void>;\n}\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nexport class PersistentWriteStream extends PersistentStream<\n  api.WriteRequest,\n  api.WriteResponse,\n  WriteStreamListener\n> {\n  private handshakeComplete_ = false;\n\n  constructor(\n    queue: AsyncQueue,\n    connection: Connection,\n    credentials: CredentialsProvider,\n    private serializer: JsonProtoSerializer,\n    listener: WriteStreamListener\n  ) {\n    super(\n      queue,\n      TimerId.WriteStreamConnectionBackoff,\n      TimerId.WriteStreamIdle,\n      connection,\n      credentials,\n      listener\n    );\n  }\n\n  /**\n   * The last received stream token from the server, used to acknowledge which\n   * responses the client has processed. Stream tokens are opaque checkpoint\n   * markers whose only real value is their inclusion in the next request.\n   *\n   * PersistentWriteStream manages propagating this value from responses to the\n   * next request.\n   */\n  private lastStreamToken: ByteString = ByteString.EMPTY_BYTE_STRING;\n\n  /**\n   * Tracks whether or not a handshake has been successfully exchanged and\n   * the stream is ready to accept mutations.\n   */\n  get handshakeComplete(): boolean {\n    return this.handshakeComplete_;\n  }\n\n  // Override of PersistentStream.start\n  start(): void {\n    this.handshakeComplete_ = false;\n    this.lastStreamToken = ByteString.EMPTY_BYTE_STRING;\n    super.start();\n  }\n\n  protected tearDown(): void {\n    if (this.handshakeComplete_) {\n      this.writeMutations([]);\n    }\n  }\n\n  protected startRpc(\n    token: Token | null\n  ): Stream<api.WriteRequest, api.WriteResponse> {\n    return this.connection.openStream<api.WriteRequest, api.WriteResponse>(\n      'Write',\n      token\n    );\n  }\n\n  protected onMessage(responseProto: api.WriteResponse): Promise<void> {\n    // Always capture the last stream token.\n    hardAssert(\n      !!responseProto.streamToken,\n      'Got a write response without a stream token'\n    );\n    this.lastStreamToken = this.serializer.fromBytes(responseProto.streamToken);\n\n    if (!this.handshakeComplete_) {\n      // The first response is always the handshake response\n      hardAssert(\n        !responseProto.writeResults || responseProto.writeResults.length === 0,\n        'Got mutation results for handshake'\n      );\n      this.handshakeComplete_ = true;\n      return this.listener!.onHandshakeComplete();\n    } else {\n      // A successful first write response means the stream is healthy,\n      // Note, that we could consider a successful handshake healthy, however,\n      // the write itself might be causing an error we want to back off from.\n      this.backoff.reset();\n\n      const results = this.serializer.fromWriteResults(\n        responseProto.writeResults,\n        responseProto.commitTime\n      );\n      const commitVersion = this.serializer.fromVersion(\n        responseProto.commitTime!\n      );\n      return this.listener!.onMutationResult(commitVersion, results);\n    }\n  }\n\n  /**\n   * Sends an initial streamToken to the server, performing the handshake\n   * required to make the StreamingWrite RPC work. Subsequent\n   * calls should wait until onHandshakeComplete was called.\n   */\n  writeHandshake(): void {\n    debugAssert(this.isOpen(), 'Writing handshake requires an opened stream');\n    debugAssert(!this.handshakeComplete_, 'Handshake already completed');\n    debugAssert(\n      this.lastStreamToken.isEqual(ByteString.EMPTY_BYTE_STRING),\n      'Stream token should be empty during handshake'\n    );\n    // TODO(dimond): Support stream resumption. We intentionally do not set the\n    // stream token on the handshake, ignoring any stream token we might have.\n    const request: WriteRequest = {};\n    request.database = this.serializer.encodedDatabaseId;\n    this.sendRequest(request);\n  }\n\n  /** Sends a group of mutations to the Firestore backend to apply. */\n  writeMutations(mutations: Mutation[]): void {\n    debugAssert(this.isOpen(), 'Writing mutations requires an opened stream');\n    debugAssert(\n      this.handshakeComplete_,\n      'Handshake must be complete before writing mutations'\n    );\n    debugAssert(\n      this.lastStreamToken.approximateByteSize() > 0,\n      'Trying to write mutation without a token'\n    );\n\n    const request: WriteRequest = {\n      streamToken: this.serializer.toBytes(this.lastStreamToken),\n      writes: mutations.map(mutation => this.serializer.toMutation(mutation))\n    };\n\n    this.sendRequest(request);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CredentialsProvider } from '../api/credentials';\nimport { MaybeDocument, Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport * as api from '../protos/firestore_proto_api';\nimport { debugCast, hardAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { Connection } from './connection';\nimport { JsonProtoSerializer } from './serializer';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream,\n  WatchStreamListener,\n  WriteStreamListener\n} from './persistent_stream';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Query } from '../core/query';\n\n/**\n * Datastore and its related methods are a wrapper around the external Google\n * Cloud Datastore grpc API, which provides an interface that is more convenient\n * for the rest of the client SDK architecture to consume.\n */\nexport class Datastore {\n  // Make sure that the structural type of `Datastore` is unique.\n  // See https://github.com/microsoft/TypeScript/issues/5451\n  private _ = undefined;\n}\n\n/**\n * An implementation of Datastore that exposes additional state for internal\n * consumption.\n */\nclass DatastoreImpl extends Datastore {\n  terminated = false;\n\n  constructor(\n    public readonly connection: Connection,\n    public readonly credentials: CredentialsProvider,\n    public readonly serializer: JsonProtoSerializer\n  ) {\n    super();\n  }\n\n  private verifyNotTerminated(): void {\n    if (this.terminated) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'The client has already been terminated.'\n      );\n    }\n  }\n\n  /** Gets an auth token and invokes the provided RPC. */\n  invokeRPC<Req, Resp>(rpcName: string, request: Req): Promise<Resp> {\n    this.verifyNotTerminated();\n    return this.credentials\n      .getToken()\n      .then(token => {\n        return this.connection.invokeRPC<Req, Resp>(rpcName, request, token);\n      })\n      .catch((error: FirestoreError) => {\n        if (error.code === Code.UNAUTHENTICATED) {\n          this.credentials.invalidateToken();\n        }\n        throw error;\n      });\n  }\n\n  /** Gets an auth token and invokes the provided RPC with streamed results. */\n  invokeStreamingRPC<Req, Resp>(\n    rpcName: string,\n    request: Req\n  ): Promise<Resp[]> {\n    this.verifyNotTerminated();\n    return this.credentials\n      .getToken()\n      .then(token => {\n        return this.connection.invokeStreamingRPC<Req, Resp>(\n          rpcName,\n          request,\n          token\n        );\n      })\n      .catch((error: FirestoreError) => {\n        if (error.code === Code.UNAUTHENTICATED) {\n          this.credentials.invalidateToken();\n        }\n        throw error;\n      });\n  }\n}\n\nexport function newDatastore(\n  connection: Connection,\n  credentials: CredentialsProvider,\n  serializer: JsonProtoSerializer\n): Datastore {\n  return new DatastoreImpl(connection, credentials, serializer);\n}\n\nexport async function invokeCommitRpc(\n  datastore: Datastore,\n  mutations: Mutation[]\n): Promise<void> {\n  const datastoreImpl = debugCast(datastore, DatastoreImpl);\n  const params = {\n    database: datastoreImpl.serializer.encodedDatabaseId,\n    writes: mutations.map(m => datastoreImpl.serializer.toMutation(m))\n  };\n  await datastoreImpl.invokeRPC('Commit', params);\n}\n\nexport async function invokeBatchGetDocumentsRpc(\n  datastore: Datastore,\n  keys: DocumentKey[]\n): Promise<MaybeDocument[]> {\n  const datastoreImpl = debugCast(datastore, DatastoreImpl);\n  const params = {\n    database: datastoreImpl.serializer.encodedDatabaseId,\n    documents: keys.map(k => datastoreImpl.serializer.toName(k))\n  };\n  const response = await datastoreImpl.invokeStreamingRPC<\n    api.BatchGetDocumentsRequest,\n    api.BatchGetDocumentsResponse\n  >('BatchGetDocuments', params);\n\n  const docs = new Map<string, MaybeDocument>();\n  response.forEach(proto => {\n    const doc = datastoreImpl.serializer.fromMaybeDocument(proto);\n    docs.set(doc.key.toString(), doc);\n  });\n  const result: MaybeDocument[] = [];\n  keys.forEach(key => {\n    const doc = docs.get(key.toString());\n    hardAssert(!!doc, 'Missing entity in write response for ' + key);\n    result.push(doc);\n  });\n  return result;\n}\n\nexport async function invokeRunQueryRpc(\n  datastore: Datastore,\n  query: Query\n): Promise<Document[]> {\n  const datastoreImpl = debugCast(datastore, DatastoreImpl);\n  const { structuredQuery, parent } = datastoreImpl.serializer.toQueryTarget(\n    query.toTarget()\n  );\n  const params = {\n    database: datastoreImpl.serializer.encodedDatabaseId,\n    parent,\n    structuredQuery\n  };\n\n  const response = await datastoreImpl.invokeStreamingRPC<\n    api.RunQueryRequest,\n    api.RunQueryResponse\n  >('RunQuery', params);\n\n  return (\n    response\n      // Omit RunQueryResponses that only contain readTimes.\n      .filter(proto => !!proto.document)\n      .map(proto => datastoreImpl.serializer.fromDocument(proto.document!))\n  );\n}\n\nexport function newPersistentWriteStream(\n  datastore: Datastore,\n  queue: AsyncQueue,\n  listener: WriteStreamListener\n): PersistentWriteStream {\n  const datastoreImpl = debugCast(datastore, DatastoreImpl);\n  return new PersistentWriteStream(\n    queue,\n    datastoreImpl.connection,\n    datastoreImpl.credentials,\n    datastoreImpl.serializer,\n    listener\n  );\n}\n\nexport function newPersistentWatchStream(\n  datastore: Datastore,\n  queue: AsyncQueue,\n  listener: WatchStreamListener\n): PersistentListenStream {\n  const datastoreImpl = debugCast(datastore, DatastoreImpl);\n  return new PersistentListenStream(\n    queue,\n    datastoreImpl.connection,\n    datastoreImpl.credentials,\n    datastoreImpl.serializer,\n    listener\n  );\n}\n\nexport function terminateDatastore(datastore: Datastore): void {\n  const datastoreImpl = debugCast(datastore, DatastoreImpl);\n  datastoreImpl.terminated = true;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParsedSetData, ParsedUpdateData } from '../api/user_data_reader';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\n\nimport { DocumentKey } from '../model/document_key';\nimport {\n  DeleteMutation,\n  Mutation,\n  Precondition,\n  VerifyMutation\n} from '../model/mutation';\nimport {\n  Datastore,\n  invokeBatchGetDocumentsRpc,\n  invokeCommitRpc\n} from '../remote/datastore';\nimport { fail, debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { SnapshotVersion } from './snapshot_version';\nimport { ResourcePath } from '../model/path';\n\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nexport class Transaction {\n  // The version of each document that was read during this transaction.\n  private readVersions = new Map</* path */ string, SnapshotVersion>();\n  private mutations: Mutation[] = [];\n  private committed = false;\n\n  /**\n   * A deferred usage error that occurred previously in this transaction that\n   * will cause the transaction to fail once it actually commits.\n   */\n  private lastWriteError: FirestoreError | null = null;\n\n  /**\n   * Set of documents that have been written in the transaction.\n   *\n   * When there's more than one write to the same key in a transaction, any\n   * writes after the first are handled differently.\n   */\n  private writtenDocs: Set<DocumentKey> = new Set();\n\n  constructor(private datastore: Datastore) {}\n\n  async lookup(keys: DocumentKey[]): Promise<MaybeDocument[]> {\n    this.ensureCommitNotCalled();\n\n    if (this.mutations.length > 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Firestore transactions require all reads to be executed before all writes.'\n      );\n    }\n    const docs = await invokeBatchGetDocumentsRpc(this.datastore, keys);\n    docs.forEach(doc => {\n      if (doc instanceof NoDocument || doc instanceof Document) {\n        this.recordVersion(doc);\n      } else {\n        fail('Document in a transaction was a ' + doc.constructor.name);\n      }\n    });\n    return docs;\n  }\n\n  set(key: DocumentKey, data: ParsedSetData): void {\n    this.write(data.toMutations(key, this.precondition(key)));\n    this.writtenDocs.add(key);\n  }\n\n  update(key: DocumentKey, data: ParsedUpdateData): void {\n    try {\n      this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n    } catch (e) {\n      this.lastWriteError = e;\n    }\n    this.writtenDocs.add(key);\n  }\n\n  delete(key: DocumentKey): void {\n    this.write([new DeleteMutation(key, this.precondition(key))]);\n    this.writtenDocs.add(key);\n  }\n\n  async commit(): Promise<void> {\n    this.ensureCommitNotCalled();\n\n    if (this.lastWriteError) {\n      throw this.lastWriteError;\n    }\n    const unwritten = this.readVersions;\n    // For each mutation, note that the doc was written.\n    this.mutations.forEach(mutation => {\n      unwritten.delete(mutation.key.toString());\n    });\n    // For each document that was read but not written to, we want to perform\n    // a `verify` operation.\n    unwritten.forEach((_, path) => {\n      const key = new DocumentKey(ResourcePath.fromString(path));\n      this.mutations.push(new VerifyMutation(key, this.precondition(key)));\n    });\n    await invokeCommitRpc(this.datastore, this.mutations);\n    this.committed = true;\n  }\n\n  private recordVersion(doc: MaybeDocument): void {\n    let docVersion: SnapshotVersion;\n\n    if (doc instanceof Document) {\n      docVersion = doc.version;\n    } else if (doc instanceof NoDocument) {\n      // For deleted docs, we must use baseVersion 0 when we overwrite them.\n      docVersion = SnapshotVersion.min();\n    } else {\n      throw fail('Document in a transaction was a ' + doc.constructor.name);\n    }\n\n    const existingVersion = this.readVersions.get(doc.key.toString());\n    if (existingVersion) {\n      if (!docVersion.isEqual(existingVersion)) {\n        // This transaction will fail no matter what.\n        throw new FirestoreError(\n          Code.ABORTED,\n          'Document version changed between two reads.'\n        );\n      }\n    } else {\n      this.readVersions.set(doc.key.toString(), docVersion);\n    }\n  }\n\n  /**\n   * Returns the version of this document when it was read in this transaction,\n   * as a precondition, or no precondition if it was not read.\n   */\n  private precondition(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key.toString());\n    if (!this.writtenDocs.has(key) && version) {\n      return Precondition.updateTime(version);\n    } else {\n      return Precondition.none();\n    }\n  }\n\n  /**\n   * Returns the precondition for a document if the operation is an update.\n   */\n  private preconditionForUpdate(key: DocumentKey): Precondition {\n    const version = this.readVersions.get(key.toString());\n    // The first time a document is written, we want to take into account the\n    // read time and existence\n    if (!this.writtenDocs.has(key) && version) {\n      if (version.isEqual(SnapshotVersion.min())) {\n        // The document doesn't exist, so fail the transaction.\n\n        // This has to be validated locally because you can't send a\n        // precondition that a document does not exist without changing the\n        // semantics of the backend write to be an insert. This is the reverse\n        // of what we want, since we want to assert that the document doesn't\n        // exist but then send the update and have it fail. Since we can't\n        // express that to the backend, we have to validate locally.\n\n        // Note: this can change once we can send separate verify writes in the\n        // transaction.\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          \"Can't update a document that doesn't exist.\"\n        );\n      }\n      // Document exists, base precondition on document update time.\n      return Precondition.updateTime(version);\n    } else {\n      // Document was not read, so we just use the preconditions for a blind\n      // update.\n      return Precondition.exists(true);\n    }\n  }\n\n  private write(mutations: Mutation[]): void {\n    this.ensureCommitNotCalled();\n    this.mutations = this.mutations.concat(mutations);\n  }\n\n  private ensureCommitNotCalled(): void {\n    debugAssert(\n      !this.committed,\n      'A transaction object cannot be used after its update callback has been invoked.'\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { fail } from '../util/assert';\nimport { Code } from '../util/error';\nimport { logError } from '../util/log';\n\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers or change this into a const enum.\n */\nenum RpcCode {\n  OK = 0,\n  CANCELLED = 1,\n  UNKNOWN = 2,\n  INVALID_ARGUMENT = 3,\n  DEADLINE_EXCEEDED = 4,\n  NOT_FOUND = 5,\n  ALREADY_EXISTS = 6,\n  PERMISSION_DENIED = 7,\n  UNAUTHENTICATED = 16,\n  RESOURCE_EXHAUSTED = 8,\n  FAILED_PRECONDITION = 9,\n  ABORTED = 10,\n  OUT_OF_RANGE = 11,\n  UNIMPLEMENTED = 12,\n  INTERNAL = 13,\n  UNAVAILABLE = 14,\n  DATA_LOSS = 15\n}\n\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a non-write operation.\n *\n * See isPermanentWriteError for classifying write errors.\n */\nexport function isPermanentError(code: Code): boolean {\n  switch (code) {\n    case Code.OK:\n      return fail('Treated status OK as error');\n    case Code.CANCELLED:\n    case Code.UNKNOWN:\n    case Code.DEADLINE_EXCEEDED:\n    case Code.RESOURCE_EXHAUSTED:\n    case Code.INTERNAL:\n    case Code.UNAVAILABLE:\n    // Unauthenticated means something went wrong with our token and we need\n    // to retry with new credentials which will happen automatically.\n    case Code.UNAUTHENTICATED:\n      return false;\n    case Code.INVALID_ARGUMENT:\n    case Code.NOT_FOUND:\n    case Code.ALREADY_EXISTS:\n    case Code.PERMISSION_DENIED:\n    case Code.FAILED_PRECONDITION:\n    // Aborted might be retried in some scenarios, but that is dependant on\n    // the context and should handled individually by the calling code.\n    // See https://cloud.google.com/apis/design/errors.\n    case Code.ABORTED:\n    case Code.OUT_OF_RANGE:\n    case Code.UNIMPLEMENTED:\n    case Code.DATA_LOSS:\n      return true;\n    default:\n      return fail('Unknown status code: ' + code);\n  }\n}\n\n/**\n * Determines whether an error code represents a permanent error when received\n * in response to a write operation.\n *\n * Write operations must be handled specially because as of b/119437764, ABORTED\n * errors on the write stream should be retried too (even though ABORTED errors\n * are not generally retryable).\n *\n * Note that during the initial handshake on the write stream an ABORTED error\n * signals that we should discard our stream token (i.e. it is permanent). This\n * means a handshake error should be classified with isPermanentError, above.\n */\nexport function isPermanentWriteError(code: Code): boolean {\n  return isPermanentError(code) && code !== Code.ABORTED;\n}\n\n/**\n * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.\n *\n * @returns The Code equivalent to the given status string or undefined if\n *     there is no match.\n */\nexport function mapCodeFromRpcStatus(status: string): Code | undefined {\n  // lookup by string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const code: RpcCode = RpcCode[status as any] as any;\n  if (code === undefined) {\n    return undefined;\n  }\n\n  return mapCodeFromRpcCode(code);\n}\n\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nexport function mapCodeFromRpcCode(code: number | undefined): Code {\n  if (code === undefined) {\n    // This shouldn't normally happen, but in certain error cases (like trying\n    // to send invalid proto messages) we may get an error with no GRPC code.\n    logError('GRPC error has no .code');\n    return Code.UNKNOWN;\n  }\n\n  switch (code) {\n    case RpcCode.OK:\n      return Code.OK;\n    case RpcCode.CANCELLED:\n      return Code.CANCELLED;\n    case RpcCode.UNKNOWN:\n      return Code.UNKNOWN;\n    case RpcCode.DEADLINE_EXCEEDED:\n      return Code.DEADLINE_EXCEEDED;\n    case RpcCode.RESOURCE_EXHAUSTED:\n      return Code.RESOURCE_EXHAUSTED;\n    case RpcCode.INTERNAL:\n      return Code.INTERNAL;\n    case RpcCode.UNAVAILABLE:\n      return Code.UNAVAILABLE;\n    case RpcCode.UNAUTHENTICATED:\n      return Code.UNAUTHENTICATED;\n    case RpcCode.INVALID_ARGUMENT:\n      return Code.INVALID_ARGUMENT;\n    case RpcCode.NOT_FOUND:\n      return Code.NOT_FOUND;\n    case RpcCode.ALREADY_EXISTS:\n      return Code.ALREADY_EXISTS;\n    case RpcCode.PERMISSION_DENIED:\n      return Code.PERMISSION_DENIED;\n    case RpcCode.FAILED_PRECONDITION:\n      return Code.FAILED_PRECONDITION;\n    case RpcCode.ABORTED:\n      return Code.ABORTED;\n    case RpcCode.OUT_OF_RANGE:\n      return Code.OUT_OF_RANGE;\n    case RpcCode.UNIMPLEMENTED:\n      return Code.UNIMPLEMENTED;\n    case RpcCode.DATA_LOSS:\n      return Code.DATA_LOSS;\n    default:\n      return fail('Unknown status code: ' + code);\n  }\n}\n\n/**\n * Maps an RPC code from a Code. This is the reverse operation from\n * mapCodeFromRpcCode and should really only be used in tests.\n */\nexport function mapRpcCodeFromCode(code: Code | undefined): number {\n  if (code === undefined) {\n    return RpcCode.OK;\n  }\n\n  switch (code) {\n    case Code.OK:\n      return RpcCode.OK;\n    case Code.CANCELLED:\n      return RpcCode.CANCELLED;\n    case Code.UNKNOWN:\n      return RpcCode.UNKNOWN;\n    case Code.DEADLINE_EXCEEDED:\n      return RpcCode.DEADLINE_EXCEEDED;\n    case Code.RESOURCE_EXHAUSTED:\n      return RpcCode.RESOURCE_EXHAUSTED;\n    case Code.INTERNAL:\n      return RpcCode.INTERNAL;\n    case Code.UNAVAILABLE:\n      return RpcCode.UNAVAILABLE;\n    case Code.UNAUTHENTICATED:\n      return RpcCode.UNAUTHENTICATED;\n    case Code.INVALID_ARGUMENT:\n      return RpcCode.INVALID_ARGUMENT;\n    case Code.NOT_FOUND:\n      return RpcCode.NOT_FOUND;\n    case Code.ALREADY_EXISTS:\n      return RpcCode.ALREADY_EXISTS;\n    case Code.PERMISSION_DENIED:\n      return RpcCode.PERMISSION_DENIED;\n    case Code.FAILED_PRECONDITION:\n      return RpcCode.FAILED_PRECONDITION;\n    case Code.ABORTED:\n      return RpcCode.ABORTED;\n    case Code.OUT_OF_RANGE:\n      return RpcCode.OUT_OF_RANGE;\n    case Code.UNIMPLEMENTED:\n      return RpcCode.UNIMPLEMENTED;\n    case Code.DATA_LOSS:\n      return RpcCode.DATA_LOSS;\n    default:\n      return fail('Unknown status code: ' + code);\n  }\n}\n\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nexport function mapCodeFromHttpStatus(status: number): Code {\n  // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n  // status codes but the mapping is not bijective. In each case of ambiguity\n  // this function chooses a primary error.\n  //\n  // [1]\n  // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n  switch (status) {\n    case 200: // OK\n      return Code.OK;\n\n    case 400: // Bad Request\n      return Code.INVALID_ARGUMENT;\n    // Other possibilities based on the forward mapping\n    // return Code.FAILED_PRECONDITION;\n    // return Code.OUT_OF_RANGE;\n\n    case 401: // Unauthorized\n      return Code.UNAUTHENTICATED;\n\n    case 403: // Forbidden\n      return Code.PERMISSION_DENIED;\n\n    case 404: // Not Found\n      return Code.NOT_FOUND;\n\n    case 409: // Conflict\n      return Code.ABORTED;\n    // Other possibilities:\n    // return Code.ALREADY_EXISTS;\n\n    case 416: // Range Not Satisfiable\n      return Code.OUT_OF_RANGE;\n\n    case 429: // Too Many Requests\n      return Code.RESOURCE_EXHAUSTED;\n\n    case 499: // Client Closed Request\n      return Code.CANCELLED;\n\n    case 500: // Internal Server Error\n      return Code.UNKNOWN;\n    // Other possibilities:\n    // return Code.INTERNAL;\n    // return Code.DATA_LOSS;\n\n    case 501: // Unimplemented\n      return Code.UNIMPLEMENTED;\n\n    case 503: // Service Unavailable\n      return Code.UNAVAILABLE;\n\n    case 504: // Gateway Timeout\n      return Code.DEADLINE_EXCEEDED;\n\n    default:\n      if (status >= 200 && status < 300) {\n        return Code.OK;\n      }\n      if (status >= 400 && status < 500) {\n        return Code.FAILED_PRECONDITION;\n      }\n      if (status >= 500 && status < 600) {\n        return Code.INTERNAL;\n      }\n      return Code.UNKNOWN;\n  }\n}\n\n/**\n * Converts an HTTP response's error status to the equivalent error code.\n *\n * @param status An HTTP error response status (\"FAILED_PRECONDITION\",\n * \"UNKNOWN\", etc.)\n * @returns The equivalent Code. Non-matching responses are mapped to\n *     Code.UNKNOWN.\n */\nexport function mapCodeFromHttpResponseErrorStatus(status: string): Code {\n  const serverError = status.toLowerCase().replace('_', '-');\n  return Object.values(Code).indexOf(serverError as Code) >= 0\n    ? (serverError as Code)\n    : Code.UNKNOWN;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Deferred } from '../util/promise';\nimport { TimerId, AsyncQueue } from '../util/async_queue';\nimport { ExponentialBackoff } from '../remote/backoff';\nimport { Transaction } from './transaction';\nimport { Datastore } from '../remote/datastore';\nimport { isNullOrUndefined } from '../util/types';\nimport { isPermanentError } from '../remote/rpc_error';\nimport { FirestoreError } from '../util/error';\n\nconst RETRY_COUNT = 5;\n\n/**\n * TransactionRunner encapsulates the logic needed to run and retry transactions\n * with backoff.\n */\nexport class TransactionRunner<T> {\n  private retries = RETRY_COUNT;\n  private backoff: ExponentialBackoff;\n\n  constructor(\n    private readonly asyncQueue: AsyncQueue,\n    private readonly datastore: Datastore,\n    private readonly updateFunction: (transaction: Transaction) => Promise<T>,\n    private readonly deferred: Deferred<T>\n  ) {\n    this.backoff = new ExponentialBackoff(\n      this.asyncQueue,\n      TimerId.TransactionRetry\n    );\n  }\n\n  /** Runs the transaction and sets the result on deferred. */\n  run(): void {\n    this.runWithBackOff();\n  }\n\n  private runWithBackOff(): void {\n    this.backoff.backoffAndRun(async () => {\n      const transaction = new Transaction(this.datastore);\n      const userPromise = this.tryRunUpdateFunction(transaction);\n      if (userPromise) {\n        userPromise\n          .then(result => {\n            this.asyncQueue.enqueueAndForget(() => {\n              return transaction\n                .commit()\n                .then(() => {\n                  this.deferred.resolve(result);\n                })\n                .catch(commitError => {\n                  this.handleTransactionError(commitError);\n                });\n            });\n          })\n          .catch(userPromiseError => {\n            this.handleTransactionError(userPromiseError);\n          });\n      }\n    });\n  }\n\n  private tryRunUpdateFunction(transaction: Transaction): Promise<T> | null {\n    try {\n      const userPromise = this.updateFunction(transaction);\n      if (\n        isNullOrUndefined(userPromise) ||\n        !userPromise.catch ||\n        !userPromise.then\n      ) {\n        this.deferred.reject(\n          Error('Transaction callback must return a Promise')\n        );\n        return null;\n      }\n      return userPromise;\n    } catch (error) {\n      // Do not retry errors thrown by user provided updateFunction.\n      this.deferred.reject(error);\n      return null;\n    }\n  }\n\n  private handleTransactionError(error: Error): void {\n    if (this.retries > 0 && this.isRetryableTransactionError(error)) {\n      this.retries -= 1;\n      this.asyncQueue.enqueueAndForget(() => {\n        this.runWithBackOff();\n        return Promise.resolve();\n      });\n    } else {\n      this.deferred.reject(error);\n    }\n  }\n\n  private isRetryableTransactionError(error: Error): boolean {\n    if (error.name === 'FirebaseError') {\n      // In transactions, the backend will fail outdated reads with FAILED_PRECONDITION and\n      // non-matching document versions with ABORTED. These errors should be retried.\n      const code = (error as FirestoreError).code;\n      return (\n        code === 'aborted' ||\n        code === 'failed-precondition' ||\n        !isPermanentError(code)\n      );\n    }\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport {\n  ignoreIfPrimaryLeaseLoss,\n  LocalStore,\n  MultiTabLocalStore\n} from '../local/local_store';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { ReferenceSet } from '../local/reference_set';\nimport { TargetData, TargetPurpose } from '../local/target_data';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { BATCHID_UNKNOWN, MutationBatchResult } from '../model/mutation_batch';\nimport { RemoteEvent, TargetChange } from '../remote/remote_event';\nimport { RemoteStore } from '../remote/remote_store';\nimport { RemoteSyncer } from '../remote/remote_syncer';\nimport { debugAssert, fail, hardAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport { ObjectMap } from '../util/obj_map';\nimport { Deferred } from '../util/promise';\nimport { SortedMap } from '../util/sorted_map';\n\nimport { ClientId, SharedClientState } from '../local/shared_client_state';\nimport {\n  QueryTargetState,\n  SharedClientStateSyncer\n} from '../local/shared_client_state_syncer';\nimport { SortedSet } from '../util/sorted_set';\nimport { ListenSequence } from './listen_sequence';\nimport { LimitType, Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { Target } from './target';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { Transaction } from './transaction';\nimport {\n  BatchId,\n  MutationBatchState,\n  OnlineState,\n  OnlineStateSource,\n  TargetId\n} from './types';\nimport {\n  AddedLimboDocument,\n  LimboDocumentChange,\n  RemovedLimboDocument,\n  View,\n  ViewChange,\n  ViewDocumentChanges\n} from './view';\nimport { ViewSnapshot } from './view_snapshot';\nimport { AsyncQueue, wrapInUserErrorIfRecoverable } from '../util/async_queue';\nimport { TransactionRunner } from './transaction_runner';\nimport { Datastore } from '../remote/datastore';\n\nconst LOG_TAG = 'SyncEngine';\n\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nclass QueryView {\n  constructor(\n    /**\n     * The query itself.\n     */\n    public query: Query,\n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    public targetId: TargetId,\n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    public view: View\n  ) {}\n}\n\n/** Tracks a limbo resolution. */\nclass LimboResolution {\n  constructor(public key: DocumentKey) {}\n\n  /**\n   * Set to true once we've received a document. This is used in\n   * getRemoteKeysForTarget() and ultimately used by WatchChangeAggregator to\n   * decide whether it needs to manufacture a delete event for the target once\n   * the target is CURRENT.\n   */\n  receivedDocument: boolean = false;\n}\n\n/**\n * Interface implemented by EventManager to handle notifications from\n * SyncEngine.\n */\nexport interface SyncEngineListener {\n  /** Handles new view snapshots. */\n  onWatchChange(snapshots: ViewSnapshot[]): void;\n\n  /** Handles the failure of a query. */\n  onWatchError(query: Query, error: Error): void;\n\n  /** Handles a change in online state. */\n  onOnlineStateChange(onlineState: OnlineState): void;\n}\n\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngines methods should only ever be called by methods running in the\n * global async queue.\n */\nexport class SyncEngine implements RemoteSyncer {\n  protected syncEngineListener: SyncEngineListener | null = null;\n\n  protected queryViewsByQuery = new ObjectMap<Query, QueryView>(q =>\n    q.canonicalId()\n  );\n  protected queriesByTarget = new Map<TargetId, Query[]>();\n  /**\n   * The keys of documents that are in limbo for which we haven't yet started a\n   * limbo resolution query.\n   */\n  private enqueuedLimboResolutions: DocumentKey[] = [];\n  /**\n   * Keeps track of the target ID for each document that is in limbo with an\n   * active target.\n   */\n  protected activeLimboTargetsByKey = new SortedMap<DocumentKey, TargetId>(\n    DocumentKey.comparator\n  );\n  /**\n   * Keeps track of the information about an active limbo resolution for each\n   * active target ID that was started for the purpose of limbo resolution.\n   */\n  protected activeLimboResolutionsByTarget = new Map<\n    TargetId,\n    LimboResolution\n  >();\n  protected limboDocumentRefs = new ReferenceSet();\n  /** Stores user completion handlers, indexed by User and BatchId. */\n  private mutationUserCallbacks = {} as {\n    [uidKey: string]: SortedMap<BatchId, Deferred<void>>;\n  };\n  /** Stores user callbacks waiting for all pending writes to be acknowledged. */\n  private pendingWritesCallbacks = new Map<BatchId, Array<Deferred<void>>>();\n  private limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();\n\n  private onlineState = OnlineState.Unknown;\n\n  constructor(\n    protected localStore: LocalStore,\n    protected remoteStore: RemoteStore,\n    protected datastore: Datastore,\n    // PORTING NOTE: Manages state synchronization in multi-tab environments.\n    protected sharedClientState: SharedClientState,\n    private currentUser: User,\n    private maxConcurrentLimboResolutions: number\n  ) {}\n\n  get isPrimaryClient(): boolean {\n    return true;\n  }\n\n  /** Subscribes to SyncEngine notifications. Has to be called exactly once. */\n  subscribe(syncEngineListener: SyncEngineListener): void {\n    debugAssert(\n      syncEngineListener !== null,\n      'SyncEngine listener cannot be null'\n    );\n    debugAssert(\n      this.syncEngineListener === null,\n      'SyncEngine already has a subscriber.'\n    );\n\n    this.syncEngineListener = syncEngineListener;\n  }\n\n  /**\n   * Initiates the new listen, resolves promise when listen enqueued to the\n   * server. All the subsequent view snapshots or errors are sent to the\n   * subscribed handlers. Returns the initial snapshot.\n   */\n  async listen(query: Query): Promise<ViewSnapshot> {\n    this.assertSubscribed('listen()');\n\n    let targetId;\n    let viewSnapshot;\n\n    const queryView = this.queryViewsByQuery.get(query);\n    if (queryView) {\n      // PORTING NOTE: With Multi-Tab Web, it is possible that a query view\n      // already exists when EventManager calls us for the first time. This\n      // happens when the primary tab is already listening to this query on\n      // behalf of another tab and the user of the primary also starts listening\n      // to the query. EventManager will not have an assigned target ID in this\n      // case and calls `listen` to obtain this ID.\n      targetId = queryView.targetId;\n      this.sharedClientState.addLocalQueryTarget(targetId);\n      viewSnapshot = queryView.view.computeInitialSnapshot();\n    } else {\n      const targetData = await this.localStore.allocateTarget(query.toTarget());\n\n      const status = this.sharedClientState.addLocalQueryTarget(\n        targetData.targetId\n      );\n      targetId = targetData.targetId;\n      viewSnapshot = await this.initializeViewAndComputeSnapshot(\n        query,\n        targetId,\n        status === 'current'\n      );\n      if (this.isPrimaryClient) {\n        this.remoteStore.listen(targetData);\n      }\n    }\n\n    return viewSnapshot;\n  }\n\n  /**\n   * Registers a view for a previously unknown query and computes its initial\n   * snapshot.\n   */\n  protected async initializeViewAndComputeSnapshot(\n    query: Query,\n    targetId: TargetId,\n    current: boolean\n  ): Promise<ViewSnapshot> {\n    const queryResult = await this.localStore.executeQuery(\n      query,\n      /* usePreviousResults= */ true\n    );\n    const view = new View(query, queryResult.remoteKeys);\n    const viewDocChanges = view.computeDocChanges(queryResult.documents);\n    const synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(\n      targetId,\n      current && this.onlineState !== OnlineState.Offline\n    );\n    const viewChange = view.applyChanges(\n      viewDocChanges,\n      /* updateLimboDocuments= */ this.isPrimaryClient,\n      synthesizedTargetChange\n    );\n    this.updateTrackedLimbos(targetId, viewChange.limboChanges);\n\n    debugAssert(\n      !!viewChange.snapshot,\n      'applyChanges for new view should always return a snapshot'\n    );\n\n    const data = new QueryView(query, targetId, view);\n    this.queryViewsByQuery.set(query, data);\n    if (this.queriesByTarget.has(targetId)) {\n      this.queriesByTarget.get(targetId)!.push(query);\n    } else {\n      this.queriesByTarget.set(targetId, [query]);\n    }\n    return viewChange.snapshot!;\n  }\n\n  /** Stops listening to the query. */\n  async unlisten(query: Query): Promise<void> {\n    this.assertSubscribed('unlisten()');\n\n    const queryView = this.queryViewsByQuery.get(query)!;\n    debugAssert(!!queryView, 'Trying to unlisten on query not found:' + query);\n\n    // Only clean up the query view and target if this is the only query mapped\n    // to the target.\n    const queries = this.queriesByTarget.get(queryView.targetId)!;\n    if (queries.length > 1) {\n      this.queriesByTarget.set(\n        queryView.targetId,\n        queries.filter(q => !q.isEqual(query))\n      );\n      this.queryViewsByQuery.delete(query);\n      return;\n    }\n\n    // No other queries are mapped to the target, clean up the query and the target.\n    if (this.isPrimaryClient) {\n      // We need to remove the local query target first to allow us to verify\n      // whether any other client is still interested in this target.\n      this.sharedClientState.removeLocalQueryTarget(queryView.targetId);\n      const targetRemainsActive = this.sharedClientState.isActiveQueryTarget(\n        queryView.targetId\n      );\n\n      if (!targetRemainsActive) {\n        await this.localStore\n          .releaseTarget(queryView.targetId, /*keepPersistedTargetData=*/ false)\n          .then(() => {\n            this.sharedClientState.clearQueryState(queryView.targetId);\n            this.remoteStore.unlisten(queryView.targetId);\n            this.removeAndCleanupTarget(queryView.targetId);\n          })\n          .catch(ignoreIfPrimaryLeaseLoss);\n      }\n    } else {\n      this.removeAndCleanupTarget(queryView.targetId);\n      await this.localStore.releaseTarget(\n        queryView.targetId,\n        /*keepPersistedTargetData=*/ true\n      );\n    }\n  }\n\n  /**\n   * Initiates the write of local mutation batch which involves adding the\n   * writes to the mutation queue, notifying the remote store about new\n   * mutations and raising events for any changes this write caused.\n   *\n   * The promise returned by this call is resolved when the above steps\n   * have completed, *not* when the write was acked by the backend. The\n   * userCallback is resolved once the write was acked/rejected by the\n   * backend (or failed locally for any other reason).\n   */\n  async write(batch: Mutation[], userCallback: Deferred<void>): Promise<void> {\n    this.assertSubscribed('write()');\n\n    try {\n      const result = await this.localStore.localWrite(batch);\n      this.sharedClientState.addPendingMutation(result.batchId);\n      this.addMutationCallback(result.batchId, userCallback);\n      await this.emitNewSnapsAndNotifyLocalStore(result.changes);\n      await this.remoteStore.fillWritePipeline();\n    } catch (e) {\n      // If we can't persist the mutation, we reject the user callback and\n      // don't send the mutation. The user can then retry the write.\n      const error = wrapInUserErrorIfRecoverable(e, `Failed to persist write`);\n      userCallback.reject(error);\n    }\n  }\n\n  /**\n   * Takes an updateFunction in which a set of reads and writes can be performed\n   * atomically. In the updateFunction, the client can read and write values\n   * using the supplied transaction object. After the updateFunction, all\n   * changes will be committed. If a retryable error occurs (ex: some other\n   * client has changed any of the data referenced), then the updateFunction\n   * will be called again after a backoff. If the updateFunction still fails\n   * after all retries, then the transaction will be rejected.\n   *\n   * The transaction object passed to the updateFunction contains methods for\n   * accessing documents and collections. Unlike other datastore access, data\n   * accessed with the transaction will not reflect local changes that have not\n   * been committed. For this reason, it is required that all reads are\n   * performed before any writes. Transactions must be performed while online.\n   *\n   * The Deferred input is resolved when the transaction is fully committed.\n   */\n  runTransaction<T>(\n    asyncQueue: AsyncQueue,\n    updateFunction: (transaction: Transaction) => Promise<T>,\n    deferred: Deferred<T>\n  ): void {\n    new TransactionRunner<T>(\n      asyncQueue,\n      this.datastore,\n      updateFunction,\n      deferred\n    ).run();\n  }\n\n  async applyRemoteEvent(remoteEvent: RemoteEvent): Promise<void> {\n    this.assertSubscribed('applyRemoteEvent()');\n    try {\n      const changes = await this.localStore.applyRemoteEvent(remoteEvent);\n      // Update `receivedDocument` as appropriate for any limbo targets.\n      remoteEvent.targetChanges.forEach((targetChange, targetId) => {\n        const limboResolution = this.activeLimboResolutionsByTarget.get(\n          targetId\n        );\n        if (limboResolution) {\n          // Since this is a limbo resolution lookup, it's for a single document\n          // and it could be added, modified, or removed, but not a combination.\n          hardAssert(\n            targetChange.addedDocuments.size +\n              targetChange.modifiedDocuments.size +\n              targetChange.removedDocuments.size <=\n              1,\n            'Limbo resolution for single document contains multiple changes.'\n          );\n          if (targetChange.addedDocuments.size > 0) {\n            limboResolution.receivedDocument = true;\n          } else if (targetChange.modifiedDocuments.size > 0) {\n            hardAssert(\n              limboResolution.receivedDocument,\n              'Received change for limbo target document without add.'\n            );\n          } else if (targetChange.removedDocuments.size > 0) {\n            hardAssert(\n              limboResolution.receivedDocument,\n              'Received remove for limbo target document without add.'\n            );\n            limboResolution.receivedDocument = false;\n          } else {\n            // This was probably just a CURRENT targetChange or similar.\n          }\n        }\n      });\n      await this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n    } catch (error) {\n      await ignoreIfPrimaryLeaseLoss(error);\n    }\n  }\n\n  /**\n   * Applies an OnlineState change to the sync engine and notifies any views of\n   * the change.\n   */\n  applyOnlineStateChange(\n    onlineState: OnlineState,\n    source: OnlineStateSource\n  ): void {\n    this.assertSubscribed('applyOnlineStateChange()');\n    const newViewSnapshots = [] as ViewSnapshot[];\n    this.queryViewsByQuery.forEach((query, queryView) => {\n      const viewChange = queryView.view.applyOnlineStateChange(onlineState);\n      debugAssert(\n        viewChange.limboChanges.length === 0,\n        'OnlineState should not affect limbo documents.'\n      );\n      if (viewChange.snapshot) {\n        newViewSnapshots.push(viewChange.snapshot);\n      }\n    });\n    this.syncEngineListener!.onOnlineStateChange(onlineState);\n    this.syncEngineListener!.onWatchChange(newViewSnapshots);\n    this.onlineState = onlineState;\n  }\n\n  async rejectListen(targetId: TargetId, err: FirestoreError): Promise<void> {\n    this.assertSubscribed('rejectListens()');\n\n    // PORTING NOTE: Multi-tab only.\n    this.sharedClientState.updateQueryState(targetId, 'rejected', err);\n\n    const limboResolution = this.activeLimboResolutionsByTarget.get(targetId);\n    const limboKey = limboResolution && limboResolution.key;\n    if (limboKey) {\n      // TODO(klimt): We really only should do the following on permission\n      // denied errors, but we don't have the cause code here.\n\n      // It's a limbo doc. Create a synthetic event saying it was deleted.\n      // This is kind of a hack. Ideally, we would have a method in the local\n      // store to purge a document. However, it would be tricky to keep all of\n      // the local store's invariants with another method.\n      let documentUpdates = new SortedMap<DocumentKey, MaybeDocument>(\n        DocumentKey.comparator\n      );\n      documentUpdates = documentUpdates.insert(\n        limboKey,\n        new NoDocument(limboKey, SnapshotVersion.min())\n      );\n      const resolvedLimboDocuments = documentKeySet().add(limboKey);\n      const event = new RemoteEvent(\n        SnapshotVersion.min(),\n        /* targetChanges= */ new Map<TargetId, TargetChange>(),\n        /* targetMismatches= */ new SortedSet<TargetId>(primitiveComparator),\n        documentUpdates,\n        resolvedLimboDocuments\n      );\n\n      await this.applyRemoteEvent(event);\n\n      // Since this query failed, we won't want to manually unlisten to it.\n      // We only remove it from bookkeeping after we successfully applied the\n      // RemoteEvent. If `applyRemoteEvent()` throws, we want to re-listen to\n      // this query when the RemoteStore restarts the Watch stream, which should\n      // re-trigger the target failure.\n      this.activeLimboTargetsByKey = this.activeLimboTargetsByKey.remove(\n        limboKey\n      );\n      this.activeLimboResolutionsByTarget.delete(targetId);\n      this.pumpEnqueuedLimboResolutions();\n    } else {\n      await this.localStore\n        .releaseTarget(targetId, /* keepPersistedTargetData */ false)\n        .then(() => this.removeAndCleanupTarget(targetId, err))\n        .catch(ignoreIfPrimaryLeaseLoss);\n    }\n  }\n\n  async applySuccessfulWrite(\n    mutationBatchResult: MutationBatchResult\n  ): Promise<void> {\n    this.assertSubscribed('applySuccessfulWrite()');\n\n    const batchId = mutationBatchResult.batch.batchId;\n\n    try {\n      const changes = await this.localStore.acknowledgeBatch(\n        mutationBatchResult\n      );\n\n      // The local store may or may not be able to apply the write result and\n      // raise events immediately (depending on whether the watcher is caught\n      // up), so we raise user callbacks first so that they consistently happen\n      // before listen events.\n      this.processUserCallback(batchId, /*error=*/ null);\n      this.triggerPendingWritesCallbacks(batchId);\n\n      this.sharedClientState.updateMutationState(batchId, 'acknowledged');\n      await this.emitNewSnapsAndNotifyLocalStore(changes);\n    } catch (error) {\n      await ignoreIfPrimaryLeaseLoss(error);\n    }\n  }\n\n  async rejectFailedWrite(\n    batchId: BatchId,\n    error: FirestoreError\n  ): Promise<void> {\n    this.assertSubscribed('rejectFailedWrite()');\n\n    try {\n      const changes = await this.localStore.rejectBatch(batchId);\n\n      // The local store may or may not be able to apply the write result and\n      // raise events immediately (depending on whether the watcher is caught up),\n      // so we raise user callbacks first so that they consistently happen before\n      // listen events.\n      this.processUserCallback(batchId, error);\n      this.triggerPendingWritesCallbacks(batchId);\n\n      this.sharedClientState.updateMutationState(batchId, 'rejected', error);\n      await this.emitNewSnapsAndNotifyLocalStore(changes);\n    } catch (error) {\n      await ignoreIfPrimaryLeaseLoss(error);\n    }\n  }\n\n  /**\n   * Registers a user callback that resolves when all pending mutations at the moment of calling\n   * are acknowledged .\n   */\n  async registerPendingWritesCallback(callback: Deferred<void>): Promise<void> {\n    if (!this.remoteStore.canUseNetwork()) {\n      logDebug(\n        LOG_TAG,\n        'The network is disabled. The task returned by ' +\n          \"'awaitPendingWrites()' will not complete until the network is enabled.\"\n      );\n    }\n\n    try {\n      const highestBatchId = await this.localStore.getHighestUnacknowledgedBatchId();\n      if (highestBatchId === BATCHID_UNKNOWN) {\n        // Trigger the callback right away if there is no pending writes at the moment.\n        callback.resolve();\n        return;\n      }\n\n      const callbacks = this.pendingWritesCallbacks.get(highestBatchId) || [];\n      callbacks.push(callback);\n      this.pendingWritesCallbacks.set(highestBatchId, callbacks);\n    } catch (e) {\n      const firestoreError = wrapInUserErrorIfRecoverable(\n        e,\n        'Initialization of waitForPendingWrites() operation failed'\n      );\n      callback.reject(firestoreError);\n    }\n  }\n\n  /**\n   * Triggers the callbacks that are waiting for this batch id to get acknowledged by server,\n   * if there are any.\n   */\n  private triggerPendingWritesCallbacks(batchId: BatchId): void {\n    (this.pendingWritesCallbacks.get(batchId) || []).forEach(callback => {\n      callback.resolve();\n    });\n\n    this.pendingWritesCallbacks.delete(batchId);\n  }\n\n  /** Reject all outstanding callbacks waiting for pending writes to complete. */\n  private rejectOutstandingPendingWritesCallbacks(errorMessage: string): void {\n    this.pendingWritesCallbacks.forEach(callbacks => {\n      callbacks.forEach(callback => {\n        callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));\n      });\n    });\n\n    this.pendingWritesCallbacks.clear();\n  }\n\n  private addMutationCallback(\n    batchId: BatchId,\n    callback: Deferred<void>\n  ): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n    if (!newCallbacks) {\n      newCallbacks = new SortedMap<BatchId, Deferred<void>>(\n        primitiveComparator\n      );\n    }\n    newCallbacks = newCallbacks.insert(batchId, callback);\n    this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n  }\n\n  /**\n   * Resolves or rejects the user callback for the given batch and then discards\n   * it.\n   */\n  protected processUserCallback(batchId: BatchId, error: Error | null): void {\n    let newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n\n    // NOTE: Mutations restored from persistence won't have callbacks, so it's\n    // okay for there to be no callback for this ID.\n    if (newCallbacks) {\n      const callback = newCallbacks.get(batchId);\n      if (callback) {\n        debugAssert(\n          batchId === newCallbacks.minKey(),\n          'Mutation callbacks processed out-of-order?'\n        );\n        if (error) {\n          callback.reject(error);\n        } else {\n          callback.resolve();\n        }\n        newCallbacks = newCallbacks.remove(batchId);\n      }\n      this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    }\n  }\n\n  protected removeAndCleanupTarget(\n    targetId: number,\n    error: Error | null = null\n  ): void {\n    this.sharedClientState.removeLocalQueryTarget(targetId);\n\n    debugAssert(\n      this.queriesByTarget.has(targetId) &&\n        this.queriesByTarget.get(targetId)!.length !== 0,\n      `There are no queries mapped to target id ${targetId}`\n    );\n\n    for (const query of this.queriesByTarget.get(targetId)!) {\n      this.queryViewsByQuery.delete(query);\n      if (error) {\n        this.syncEngineListener!.onWatchError(query, error);\n      }\n    }\n\n    this.queriesByTarget.delete(targetId);\n\n    if (this.isPrimaryClient) {\n      const limboKeys = this.limboDocumentRefs.removeReferencesForId(targetId);\n      limboKeys.forEach(limboKey => {\n        const isReferenced = this.limboDocumentRefs.containsKey(limboKey);\n        if (!isReferenced) {\n          // We removed the last reference for this key\n          this.removeLimboTarget(limboKey);\n        }\n      });\n    }\n  }\n\n  private removeLimboTarget(key: DocumentKey): void {\n    // It's possible that the target already got removed because the query failed. In that case,\n    // the key won't exist in `limboTargetsByKey`. Only do the cleanup if we still have the target.\n    const limboTargetId = this.activeLimboTargetsByKey.get(key);\n    if (limboTargetId === null) {\n      // This target already got removed, because the query failed.\n      return;\n    }\n\n    this.remoteStore.unlisten(limboTargetId);\n    this.activeLimboTargetsByKey = this.activeLimboTargetsByKey.remove(key);\n    this.activeLimboResolutionsByTarget.delete(limboTargetId);\n    this.pumpEnqueuedLimboResolutions();\n  }\n\n  protected updateTrackedLimbos(\n    targetId: TargetId,\n    limboChanges: LimboDocumentChange[]\n  ): void {\n    for (const limboChange of limboChanges) {\n      if (limboChange instanceof AddedLimboDocument) {\n        this.limboDocumentRefs.addReference(limboChange.key, targetId);\n        this.trackLimboChange(limboChange);\n      } else if (limboChange instanceof RemovedLimboDocument) {\n        logDebug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n        this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n        const isReferenced = this.limboDocumentRefs.containsKey(\n          limboChange.key\n        );\n        if (!isReferenced) {\n          // We removed the last reference for this key\n          this.removeLimboTarget(limboChange.key);\n        }\n      } else {\n        fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n      }\n    }\n  }\n\n  private trackLimboChange(limboChange: AddedLimboDocument): void {\n    const key = limboChange.key;\n    if (!this.activeLimboTargetsByKey.get(key)) {\n      logDebug(LOG_TAG, 'New document in limbo: ' + key);\n      this.enqueuedLimboResolutions.push(key);\n      this.pumpEnqueuedLimboResolutions();\n    }\n  }\n\n  /**\n   * Starts listens for documents in limbo that are enqueued for resolution,\n   * subject to a maximum number of concurrent resolutions.\n   *\n   * Without bounding the number of concurrent resolutions, the server can fail\n   * with \"resource exhausted\" errors which can lead to pathological client\n   * behavior as seen in https://github.com/firebase/firebase-js-sdk/issues/2683.\n   */\n  private pumpEnqueuedLimboResolutions(): void {\n    while (\n      this.enqueuedLimboResolutions.length > 0 &&\n      this.activeLimboTargetsByKey.size < this.maxConcurrentLimboResolutions\n    ) {\n      const key = this.enqueuedLimboResolutions.shift()!;\n      const limboTargetId = this.limboTargetIdGenerator.next();\n      this.activeLimboResolutionsByTarget.set(\n        limboTargetId,\n        new LimboResolution(key)\n      );\n      this.activeLimboTargetsByKey = this.activeLimboTargetsByKey.insert(\n        key,\n        limboTargetId\n      );\n      this.remoteStore.listen(\n        new TargetData(\n          Query.atPath(key.path).toTarget(),\n          limboTargetId,\n          TargetPurpose.LimboResolution,\n          ListenSequence.INVALID\n        )\n      );\n    }\n  }\n\n  // Visible for testing\n  activeLimboDocumentResolutions(): SortedMap<DocumentKey, TargetId> {\n    return this.activeLimboTargetsByKey;\n  }\n\n  // Visible for testing\n  enqueuedLimboDocumentResolutions(): DocumentKey[] {\n    return this.enqueuedLimboResolutions;\n  }\n\n  protected async emitNewSnapsAndNotifyLocalStore(\n    changes: MaybeDocumentMap,\n    remoteEvent?: RemoteEvent\n  ): Promise<void> {\n    const newSnaps: ViewSnapshot[] = [];\n    const docChangesInAllViews: LocalViewChanges[] = [];\n    const queriesProcessed: Array<Promise<void>> = [];\n\n    this.queryViewsByQuery.forEach((_, queryView) => {\n      queriesProcessed.push(\n        Promise.resolve()\n          .then(() => {\n            const viewDocChanges = queryView.view.computeDocChanges(changes);\n            if (!viewDocChanges.needsRefill) {\n              return viewDocChanges;\n            }\n            // The query has a limit and some docs were removed, so we need\n            // to re-run the query against the local store to make sure we\n            // didn't lose any good docs that had been past the limit.\n            return this.localStore\n              .executeQuery(queryView.query, /* usePreviousResults= */ false)\n              .then(({ documents }) => {\n                return queryView.view.computeDocChanges(\n                  documents,\n                  viewDocChanges\n                );\n              });\n          })\n          .then((viewDocChanges: ViewDocumentChanges) => {\n            const targetChange =\n              remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);\n            const viewChange = queryView.view.applyChanges(\n              viewDocChanges,\n              /* updateLimboDocuments= */ this.isPrimaryClient,\n              targetChange\n            );\n            this.updateTrackedLimbos(\n              queryView.targetId,\n              viewChange.limboChanges\n            );\n            if (viewChange.snapshot) {\n              if (this.isPrimaryClient) {\n                this.sharedClientState.updateQueryState(\n                  queryView.targetId,\n                  viewChange.snapshot.fromCache ? 'not-current' : 'current'\n                );\n              }\n\n              newSnaps.push(viewChange.snapshot);\n              const docChanges = LocalViewChanges.fromSnapshot(\n                queryView.targetId,\n                viewChange.snapshot\n              );\n              docChangesInAllViews.push(docChanges);\n            }\n          })\n      );\n    });\n\n    await Promise.all(queriesProcessed);\n    this.syncEngineListener!.onWatchChange(newSnaps);\n    await this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n  }\n\n  protected assertSubscribed(fnName: string): void {\n    debugAssert(\n      this.syncEngineListener !== null,\n      'Trying to call ' + fnName + ' before calling subscribe().'\n    );\n  }\n\n  async handleCredentialChange(user: User): Promise<void> {\n    const userChanged = !this.currentUser.isEqual(user);\n\n    if (userChanged) {\n      const result = await this.localStore.handleUserChange(user);\n      this.currentUser = user;\n\n      // Fails tasks waiting for pending writes requested by previous user.\n      this.rejectOutstandingPendingWritesCallbacks(\n        \"'waitForPendingWrites' promise is rejected due to a user change.\"\n      );\n      // TODO(b/114226417): Consider calling this only in the primary tab.\n      this.sharedClientState.handleUserChange(\n        user,\n        result.removedBatchIds,\n        result.addedBatchIds\n      );\n      await this.emitNewSnapsAndNotifyLocalStore(result.affectedDocuments);\n    }\n\n    await this.remoteStore.handleCredentialChange();\n  }\n\n  enableNetwork(): Promise<void> {\n    return this.remoteStore.enableNetwork();\n  }\n\n  disableNetwork(): Promise<void> {\n    return this.remoteStore.disableNetwork();\n  }\n\n  getRemoteKeysForTarget(targetId: TargetId): DocumentKeySet {\n    const limboResolution = this.activeLimboResolutionsByTarget.get(targetId);\n    if (limboResolution && limboResolution.receivedDocument) {\n      return documentKeySet().add(limboResolution.key);\n    } else {\n      let keySet = documentKeySet();\n      const queries = this.queriesByTarget.get(targetId);\n      if (!queries) {\n        return keySet;\n      }\n      for (const query of queries) {\n        const queryView = this.queryViewsByQuery.get(query);\n        debugAssert(!!queryView, `No query view found for ${query}`);\n        keySet = keySet.unionWith(queryView.view.syncedDocuments);\n      }\n      return keySet;\n    }\n  }\n}\n\n/**\n * An impplementation of SyncEngine that implement SharedClientStateSyncer for\n * Multi-Tab synchronization.\n */\n// PORTING NOTE: Web only\nexport class MultiTabSyncEngine extends SyncEngine\n  implements SharedClientStateSyncer {\n  // The primary state is set to `true` or `false` immediately after Firestore\n  // startup. In the interim, a client should only be considered primary if\n  // `isPrimary` is true.\n  private _isPrimaryClient: undefined | boolean = undefined;\n\n  constructor(\n    protected localStore: MultiTabLocalStore,\n    remoteStore: RemoteStore,\n    datastore: Datastore,\n    sharedClientState: SharedClientState,\n    currentUser: User,\n    maxConcurrentLimboResolutions: number\n  ) {\n    super(\n      localStore,\n      remoteStore,\n      datastore,\n      sharedClientState,\n      currentUser,\n      maxConcurrentLimboResolutions\n    );\n  }\n\n  get isPrimaryClient(): boolean {\n    return this._isPrimaryClient === true;\n  }\n\n  enableNetwork(): Promise<void> {\n    this.localStore.setNetworkEnabled(true);\n    return super.enableNetwork();\n  }\n\n  disableNetwork(): Promise<void> {\n    this.localStore.setNetworkEnabled(false);\n    return super.disableNetwork();\n  }\n\n  /**\n   * Reconcile the list of synced documents in an existing view with those\n   * from persistence.\n   */\n  private async synchronizeViewAndComputeSnapshot(\n    queryView: QueryView\n  ): Promise<ViewChange> {\n    const queryResult = await this.localStore.executeQuery(\n      queryView.query,\n      /* usePreviousResults= */ true\n    );\n    const viewSnapshot = queryView.view.synchronizeWithPersistedState(\n      queryResult\n    );\n    if (this._isPrimaryClient) {\n      this.updateTrackedLimbos(queryView.targetId, viewSnapshot.limboChanges);\n    }\n    return viewSnapshot;\n  }\n\n  applyOnlineStateChange(\n    onlineState: OnlineState,\n    source: OnlineStateSource\n  ): void {\n    // If we are the primary client, the online state of all clients only\n    // depends on the online state of the local RemoteStore.\n    if (this.isPrimaryClient && source === OnlineStateSource.RemoteStore) {\n      super.applyOnlineStateChange(onlineState, source);\n      this.sharedClientState.setOnlineState(onlineState);\n    }\n\n    // If we are the secondary client, we explicitly ignore the remote store's\n    // online state (the local client may go offline, even though the primary\n    // tab remains online) and only apply the primary tab's online state from\n    // SharedClientState.\n    if (\n      !this.isPrimaryClient &&\n      source === OnlineStateSource.SharedClientState\n    ) {\n      super.applyOnlineStateChange(onlineState, source);\n    }\n  }\n\n  async applyBatchState(\n    batchId: BatchId,\n    batchState: MutationBatchState,\n    error?: FirestoreError\n  ): Promise<void> {\n    this.assertSubscribed('applyBatchState()');\n    const documents = await this.localStore.lookupMutationDocuments(batchId);\n\n    if (documents === null) {\n      // A throttled tab may not have seen the mutation before it was completed\n      // and removed from the mutation queue, in which case we won't have cached\n      // the affected documents. In this case we can safely ignore the update\n      // since that means we didn't apply the mutation locally at all (if we\n      // had, we would have cached the affected documents), and so we will just\n      // see any resulting document changes via normal remote document updates\n      // as applicable.\n      logDebug(LOG_TAG, 'Cannot apply mutation batch with id: ' + batchId);\n      return;\n    }\n\n    if (batchState === 'pending') {\n      // If we are the primary client, we need to send this write to the\n      // backend. Secondary clients will ignore these writes since their remote\n      // connection is disabled.\n      await this.remoteStore.fillWritePipeline();\n    } else if (batchState === 'acknowledged' || batchState === 'rejected') {\n      // NOTE: Both these methods are no-ops for batches that originated from\n      // other clients.\n      this.processUserCallback(batchId, error ? error : null);\n      this.localStore.removeCachedMutationBatchMetadata(batchId);\n    } else {\n      fail(`Unknown batchState: ${batchState}`);\n    }\n\n    await this.emitNewSnapsAndNotifyLocalStore(documents);\n  }\n\n  async applyPrimaryState(isPrimary: boolean): Promise<void> {\n    if (isPrimary === true && this._isPrimaryClient !== true) {\n      // Secondary tabs only maintain Views for their local listeners and the\n      // Views internal state may not be 100% populated (in particular\n      // secondary tabs don't track syncedDocuments, the set of documents the\n      // server considers to be in the target). So when a secondary becomes\n      // primary, we need to need to make sure that all views for all targets\n      // match the state on disk.\n      const activeTargets = this.sharedClientState.getAllActiveQueryTargets();\n      const activeQueries = await this.synchronizeQueryViewsAndRaiseSnapshots(\n        activeTargets.toArray(),\n        /*transitionToPrimary=*/ true\n      );\n      this._isPrimaryClient = true;\n      await this.remoteStore.applyPrimaryState(true);\n      for (const targetData of activeQueries) {\n        this.remoteStore.listen(targetData);\n      }\n    } else if (isPrimary === false && this._isPrimaryClient !== false) {\n      const activeTargets: TargetId[] = [];\n\n      let p = Promise.resolve();\n      this.queriesByTarget.forEach((_, targetId) => {\n        if (this.sharedClientState.isLocalQueryTarget(targetId)) {\n          activeTargets.push(targetId);\n        } else {\n          p = p.then(() => {\n            this.removeAndCleanupTarget(targetId);\n            return this.localStore.releaseTarget(\n              targetId,\n              /*keepPersistedTargetData=*/ true\n            );\n          });\n        }\n        this.remoteStore.unlisten(targetId);\n      });\n      await p;\n\n      await this.synchronizeQueryViewsAndRaiseSnapshots(\n        activeTargets,\n        /*transitionToPrimary=*/ false\n      );\n      this.resetLimboDocuments();\n      this._isPrimaryClient = false;\n      await this.remoteStore.applyPrimaryState(false);\n    }\n  }\n\n  private resetLimboDocuments(): void {\n    this.activeLimboResolutionsByTarget.forEach((_, targetId) => {\n      this.remoteStore.unlisten(targetId);\n    });\n    this.limboDocumentRefs.removeAllReferences();\n    this.activeLimboResolutionsByTarget = new Map<TargetId, LimboResolution>();\n    this.activeLimboTargetsByKey = new SortedMap<DocumentKey, TargetId>(\n      DocumentKey.comparator\n    );\n  }\n\n  /**\n   * Reconcile the query views of the provided query targets with the state from\n   * persistence. Raises snapshots for any changes that affect the local\n   * client and returns the updated state of all target's query data.\n   *\n   * @param targets the list of targets with views that need to be recomputed\n   * @param transitionToPrimary `true` iff the tab transitions from a secondary\n   * tab to a primary tab\n   */\n  private async synchronizeQueryViewsAndRaiseSnapshots(\n    targets: TargetId[],\n    transitionToPrimary: boolean\n  ): Promise<TargetData[]> {\n    const activeQueries: TargetData[] = [];\n    const newViewSnapshots: ViewSnapshot[] = [];\n    for (const targetId of targets) {\n      let targetData: TargetData;\n      const queries = this.queriesByTarget.get(targetId);\n\n      if (queries && queries.length !== 0) {\n        // For queries that have a local View, we fetch their current state\n        // from LocalStore (as the resume token and the snapshot version\n        // might have changed) and reconcile their views with the persisted\n        // state (the list of syncedDocuments may have gotten out of sync).\n        targetData = await this.localStore.allocateTarget(\n          queries[0].toTarget()\n        );\n\n        for (const query of queries) {\n          const queryView = this.queryViewsByQuery.get(query);\n          debugAssert(!!queryView, `No query view found for ${query}`);\n\n          const viewChange = await this.synchronizeViewAndComputeSnapshot(\n            queryView\n          );\n          if (viewChange.snapshot) {\n            newViewSnapshots.push(viewChange.snapshot);\n          }\n        }\n      } else {\n        debugAssert(\n          transitionToPrimary,\n          'A secondary tab should never have an active view without an active target.'\n        );\n        // For queries that never executed on this client, we need to\n        // allocate the target in LocalStore and initialize a new View.\n        const target = await this.localStore.getTarget(targetId);\n        debugAssert(!!target, `Target for id ${targetId} not found`);\n        targetData = await this.localStore.allocateTarget(target);\n        await this.initializeViewAndComputeSnapshot(\n          this.synthesizeTargetToQuery(target!),\n          targetId,\n          /*current=*/ false\n        );\n      }\n\n      activeQueries.push(targetData!);\n    }\n\n    this.syncEngineListener!.onWatchChange(newViewSnapshots);\n    return activeQueries;\n  }\n\n  /**\n   * Creates a `Query` object from the specified `Target`. There is no way to\n   * obtain the original `Query`, so we synthesize a `Query` from the `Target`\n   * object.\n   *\n   * The synthesized result might be different from the original `Query`, but\n   * since the synthesized `Query` should return the same results as the\n   * original one (only the presentation of results might differ), the potential\n   * difference will not cause issues.\n   */\n  private synthesizeTargetToQuery(target: Target): Query {\n    return new Query(\n      target.path,\n      target.collectionGroup,\n      target.orderBy,\n      target.filters,\n      target.limit,\n      LimitType.First,\n      target.startAt,\n      target.endAt\n    );\n  }\n\n  getActiveClients(): Promise<ClientId[]> {\n    return this.localStore.getActiveClients();\n  }\n\n  async applyTargetState(\n    targetId: TargetId,\n    state: QueryTargetState,\n    error?: FirestoreError\n  ): Promise<void> {\n    if (this._isPrimaryClient) {\n      // If we receive a target state notification via WebStorage, we are\n      // either already secondary or another tab has taken the primary lease.\n      logDebug(LOG_TAG, 'Ignoring unexpected query state notification.');\n      return;\n    }\n\n    if (this.queriesByTarget.has(targetId)) {\n      switch (state) {\n        case 'current':\n        case 'not-current': {\n          const changes = await this.localStore.getNewDocumentChanges();\n          const synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(\n            targetId,\n            state === 'current'\n          );\n          await this.emitNewSnapsAndNotifyLocalStore(\n            changes,\n            synthesizedRemoteEvent\n          );\n          break;\n        }\n        case 'rejected': {\n          await this.localStore.releaseTarget(\n            targetId,\n            /* keepPersistedTargetData */ true\n          );\n          this.removeAndCleanupTarget(targetId, error);\n          break;\n        }\n        default:\n          fail('Unexpected target state: ' + state);\n      }\n    }\n  }\n\n  async applyActiveTargetsChange(\n    added: TargetId[],\n    removed: TargetId[]\n  ): Promise<void> {\n    if (!this._isPrimaryClient) {\n      return;\n    }\n\n    for (const targetId of added) {\n      if (this.queriesByTarget.has(targetId)) {\n        // A target might have been added in a previous attempt\n        logDebug(LOG_TAG, 'Adding an already active target ' + targetId);\n        continue;\n      }\n\n      const target = await this.localStore.getTarget(targetId);\n      debugAssert(\n        !!target,\n        `Query data for active target ${targetId} not found`\n      );\n      const targetData = await this.localStore.allocateTarget(target);\n      await this.initializeViewAndComputeSnapshot(\n        this.synthesizeTargetToQuery(target),\n        targetData.targetId,\n        /*current=*/ false\n      );\n      this.remoteStore.listen(targetData);\n    }\n\n    for (const targetId of removed) {\n      // Check that the target is still active since the target might have been\n      // removed if it has been rejected by the backend.\n      if (!this.queriesByTarget.has(targetId)) {\n        continue;\n      }\n\n      // Release queries that are still active.\n      await this.localStore\n        .releaseTarget(targetId, /* keepPersistedTargetData */ false)\n        .then(() => {\n          this.remoteStore.unlisten(targetId);\n          this.removeAndCleanupTarget(targetId);\n        })\n        .catch(ignoreIfPrimaryLeaseLoss);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OnlineState } from '../core/types';\nimport { debugAssert } from '../util/assert';\nimport { AsyncQueue, DelayedOperation, TimerId } from '../util/async_queue';\nimport { FirestoreError } from '../util/error';\nimport { logError, logDebug } from '../util/log';\n\nconst LOG_TAG = 'OnlineStateTracker';\n\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\n// TODO(mikelehen): This used to be set to 2 as a mitigation for b/66228394.\n// @jdimond thinks that bug is sufficiently fixed so that we can set this back\n// to 1. If that works okay, we could potentially remove this logic entirely.\nconst MAX_WATCH_STREAM_FAILURES = 1;\n\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nconst ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nexport class OnlineStateTracker {\n  /** The current OnlineState. */\n  private state = OnlineState.Unknown;\n\n  /**\n   * A count of consecutive failures to open the stream. If it reaches the\n   * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n   * Offline.\n   */\n  private watchStreamFailures = 0;\n\n  /**\n   * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n   * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n   * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n   */\n  private onlineStateTimer: DelayedOperation<void> | null = null;\n\n  /**\n   * Whether the client should log a warning message if it fails to connect to\n   * the backend (initially true, cleared after a successful stream, or if we've\n   * logged the message already).\n   */\n  private shouldWarnClientIsOffline = true;\n\n  constructor(\n    private asyncQueue: AsyncQueue,\n    private onlineStateHandler: (onlineState: OnlineState) => void\n  ) {}\n\n  /**\n   * Called by RemoteStore when a watch stream is started (including on each\n   * backoff attempt).\n   *\n   * If this is the first attempt, it sets the OnlineState to Unknown and starts\n   * the onlineStateTimer.\n   */\n  handleWatchStreamStart(): void {\n    if (this.watchStreamFailures === 0) {\n      this.setAndBroadcast(OnlineState.Unknown);\n\n      debugAssert(\n        this.onlineStateTimer === null,\n        `onlineStateTimer shouldn't be started yet`\n      );\n      this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(\n        TimerId.OnlineStateTimeout,\n        ONLINE_STATE_TIMEOUT_MS,\n        () => {\n          this.onlineStateTimer = null;\n          debugAssert(\n            this.state === OnlineState.Unknown,\n            'Timer should be canceled if we transitioned to a different state.'\n          );\n          this.logClientOfflineWarningIfNecessary(\n            `Backend didn't respond within ${ONLINE_STATE_TIMEOUT_MS / 1000} ` +\n              `seconds.`\n          );\n          this.setAndBroadcast(OnlineState.Offline);\n\n          // NOTE: handleWatchStreamFailure() will continue to increment\n          // watchStreamFailures even though we are already marked Offline,\n          // but this is non-harmful.\n\n          return Promise.resolve();\n        }\n      );\n    }\n  }\n\n  /**\n   * Updates our OnlineState as appropriate after the watch stream reports a\n   * failure. The first failure moves us to the 'Unknown' state. We then may\n   * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n   * actually transition to the 'Offline' state.\n   */\n  handleWatchStreamFailure(error: FirestoreError): void {\n    if (this.state === OnlineState.Online) {\n      this.setAndBroadcast(OnlineState.Unknown);\n\n      // To get to OnlineState.Online, set() must have been called which would\n      // have reset our heuristics.\n      debugAssert(\n        this.watchStreamFailures === 0,\n        'watchStreamFailures must be 0'\n      );\n      debugAssert(\n        this.onlineStateTimer === null,\n        'onlineStateTimer must be null'\n      );\n    } else {\n      this.watchStreamFailures++;\n      if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n        this.clearOnlineStateTimer();\n\n        this.logClientOfflineWarningIfNecessary(\n          `Connection failed ${MAX_WATCH_STREAM_FAILURES} ` +\n            `times. Most recent error: ${error.toString()}`\n        );\n\n        this.setAndBroadcast(OnlineState.Offline);\n      }\n    }\n  }\n\n  /**\n   * Explicitly sets the OnlineState to the specified state.\n   *\n   * Note that this resets our timers / failure counters, etc. used by our\n   * Offline heuristics, so must not be used in place of\n   * handleWatchStreamStart() and handleWatchStreamFailure().\n   */\n  set(newState: OnlineState): void {\n    this.clearOnlineStateTimer();\n    this.watchStreamFailures = 0;\n\n    if (newState === OnlineState.Online) {\n      // We've connected to watch at least once. Don't warn the developer\n      // about being offline going forward.\n      this.shouldWarnClientIsOffline = false;\n    }\n\n    this.setAndBroadcast(newState);\n  }\n\n  private setAndBroadcast(newState: OnlineState): void {\n    if (newState !== this.state) {\n      this.state = newState;\n      this.onlineStateHandler(newState);\n    }\n  }\n\n  private logClientOfflineWarningIfNecessary(details: string): void {\n    const message =\n      `Could not reach Cloud Firestore backend. ${details}\\n` +\n      `This typically indicates that your device does not have a healthy ` +\n      `Internet connection at the moment. The client will operate in offline ` +\n      `mode until it is able to successfully connect to the backend.`;\n    if (this.shouldWarnClientIsOffline) {\n      logError(message);\n      this.shouldWarnClientIsOffline = false;\n    } else {\n      logDebug(LOG_TAG, message);\n    }\n  }\n\n  private clearOnlineStateTimer(): void {\n    if (this.onlineStateTimer !== null) {\n      this.onlineStateTimer.cancel();\n      this.onlineStateTimer = null;\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetId } from '../core/types';\nimport { ChangeType } from '../core/view_snapshot';\nimport { TargetData, TargetPurpose } from '../local/target_data';\nimport {\n  documentKeySet,\n  DocumentKeySet,\n  maybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { debugAssert, fail, hardAssert } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedMap } from '../util/sorted_map';\nimport { SortedSet } from '../util/sorted_set';\nimport { ExistenceFilter } from './existence_filter';\nimport { RemoteEvent, TargetChange } from './remote_event';\nimport { ByteString } from '../util/byte_string';\n\n/**\n * Internal representation of the watcher API protocol buffers.\n */\nexport type WatchChange =\n  | DocumentWatchChange\n  | WatchTargetChange\n  | ExistenceFilterChange;\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nexport class DocumentWatchChange {\n  constructor(\n    /** The new document applies to all of these targets. */\n    public updatedTargetIds: TargetId[],\n    /** The new document is removed from all of these targets. */\n    public removedTargetIds: TargetId[],\n    /** The key of the document for this change. */\n    public key: DocumentKey,\n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    public newDoc: MaybeDocument | null\n  ) {}\n}\n\nexport class ExistenceFilterChange {\n  constructor(\n    public targetId: TargetId,\n    public existenceFilter: ExistenceFilter\n  ) {}\n}\n\nexport const enum WatchTargetChangeState {\n  NoChange,\n  Added,\n  Removed,\n  Current,\n  Reset\n}\n\nexport class WatchTargetChange {\n  constructor(\n    /** What kind of change occurred to the watch target. */\n    public state: WatchTargetChangeState,\n    /** The target IDs that were added/removed/set. */\n    public targetIds: TargetId[],\n    /**\n     * An opaque, server-assigned token that allows watching a target to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the target. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    public resumeToken: ByteString = ByteString.EMPTY_BYTE_STRING,\n    /** An RPC error indicating why the watch failed. */\n    public cause: FirestoreError | null = null\n  ) {}\n}\n\n/** Tracks the internal state of a Watch target. */\nclass TargetState {\n  /**\n   * The number of pending responses (adds or removes) that we are waiting on.\n   * We only consider targets active that have no pending responses.\n   */\n  private pendingResponses = 0;\n\n  /**\n   * Keeps track of the document changes since the last raised snapshot.\n   *\n   * These changes are continuously updated as we receive document updates and\n   * always reflect the current set of changes against the last issued snapshot.\n   */\n  private documentChanges: SortedMap<\n    DocumentKey,\n    ChangeType\n  > = snapshotChangesMap();\n\n  /** See public getters for explanations of these fields. */\n  private _resumeToken: ByteString = ByteString.EMPTY_BYTE_STRING;\n  private _current = false;\n\n  /**\n   * Whether this target state should be included in the next snapshot. We\n   * initialize to true so that newly-added targets are included in the next\n   * RemoteEvent.\n   */\n  private _hasPendingChanges = true;\n\n  /**\n   * Whether this target has been marked 'current'.\n   *\n   * 'Current' has special meaning in the RPC protocol: It implies that the\n   * Watch backend has sent us all changes up to the point at which the target\n   * was added and that the target is consistent with the rest of the watch\n   * stream.\n   */\n  get current(): boolean {\n    return this._current;\n  }\n\n  /** The last resume token sent to us for this target. */\n  get resumeToken(): ByteString {\n    return this._resumeToken;\n  }\n\n  /** Whether this target has pending target adds or target removes. */\n  get isPending(): boolean {\n    return this.pendingResponses !== 0;\n  }\n\n  /** Whether we have modified any state that should trigger a snapshot. */\n  get hasPendingChanges(): boolean {\n    return this._hasPendingChanges;\n  }\n\n  /**\n   * Applies the resume token to the TargetChange, but only when it has a new\n   * value. Empty resumeTokens are discarded.\n   */\n  updateResumeToken(resumeToken: ByteString): void {\n    if (resumeToken.approximateByteSize() > 0) {\n      this._hasPendingChanges = true;\n      this._resumeToken = resumeToken;\n    }\n  }\n\n  /**\n   * Creates a target change from the current set of changes.\n   *\n   * To reset the document changes after raising this snapshot, call\n   * `clearPendingChanges()`.\n   */\n  toTargetChange(): TargetChange {\n    let addedDocuments = documentKeySet();\n    let modifiedDocuments = documentKeySet();\n    let removedDocuments = documentKeySet();\n\n    this.documentChanges.forEach((key, changeType) => {\n      switch (changeType) {\n        case ChangeType.Added:\n          addedDocuments = addedDocuments.add(key);\n          break;\n        case ChangeType.Modified:\n          modifiedDocuments = modifiedDocuments.add(key);\n          break;\n        case ChangeType.Removed:\n          removedDocuments = removedDocuments.add(key);\n          break;\n        default:\n          fail('Encountered invalid change type: ' + changeType);\n      }\n    });\n\n    return new TargetChange(\n      this._resumeToken,\n      this._current,\n      addedDocuments,\n      modifiedDocuments,\n      removedDocuments\n    );\n  }\n\n  /**\n   * Resets the document changes and sets `hasPendingChanges` to false.\n   */\n  clearPendingChanges(): void {\n    this._hasPendingChanges = false;\n    this.documentChanges = snapshotChangesMap();\n  }\n\n  addDocumentChange(key: DocumentKey, changeType: ChangeType): void {\n    this._hasPendingChanges = true;\n    this.documentChanges = this.documentChanges.insert(key, changeType);\n  }\n\n  removeDocumentChange(key: DocumentKey): void {\n    this._hasPendingChanges = true;\n    this.documentChanges = this.documentChanges.remove(key);\n  }\n\n  recordPendingTargetRequest(): void {\n    this.pendingResponses += 1;\n  }\n\n  recordTargetResponse(): void {\n    this.pendingResponses -= 1;\n  }\n\n  markCurrent(): void {\n    this._hasPendingChanges = true;\n    this._current = true;\n  }\n}\n\n/**\n * Interface implemented by RemoteStore to expose target metadata to the\n * WatchChangeAggregator.\n */\nexport interface TargetMetadataProvider {\n  /**\n   * Returns the set of remote document keys for the given target ID as of the\n   * last raised snapshot.\n   */\n  getRemoteKeysForTarget(targetId: TargetId): DocumentKeySet;\n\n  /**\n   * Returns the TargetData for an active target ID or 'null' if this target\n   * has become inactive\n   */\n  getTargetDataForTarget(targetId: TargetId): TargetData | null;\n}\n\nconst LOG_TAG = 'WatchChangeAggregator';\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent.\n */\nexport class WatchChangeAggregator {\n  constructor(private metadataProvider: TargetMetadataProvider) {}\n\n  /** The internal state of all tracked targets. */\n  private targetStates = new Map<TargetId, TargetState>();\n\n  /** Keeps track of the documents to update since the last raised snapshot. */\n  private pendingDocumentUpdates = maybeDocumentMap();\n\n  /** A mapping of document keys to their set of target IDs. */\n  private pendingDocumentTargetMapping = documentTargetMap();\n\n  /**\n   * A list of targets with existence filter mismatches. These targets are\n   * known to be inconsistent and their listens needs to be re-established by\n   * RemoteStore.\n   */\n  private pendingTargetResets = new SortedSet<TargetId>(primitiveComparator);\n\n  /**\n   * Processes and adds the DocumentWatchChange to the current set of changes.\n   */\n  handleDocumentChange(docChange: DocumentWatchChange): void {\n    for (const targetId of docChange.updatedTargetIds) {\n      if (docChange.newDoc instanceof Document) {\n        this.addDocumentToTarget(targetId, docChange.newDoc);\n      } else if (docChange.newDoc instanceof NoDocument) {\n        this.removeDocumentFromTarget(\n          targetId,\n          docChange.key,\n          docChange.newDoc\n        );\n      }\n    }\n\n    for (const targetId of docChange.removedTargetIds) {\n      this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);\n    }\n  }\n\n  /** Processes and adds the WatchTargetChange to the current set of changes. */\n  handleTargetChange(targetChange: WatchTargetChange): void {\n    this.forEachTarget(targetChange, targetId => {\n      const targetState = this.ensureTargetState(targetId);\n      switch (targetChange.state) {\n        case WatchTargetChangeState.NoChange:\n          if (this.isActiveTarget(targetId)) {\n            targetState.updateResumeToken(targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Added:\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          targetState.recordTargetResponse();\n          if (!targetState.isPending) {\n            // We have a freshly added target, so we need to reset any state\n            // that we had previously. This can happen e.g. when remove and add\n            // back a target for existence filter mismatches.\n            targetState.clearPendingChanges();\n          }\n          targetState.updateResumeToken(targetChange.resumeToken);\n          break;\n        case WatchTargetChangeState.Removed:\n          // We need to keep track of removed targets to we can post-filter and\n          // remove any target changes.\n          // We need to decrement the number of pending acks needed from watch\n          // for this targetId.\n          targetState.recordTargetResponse();\n          if (!targetState.isPending) {\n            this.removeTarget(targetId);\n          }\n          debugAssert(\n            !targetChange.cause,\n            'WatchChangeAggregator does not handle errored targets'\n          );\n          break;\n        case WatchTargetChangeState.Current:\n          if (this.isActiveTarget(targetId)) {\n            targetState.markCurrent();\n            targetState.updateResumeToken(targetChange.resumeToken);\n          }\n          break;\n        case WatchTargetChangeState.Reset:\n          if (this.isActiveTarget(targetId)) {\n            // Reset the target and synthesizes removes for all existing\n            // documents. The backend will re-add any documents that still\n            // match the target before it sends the next global snapshot.\n            this.resetTarget(targetId);\n            targetState.updateResumeToken(targetChange.resumeToken);\n          }\n          break;\n        default:\n          fail('Unknown target watch change state: ' + targetChange.state);\n      }\n    });\n  }\n\n  /**\n   * Iterates over all targetIds that the watch change applies to: either the\n   * targetIds explicitly listed in the change or the targetIds of all currently\n   * active targets.\n   */\n  forEachTarget(\n    targetChange: WatchTargetChange,\n    fn: (targetId: TargetId) => void\n  ): void {\n    if (targetChange.targetIds.length > 0) {\n      targetChange.targetIds.forEach(fn);\n    } else {\n      this.targetStates.forEach((_, targetId) => {\n        if (this.isActiveTarget(targetId)) {\n          fn(targetId);\n        }\n      });\n    }\n  }\n\n  /**\n   * Handles existence filters and synthesizes deletes for filter mismatches.\n   * Targets that are invalidated by filter mismatches are added to\n   * `pendingTargetResets`.\n   */\n  handleExistenceFilter(watchChange: ExistenceFilterChange): void {\n    const targetId = watchChange.targetId;\n    const expectedCount = watchChange.existenceFilter.count;\n\n    const targetData = this.targetDataForActiveTarget(targetId);\n    if (targetData) {\n      const target = targetData.target;\n      if (target.isDocumentQuery()) {\n        if (expectedCount === 0) {\n          // The existence filter told us the document does not exist. We deduce\n          // that this document does not exist and apply a deleted document to\n          // our updates. Without applying this deleted document there might be\n          // another query that will raise this document as part of a snapshot\n          // until it is resolved, essentially exposing inconsistency between\n          // queries.\n          const key = new DocumentKey(target.path);\n          this.removeDocumentFromTarget(\n            targetId,\n            key,\n            new NoDocument(key, SnapshotVersion.min())\n          );\n        } else {\n          hardAssert(\n            expectedCount === 1,\n            'Single document existence filter with count: ' + expectedCount\n          );\n        }\n      } else {\n        const currentSize = this.getCurrentDocumentCountForTarget(targetId);\n        if (currentSize !== expectedCount) {\n          // Existence filter mismatch: We reset the mapping and raise a new\n          // snapshot with `isFromCache:true`.\n          this.resetTarget(targetId);\n          this.pendingTargetResets = this.pendingTargetResets.add(targetId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Converts the currently accumulated state into a remote event at the\n   * provided snapshot version. Resets the accumulated changes before returning.\n   */\n  createRemoteEvent(snapshotVersion: SnapshotVersion): RemoteEvent {\n    const targetChanges = new Map<TargetId, TargetChange>();\n\n    this.targetStates.forEach((targetState, targetId) => {\n      const targetData = this.targetDataForActiveTarget(targetId);\n      if (targetData) {\n        if (targetState.current && targetData.target.isDocumentQuery()) {\n          // Document queries for document that don't exist can produce an empty\n          // result set. To update our local cache, we synthesize a document\n          // delete if we have not previously received the document. This\n          // resolves the limbo state of the document, removing it from\n          // limboDocumentRefs.\n          //\n          // TODO(dimond): Ideally we would have an explicit lookup target\n          // instead resulting in an explicit delete message and we could\n          // remove this special logic.\n          const key = new DocumentKey(targetData.target.path);\n          if (\n            this.pendingDocumentUpdates.get(key) === null &&\n            !this.targetContainsDocument(targetId, key)\n          ) {\n            this.removeDocumentFromTarget(\n              targetId,\n              key,\n              new NoDocument(key, snapshotVersion)\n            );\n          }\n        }\n\n        if (targetState.hasPendingChanges) {\n          targetChanges.set(targetId, targetState.toTargetChange());\n          targetState.clearPendingChanges();\n        }\n      }\n    });\n\n    let resolvedLimboDocuments = documentKeySet();\n\n    // We extract the set of limbo-only document updates as the GC logic\n    // special-cases documents that do not appear in the target cache.\n    //\n    // TODO(gsoltis): Expand on this comment once GC is available in the JS\n    // client.\n    this.pendingDocumentTargetMapping.forEach((key, targets) => {\n      let isOnlyLimboTarget = true;\n\n      targets.forEachWhile(targetId => {\n        const targetData = this.targetDataForActiveTarget(targetId);\n        if (\n          targetData &&\n          targetData.purpose !== TargetPurpose.LimboResolution\n        ) {\n          isOnlyLimboTarget = false;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (isOnlyLimboTarget) {\n        resolvedLimboDocuments = resolvedLimboDocuments.add(key);\n      }\n    });\n\n    const remoteEvent = new RemoteEvent(\n      snapshotVersion,\n      targetChanges,\n      this.pendingTargetResets,\n      this.pendingDocumentUpdates,\n      resolvedLimboDocuments\n    );\n\n    this.pendingDocumentUpdates = maybeDocumentMap();\n    this.pendingDocumentTargetMapping = documentTargetMap();\n    this.pendingTargetResets = new SortedSet<TargetId>(primitiveComparator);\n\n    return remoteEvent;\n  }\n\n  /**\n   * Adds the provided document to the internal list of document updates and\n   * its document key to the given target's mapping.\n   */\n  // Visible for testing.\n  addDocumentToTarget(targetId: TargetId, document: MaybeDocument): void {\n    if (!this.isActiveTarget(targetId)) {\n      return;\n    }\n\n    const changeType = this.targetContainsDocument(targetId, document.key)\n      ? ChangeType.Modified\n      : ChangeType.Added;\n\n    const targetState = this.ensureTargetState(targetId);\n    targetState.addDocumentChange(document.key, changeType);\n\n    this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(\n      document.key,\n      document\n    );\n\n    this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(\n      document.key,\n      this.ensureDocumentTargetMapping(document.key).add(targetId)\n    );\n  }\n\n  /**\n   * Removes the provided document from the target mapping. If the\n   * document no longer matches the target, but the document's state is still\n   * known (e.g. we know that the document was deleted or we received the change\n   * that caused the filter mismatch), the new document can be provided\n   * to update the remote document cache.\n   */\n  // Visible for testing.\n  removeDocumentFromTarget(\n    targetId: TargetId,\n    key: DocumentKey,\n    updatedDocument: MaybeDocument | null\n  ): void {\n    if (!this.isActiveTarget(targetId)) {\n      return;\n    }\n\n    const targetState = this.ensureTargetState(targetId);\n    if (this.targetContainsDocument(targetId, key)) {\n      targetState.addDocumentChange(key, ChangeType.Removed);\n    } else {\n      // The document may have entered and left the target before we raised a\n      // snapshot, so we can just ignore the change.\n      targetState.removeDocumentChange(key);\n    }\n\n    this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(\n      key,\n      this.ensureDocumentTargetMapping(key).delete(targetId)\n    );\n\n    if (updatedDocument) {\n      this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(\n        key,\n        updatedDocument\n      );\n    }\n  }\n\n  removeTarget(targetId: TargetId): void {\n    this.targetStates.delete(targetId);\n  }\n\n  /**\n   * Returns the current count of documents in the target. This includes both\n   * the number of documents that the LocalStore considers to be part of the\n   * target as well as any accumulated changes.\n   */\n  private getCurrentDocumentCountForTarget(targetId: TargetId): number {\n    const targetState = this.ensureTargetState(targetId);\n    const targetChange = targetState.toTargetChange();\n    return (\n      this.metadataProvider.getRemoteKeysForTarget(targetId).size +\n      targetChange.addedDocuments.size -\n      targetChange.removedDocuments.size\n    );\n  }\n\n  /**\n   * Increment the number of acks needed from watch before we can consider the\n   * server to be 'in-sync' with the client's active targets.\n   */\n  recordPendingTargetRequest(targetId: TargetId): void {\n    // For each request we get we need to record we need a response for it.\n    const targetState = this.ensureTargetState(targetId);\n    targetState.recordPendingTargetRequest();\n  }\n\n  private ensureTargetState(targetId: TargetId): TargetState {\n    let result = this.targetStates.get(targetId);\n    if (!result) {\n      result = new TargetState();\n      this.targetStates.set(targetId, result);\n    }\n    return result;\n  }\n\n  private ensureDocumentTargetMapping(key: DocumentKey): SortedSet<TargetId> {\n    let targetMapping = this.pendingDocumentTargetMapping.get(key);\n\n    if (!targetMapping) {\n      targetMapping = new SortedSet<TargetId>(primitiveComparator);\n      this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(\n        key,\n        targetMapping\n      );\n    }\n\n    return targetMapping;\n  }\n\n  /**\n   * Verifies that the user is still interested in this target (by calling\n   * `getTargetDataForTarget()`) and that we are not waiting for pending ADDs\n   * from watch.\n   */\n  protected isActiveTarget(targetId: TargetId): boolean {\n    const targetActive = this.targetDataForActiveTarget(targetId) !== null;\n    if (!targetActive) {\n      logDebug(LOG_TAG, 'Detected inactive target', targetId);\n    }\n    return targetActive;\n  }\n\n  /**\n   * Returns the TargetData for an active target (i.e. a target that the user\n   * is still interested in that has no outstanding target change requests).\n   */\n  protected targetDataForActiveTarget(targetId: TargetId): TargetData | null {\n    const targetState = this.targetStates.get(targetId);\n    return targetState && targetState.isPending\n      ? null\n      : this.metadataProvider.getTargetDataForTarget(targetId);\n  }\n\n  /**\n   * Resets the state of a Watch target to its initial state (e.g. sets\n   * 'current' to false, clears the resume token and removes its target mapping\n   * from all documents).\n   */\n  private resetTarget(targetId: TargetId): void {\n    debugAssert(\n      !this.targetStates.get(targetId)!.isPending,\n      'Should only reset active targets'\n    );\n    this.targetStates.set(targetId, new TargetState());\n\n    // Trigger removal for any documents currently mapped to this target.\n    // These removals will be part of the initial snapshot if Watch does not\n    // resend these documents.\n    const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n    existingKeys.forEach(key => {\n      this.removeDocumentFromTarget(targetId, key, /*updatedDocument=*/ null);\n    });\n  }\n  /**\n   * Returns whether the LocalStore considers the document to be part of the\n   * specified target.\n   */\n  private targetContainsDocument(\n    targetId: TargetId,\n    key: DocumentKey\n  ): boolean {\n    const existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);\n    return existingKeys.has(key);\n  }\n}\n\nfunction documentTargetMap(): SortedMap<DocumentKey, SortedSet<TargetId>> {\n  return new SortedMap<DocumentKey, SortedSet<TargetId>>(\n    DocumentKey.comparator\n  );\n}\n\nfunction snapshotChangesMap(): SortedMap<DocumentKey, ChangeType> {\n  return new SortedMap<DocumentKey, ChangeType>(DocumentKey.comparator);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { OnlineState, TargetId } from '../core/types';\nimport { LocalStore } from '../local/local_store';\nimport { TargetData, TargetPurpose } from '../local/target_data';\nimport { MutationResult } from '../model/mutation';\nimport {\n  BATCHID_UNKNOWN,\n  MutationBatch,\n  MutationBatchResult\n} from '../model/mutation_batch';\nimport { debugAssert } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\nimport { DocumentKeySet } from '../model/collections';\nimport { AsyncQueue } from '../util/async_queue';\nimport { ConnectivityMonitor, NetworkStatus } from './connectivity_monitor';\nimport {\n  Datastore,\n  newPersistentWatchStream,\n  newPersistentWriteStream\n} from './datastore';\nimport { OnlineStateTracker } from './online_state_tracker';\nimport {\n  PersistentListenStream,\n  PersistentWriteStream\n} from './persistent_stream';\nimport { RemoteSyncer } from './remote_syncer';\nimport { isPermanentWriteError } from './rpc_error';\nimport {\n  DocumentWatchChange,\n  ExistenceFilterChange,\n  TargetMetadataProvider,\n  WatchChange,\n  WatchChangeAggregator,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\nimport { ByteString } from '../util/byte_string';\nimport { isIndexedDbTransactionError } from '../local/simple_db';\n\nconst LOG_TAG = 'RemoteStore';\n\n// TODO(b/35853402): Negotiate this with the stream.\nconst MAX_PENDING_WRITES = 10;\n\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nexport class RemoteStore implements TargetMetadataProvider {\n  /**\n   * A list of up to MAX_PENDING_WRITES writes that we have fetched from the\n   * LocalStore via fillWritePipeline() and have or will send to the write\n   * stream.\n   *\n   * Whenever writePipeline.length > 0 the RemoteStore will attempt to start or\n   * restart the write stream. When the stream is established the writes in the\n   * pipeline will be sent in order.\n   *\n   * Writes remain in writePipeline until they are acknowledged by the backend\n   * and thus will automatically be re-sent if the stream is interrupted /\n   * restarted before they're acknowledged.\n   *\n   * Write responses from the backend are linked to their originating request\n   * purely based on order, and so we can just shift() writes from the front of\n   * the writePipeline as we receive responses.\n   */\n  private writePipeline: MutationBatch[] = [];\n\n  /**\n   * A mapping of watched targets that the client cares about tracking and the\n   * user has explicitly called a 'listen' for this target.\n   *\n   * These targets may or may not have been sent to or acknowledged by the\n   * server. On re-establishing the listen stream, these targets should be sent\n   * to the server. The targets removed with unlistens are removed eagerly\n   * without waiting for confirmation from the listen stream.\n   */\n  private listenTargets = new Map<TargetId, TargetData>();\n\n  private connectivityMonitor: ConnectivityMonitor;\n  private watchStream: PersistentListenStream;\n  private writeStream: PersistentWriteStream;\n  private watchChangeAggregator: WatchChangeAggregator | null = null;\n\n  /**\n   * Set to true by enableNetwork() and false by disableNetwork() and indicates\n   * the user-preferred network state.\n   */\n  private networkEnabled = false;\n\n  private isPrimary = false;\n\n  /**\n   * When set to `true`, the network was taken offline due to an IndexedDB\n   * failure. The state is flipped to `false` when access becomes available\n   * again.\n   */\n  private indexedDbFailed = false;\n\n  private onlineStateTracker: OnlineStateTracker;\n\n  constructor(\n    /**\n     * The local store, used to fill the write pipeline with outbound mutations.\n     */\n    private localStore: LocalStore,\n    /** The client-side proxy for interacting with the backend. */\n    private datastore: Datastore,\n    private asyncQueue: AsyncQueue,\n    onlineStateHandler: (onlineState: OnlineState) => void,\n    connectivityMonitor: ConnectivityMonitor\n  ) {\n    this.connectivityMonitor = connectivityMonitor;\n    this.connectivityMonitor.addCallback((status: NetworkStatus) => {\n      asyncQueue.enqueueAndForget(async () => {\n        if (this.canUseNetwork()) {\n          logDebug(\n            LOG_TAG,\n            'Restarting streams for network reachability change.'\n          );\n          await this.restartNetwork();\n        }\n      });\n    });\n\n    this.onlineStateTracker = new OnlineStateTracker(\n      asyncQueue,\n      onlineStateHandler\n    );\n\n    // Create streams (but note they're not started yet).\n    this.watchStream = newPersistentWatchStream(this.datastore, asyncQueue, {\n      onOpen: this.onWatchStreamOpen.bind(this),\n      onClose: this.onWatchStreamClose.bind(this),\n      onWatchChange: this.onWatchStreamChange.bind(this)\n    });\n\n    this.writeStream = newPersistentWriteStream(this.datastore, asyncQueue, {\n      onOpen: this.onWriteStreamOpen.bind(this),\n      onClose: this.onWriteStreamClose.bind(this),\n      onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n      onMutationResult: this.onMutationResult.bind(this)\n    });\n  }\n\n  /**\n   * SyncEngine to notify of watch and write events. This must be set\n   * immediately after construction.\n   */\n  syncEngine!: RemoteSyncer;\n\n  /**\n   * Starts up the remote store, creating streams, restoring state from\n   * LocalStore, etc.\n   */\n  start(): Promise<void> {\n    return this.enableNetwork();\n  }\n\n  /** Re-enables the network. Idempotent. */\n  enableNetwork(): Promise<void> {\n    this.networkEnabled = true;\n    return this.enableNetworkInternal();\n  }\n\n  private async enableNetworkInternal(): Promise<void> {\n    if (this.canUseNetwork()) {\n      if (this.shouldStartWatchStream()) {\n        this.startWatchStream();\n      } else {\n        this.onlineStateTracker.set(OnlineState.Unknown);\n      }\n\n      // This will start the write stream if necessary.\n      await this.fillWritePipeline();\n    }\n  }\n\n  /**\n   * Temporarily disables the network. The network can be re-enabled using\n   * enableNetwork().\n   */\n  async disableNetwork(): Promise<void> {\n    this.networkEnabled = false;\n    await this.disableNetworkInternal();\n\n    // Set the OnlineState to Offline so get()s return from cache, etc.\n    this.onlineStateTracker.set(OnlineState.Offline);\n  }\n\n  private async disableNetworkInternal(): Promise<void> {\n    await this.writeStream.stop();\n    await this.watchStream.stop();\n\n    if (this.writePipeline.length > 0) {\n      logDebug(\n        LOG_TAG,\n        `Stopping write stream with ${this.writePipeline.length} pending writes`\n      );\n      this.writePipeline = [];\n    }\n\n    this.cleanUpWatchStreamState();\n  }\n\n  async shutdown(): Promise<void> {\n    logDebug(LOG_TAG, 'RemoteStore shutting down.');\n    this.networkEnabled = false;\n    await this.disableNetworkInternal();\n    this.connectivityMonitor.shutdown();\n\n    // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n    // triggering spurious listener events with cached data, etc.\n    this.onlineStateTracker.set(OnlineState.Unknown);\n  }\n\n  /**\n   * Starts new listen for the given target. Uses resume token if provided. It\n   * is a no-op if the target of given `TargetData` is already being listened to.\n   */\n  listen(targetData: TargetData): void {\n    if (this.listenTargets.has(targetData.targetId)) {\n      return;\n    }\n\n    // Mark this as something the client is currently listening for.\n    this.listenTargets.set(targetData.targetId, targetData);\n\n    if (this.shouldStartWatchStream()) {\n      // The listen will be sent in onWatchStreamOpen\n      this.startWatchStream();\n    } else if (this.watchStream.isOpen()) {\n      this.sendWatchRequest(targetData);\n    }\n  }\n\n  /**\n   * Removes the listen from server. It is a no-op if the given target id is\n   * not being listened to.\n   */\n  unlisten(targetId: TargetId): void {\n    debugAssert(\n      this.listenTargets.has(targetId),\n      `unlisten called on target no currently watched: ${targetId}`\n    );\n\n    this.listenTargets.delete(targetId);\n    if (this.watchStream.isOpen()) {\n      this.sendUnwatchRequest(targetId);\n    }\n\n    if (this.listenTargets.size === 0) {\n      if (this.watchStream.isOpen()) {\n        this.watchStream.markIdle();\n      } else if (this.canUseNetwork()) {\n        // Revert to OnlineState.Unknown if the watch stream is not open and we\n        // have no listeners, since without any listens to send we cannot\n        // confirm if the stream is healthy and upgrade to OnlineState.Online.\n        this.onlineStateTracker.set(OnlineState.Unknown);\n      }\n    }\n  }\n\n  /** {@link TargetMetadataProvider.getTargetDataForTarget} */\n  getTargetDataForTarget(targetId: TargetId): TargetData | null {\n    return this.listenTargets.get(targetId) || null;\n  }\n\n  /** {@link TargetMetadataProvider.getRemoteKeysForTarget} */\n  getRemoteKeysForTarget(targetId: TargetId): DocumentKeySet {\n    return this.syncEngine.getRemoteKeysForTarget(targetId);\n  }\n\n  /**\n   * We need to increment the the expected number of pending responses we're due\n   * from watch so we wait for the ack to process any messages from this target.\n   */\n  private sendWatchRequest(targetData: TargetData): void {\n    this.watchChangeAggregator!.recordPendingTargetRequest(targetData.targetId);\n    this.watchStream.watch(targetData);\n  }\n\n  /**\n   * We need to increment the expected number of pending responses we're due\n   * from watch so we wait for the removal on the server before we process any\n   * messages from this target.\n   */\n  private sendUnwatchRequest(targetId: TargetId): void {\n    this.watchChangeAggregator!.recordPendingTargetRequest(targetId);\n    this.watchStream.unwatch(targetId);\n  }\n\n  private startWatchStream(): void {\n    debugAssert(\n      this.shouldStartWatchStream(),\n      'startWatchStream() called when shouldStartWatchStream() is false.'\n    );\n\n    this.watchChangeAggregator = new WatchChangeAggregator(this);\n    this.watchStream.start();\n    this.onlineStateTracker.handleWatchStreamStart();\n  }\n\n  /**\n   * Returns whether the watch stream should be started because it's necessary\n   * and has not yet been started.\n   */\n  private shouldStartWatchStream(): boolean {\n    return (\n      this.canUseNetwork() &&\n      !this.watchStream.isStarted() &&\n      this.listenTargets.size > 0\n    );\n  }\n\n  canUseNetwork(): boolean {\n    return !this.indexedDbFailed && this.isPrimary && this.networkEnabled;\n  }\n\n  private cleanUpWatchStreamState(): void {\n    this.watchChangeAggregator = null;\n  }\n\n  private async onWatchStreamOpen(): Promise<void> {\n    this.listenTargets.forEach((targetData, targetId) => {\n      this.sendWatchRequest(targetData);\n    });\n  }\n\n  private async onWatchStreamClose(error?: FirestoreError): Promise<void> {\n    if (error === undefined) {\n      // Graceful stop (due to stop() or idle timeout). Make sure that's\n      // desirable.\n      debugAssert(\n        !this.shouldStartWatchStream(),\n        'Watch stream was stopped gracefully while still needed.'\n      );\n    }\n\n    this.cleanUpWatchStreamState();\n\n    // If we still need the watch stream, retry the connection.\n    if (this.shouldStartWatchStream()) {\n      this.onlineStateTracker.handleWatchStreamFailure(error!);\n\n      this.startWatchStream();\n    } else {\n      // No need to restart watch stream because there are no active targets.\n      // The online state is set to unknown because there is no active attempt\n      // at establishing a connection\n      this.onlineStateTracker.set(OnlineState.Unknown);\n    }\n  }\n\n  private async onWatchStreamChange(\n    watchChange: WatchChange,\n    snapshotVersion: SnapshotVersion\n  ): Promise<void> {\n    // Mark the client as online since we got a message from the server\n    this.onlineStateTracker.set(OnlineState.Online);\n\n    if (\n      watchChange instanceof WatchTargetChange &&\n      watchChange.state === WatchTargetChangeState.Removed &&\n      watchChange.cause\n    ) {\n      // There was an error on a target, don't wait for a consistent snapshot\n      // to raise events\n      try {\n        await this.handleTargetError(watchChange);\n      } catch (e) {\n        logDebug(\n          LOG_TAG,\n          'Failed to remove targets %s: %s ',\n          watchChange.targetIds.join(','),\n          e\n        );\n        await this.disableNetworkUntilRecovery(e);\n      }\n      return;\n    }\n\n    if (watchChange instanceof DocumentWatchChange) {\n      this.watchChangeAggregator!.handleDocumentChange(watchChange);\n    } else if (watchChange instanceof ExistenceFilterChange) {\n      this.watchChangeAggregator!.handleExistenceFilter(watchChange);\n    } else {\n      debugAssert(\n        watchChange instanceof WatchTargetChange,\n        'Expected watchChange to be an instance of WatchTargetChange'\n      );\n      this.watchChangeAggregator!.handleTargetChange(watchChange);\n    }\n\n    if (!snapshotVersion.isEqual(SnapshotVersion.min())) {\n      try {\n        const lastRemoteSnapshotVersion = await this.localStore.getLastRemoteSnapshotVersion();\n        if (snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0) {\n          // We have received a target change with a global snapshot if the snapshot\n          // version is not equal to SnapshotVersion.min().\n          await this.raiseWatchSnapshot(snapshotVersion);\n        }\n      } catch (e) {\n        logDebug(LOG_TAG, 'Failed to raise snapshot:', e);\n        await this.disableNetworkUntilRecovery(e);\n      }\n    }\n  }\n\n  /**\n   * Recovery logic for IndexedDB errors that takes the network offline until\n   * `op` succeeds. Retries are scheduled with backoff using\n   * `enqueueRetryable()`. If `op()` is not provided, IndexedDB access is\n   * validated via a generic operation.\n   *\n   * The returned Promise is resolved once the network is disabled and before\n   * any retry attempt.\n   */\n  private async disableNetworkUntilRecovery(\n    e: FirestoreError,\n    op?: () => Promise<unknown>\n  ): Promise<void> {\n    if (isIndexedDbTransactionError(e)) {\n      debugAssert(\n        !this.indexedDbFailed,\n        'Unexpected network event when IndexedDB was marked failed.'\n      );\n      this.indexedDbFailed = true;\n\n      // Disable network and raise offline snapshots\n      await this.disableNetworkInternal();\n      this.onlineStateTracker.set(OnlineState.Offline);\n\n      if (!op) {\n        // Use a simple read operation to determine if IndexedDB recovered.\n        // Ideally, we would expose a health check directly on SimpleDb, but\n        // RemoteStore only has access to persistence through LocalStore.\n        op = () => this.localStore.getLastRemoteSnapshotVersion();\n      }\n\n      // Probe IndexedDB periodically and re-enable network\n      this.asyncQueue.enqueueRetryable(async () => {\n        logDebug(LOG_TAG, 'Retrying IndexedDB access');\n        await op!();\n        this.indexedDbFailed = false;\n        await this.enableNetworkInternal();\n      });\n    } else {\n      throw e;\n    }\n  }\n\n  /**\n   * Executes `op`. If `op` fails, takes the network offline until `op`\n   * succeeds. Returns after the first attempt.\n   */\n  private executeWithRecovery(op: () => Promise<void>): Promise<void> {\n    return op().catch(e => this.disableNetworkUntilRecovery(e, op));\n  }\n\n  /**\n   * Takes a batch of changes from the Datastore, repackages them as a\n   * RemoteEvent, and passes that on to the listener, which is typically the\n   * SyncEngine.\n   */\n  private raiseWatchSnapshot(snapshotVersion: SnapshotVersion): Promise<void> {\n    debugAssert(\n      !snapshotVersion.isEqual(SnapshotVersion.min()),\n      \"Can't raise event for unknown SnapshotVersion\"\n    );\n    const remoteEvent = this.watchChangeAggregator!.createRemoteEvent(\n      snapshotVersion\n    );\n\n    // Update in-memory resume tokens. LocalStore will update the\n    // persistent view of these when applying the completed RemoteEvent.\n    remoteEvent.targetChanges.forEach((change, targetId) => {\n      if (change.resumeToken.approximateByteSize() > 0) {\n        const targetData = this.listenTargets.get(targetId);\n        // A watched target might have been removed already.\n        if (targetData) {\n          this.listenTargets.set(\n            targetId,\n            targetData.withResumeToken(change.resumeToken, snapshotVersion)\n          );\n        }\n      }\n    });\n\n    // Re-establish listens for the targets that have been invalidated by\n    // existence filter mismatches.\n    remoteEvent.targetMismatches.forEach(targetId => {\n      const targetData = this.listenTargets.get(targetId);\n      if (!targetData) {\n        // A watched target might have been removed already.\n        return;\n      }\n\n      // Clear the resume token for the target, since we're in a known mismatch\n      // state.\n      this.listenTargets.set(\n        targetId,\n        targetData.withResumeToken(\n          ByteString.EMPTY_BYTE_STRING,\n          targetData.snapshotVersion\n        )\n      );\n\n      // Cause a hard reset by unwatching and rewatching immediately, but\n      // deliberately don't send a resume token so that we get a full update.\n      this.sendUnwatchRequest(targetId);\n\n      // Mark the target we send as being on behalf of an existence filter\n      // mismatch, but don't actually retain that in listenTargets. This ensures\n      // that we flag the first re-listen this way without impacting future\n      // listens of this target (that might happen e.g. on reconnect).\n      const requestTargetData = new TargetData(\n        targetData.target,\n        targetId,\n        TargetPurpose.ExistenceFilterMismatch,\n        targetData.sequenceNumber\n      );\n      this.sendWatchRequest(requestTargetData);\n    });\n\n    // Finally raise remote event\n    return this.syncEngine.applyRemoteEvent(remoteEvent);\n  }\n\n  /** Handles an error on a target */\n  private async handleTargetError(\n    watchChange: WatchTargetChange\n  ): Promise<void> {\n    debugAssert(!!watchChange.cause, 'Handling target error without a cause');\n    const error = watchChange.cause!;\n    for (const targetId of watchChange.targetIds) {\n      // A watched target might have been removed already.\n      if (this.listenTargets.has(targetId)) {\n        await this.syncEngine.rejectListen(targetId, error);\n        this.listenTargets.delete(targetId);\n        this.watchChangeAggregator!.removeTarget(targetId);\n      }\n    }\n  }\n\n  /**\n   * Attempts to fill our write pipeline with writes from the LocalStore.\n   *\n   * Called internally to bootstrap or refill the write pipeline and by\n   * SyncEngine whenever there are new mutations to process.\n   *\n   * Starts the write stream if necessary.\n   */\n  async fillWritePipeline(): Promise<void> {\n    let lastBatchIdRetrieved =\n      this.writePipeline.length > 0\n        ? this.writePipeline[this.writePipeline.length - 1].batchId\n        : BATCHID_UNKNOWN;\n\n    while (this.canAddToWritePipeline()) {\n      try {\n        const batch = await this.localStore.nextMutationBatch(\n          lastBatchIdRetrieved\n        );\n\n        if (batch === null) {\n          if (this.writePipeline.length === 0) {\n            this.writeStream.markIdle();\n          }\n          break;\n        } else {\n          lastBatchIdRetrieved = batch.batchId;\n          this.addToWritePipeline(batch);\n        }\n      } catch (e) {\n        await this.disableNetworkUntilRecovery(e);\n      }\n    }\n\n    if (this.shouldStartWriteStream()) {\n      this.startWriteStream();\n    }\n  }\n\n  /**\n   * Returns true if we can add to the write pipeline (i.e. the network is\n   * enabled and the write pipeline is not full).\n   */\n  private canAddToWritePipeline(): boolean {\n    return (\n      this.canUseNetwork() && this.writePipeline.length < MAX_PENDING_WRITES\n    );\n  }\n\n  // For testing\n  outstandingWrites(): number {\n    return this.writePipeline.length;\n  }\n\n  /**\n   * Queues additional writes to be sent to the write stream, sending them\n   * immediately if the write stream is established.\n   */\n  private addToWritePipeline(batch: MutationBatch): void {\n    debugAssert(\n      this.canAddToWritePipeline(),\n      'addToWritePipeline called when pipeline is full'\n    );\n    this.writePipeline.push(batch);\n\n    if (this.writeStream.isOpen() && this.writeStream.handshakeComplete) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  }\n\n  private shouldStartWriteStream(): boolean {\n    return (\n      this.canUseNetwork() &&\n      !this.writeStream.isStarted() &&\n      this.writePipeline.length > 0\n    );\n  }\n\n  private startWriteStream(): void {\n    debugAssert(\n      this.shouldStartWriteStream(),\n      'startWriteStream() called when shouldStartWriteStream() is false.'\n    );\n    this.writeStream.start();\n  }\n\n  private async onWriteStreamOpen(): Promise<void> {\n    this.writeStream.writeHandshake();\n  }\n\n  private async onWriteHandshakeComplete(): Promise<void> {\n    // Send the write pipeline now that the stream is established.\n    for (const batch of this.writePipeline) {\n      this.writeStream.writeMutations(batch.mutations);\n    }\n  }\n\n  private async onMutationResult(\n    commitVersion: SnapshotVersion,\n    results: MutationResult[]\n  ): Promise<void> {\n    // This is a response to a write containing mutations and should be\n    // correlated to the first write in our write pipeline.\n    debugAssert(\n      this.writePipeline.length > 0,\n      'Got result for empty write pipeline'\n    );\n    const batch = this.writePipeline.shift()!;\n    const success = MutationBatchResult.from(batch, commitVersion, results);\n\n    await this.executeWithRecovery(() =>\n      this.syncEngine.applySuccessfulWrite(success)\n    );\n\n    // It's possible that with the completion of this mutation another\n    // slot has freed up.\n    await this.fillWritePipeline();\n  }\n\n  private async onWriteStreamClose(error?: FirestoreError): Promise<void> {\n    if (error === undefined) {\n      // Graceful stop (due to stop() or idle timeout). Make sure that's\n      // desirable.\n      debugAssert(\n        !this.shouldStartWriteStream(),\n        'Write stream was stopped gracefully while still needed.'\n      );\n    }\n\n    // If the write stream closed after the write handshake completes, a write\n    // operation failed and we fail the pending operation.\n    if (error && this.writeStream.handshakeComplete) {\n      // This error affects the actual write.\n      await this.handleWriteError(error!);\n    }\n\n    // The write stream might have been started by refilling the write\n    // pipeline for failed writes\n    if (this.shouldStartWriteStream()) {\n      this.startWriteStream();\n    }\n  }\n\n  private async handleWriteError(error: FirestoreError): Promise<void> {\n    // Only handle permanent errors here. If it's transient, just let the retry\n    // logic kick in.\n    if (isPermanentWriteError(error.code)) {\n      // This was a permanent error, the request itself was the problem\n      // so it's not going to succeed if we resend it.\n      const batch = this.writePipeline.shift()!;\n\n      // In this case it's also unlikely that the server itself is melting\n      // down -- this was just a bad request so inhibit backoff on the next\n      // restart.\n      this.writeStream.inhibitBackoff();\n\n      await this.executeWithRecovery(() =>\n        this.syncEngine.rejectFailedWrite(batch.batchId, error)\n      );\n\n      // It's possible that with the completion of this mutation\n      // another slot has freed up.\n      await this.fillWritePipeline();\n    } else {\n      // Transient error, just let the retry logic kick in.\n    }\n  }\n\n  createTransaction(): Transaction {\n    return new Transaction(this.datastore);\n  }\n\n  private async restartNetwork(): Promise<void> {\n    this.networkEnabled = false;\n    await this.disableNetworkInternal();\n    this.onlineStateTracker.set(OnlineState.Unknown);\n    await this.enableNetwork();\n  }\n\n  async handleCredentialChange(): Promise<void> {\n    if (this.canUseNetwork()) {\n      // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n      // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n      // (since mutations are per-user).\n      logDebug(LOG_TAG, 'RemoteStore restarting streams for new credential');\n      await this.restartNetwork();\n    }\n  }\n\n  /**\n   * Toggles the network state when the client gains or loses its primary lease.\n   */\n  async applyPrimaryState(isPrimary: boolean): Promise<void> {\n    this.isPrimary = isPrimary;\n\n    if (isPrimary && this.networkEnabled) {\n      await this.enableNetwork();\n    } else if (!isPrimary) {\n      await this.disableNetworkInternal();\n      this.onlineStateTracker.set(OnlineState.Unknown);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from '../util/assert';\nimport { EventHandler } from '../util/misc';\nimport { ObjectMap } from '../util/obj_map';\nimport { Query } from './query';\nimport { SyncEngine, SyncEngineListener } from './sync_engine';\nimport { OnlineState } from './types';\nimport { ChangeType, DocumentViewChange, ViewSnapshot } from './view_snapshot';\nimport { wrapInUserErrorIfRecoverable } from '../util/async_queue';\n\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nclass QueryListenersInfo {\n  viewSnap: ViewSnapshot | undefined = undefined;\n  listeners: QueryListener[] = [];\n}\n\n/**\n * Interface for handling events from the EventManager.\n */\nexport interface Observer<T> {\n  next: EventHandler<T>;\n  error: EventHandler<Error>;\n}\n\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nexport class EventManager implements SyncEngineListener {\n  private queries = new ObjectMap<Query, QueryListenersInfo>(q =>\n    q.canonicalId()\n  );\n\n  private onlineState = OnlineState.Unknown;\n\n  private snapshotsInSyncListeners: Set<Observer<void>> = new Set();\n\n  constructor(private syncEngine: SyncEngine) {\n    this.syncEngine.subscribe(this);\n  }\n\n  async listen(listener: QueryListener): Promise<void> {\n    const query = listener.query;\n    let firstListen = false;\n\n    let queryInfo = this.queries.get(query);\n    if (!queryInfo) {\n      firstListen = true;\n      queryInfo = new QueryListenersInfo();\n    }\n\n    if (firstListen) {\n      try {\n        queryInfo.viewSnap = await this.syncEngine.listen(query);\n      } catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(\n          e,\n          `Initialization of query '${listener.query}' failed`\n        );\n        listener.onError(firestoreError);\n        return;\n      }\n    }\n\n    this.queries.set(query, queryInfo);\n    queryInfo.listeners.push(listener);\n\n    // Run global snapshot listeners if a consistent snapshot has been emitted.\n    const raisedEvent = listener.applyOnlineStateChange(this.onlineState);\n    debugAssert(\n      !raisedEvent,\n      \"applyOnlineStateChange() shouldn't raise an event for brand-new listeners.\"\n    );\n\n    if (queryInfo.viewSnap) {\n      const raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);\n      if (raisedEvent) {\n        this.raiseSnapshotsInSyncEvent();\n      }\n    }\n  }\n\n  async unlisten(listener: QueryListener): Promise<void> {\n    const query = listener.query;\n    let lastListen = false;\n\n    const queryInfo = this.queries.get(query);\n    if (queryInfo) {\n      const i = queryInfo.listeners.indexOf(listener);\n      if (i >= 0) {\n        queryInfo.listeners.splice(i, 1);\n        lastListen = queryInfo.listeners.length === 0;\n      }\n    }\n\n    if (lastListen) {\n      this.queries.delete(query);\n      return this.syncEngine.unlisten(query);\n    }\n  }\n\n  onWatchChange(viewSnaps: ViewSnapshot[]): void {\n    let raisedEvent = false;\n    for (const viewSnap of viewSnaps) {\n      const query = viewSnap.query;\n      const queryInfo = this.queries.get(query);\n      if (queryInfo) {\n        for (const listener of queryInfo.listeners) {\n          if (listener.onViewSnapshot(viewSnap)) {\n            raisedEvent = true;\n          }\n        }\n        queryInfo.viewSnap = viewSnap;\n      }\n    }\n    if (raisedEvent) {\n      this.raiseSnapshotsInSyncEvent();\n    }\n  }\n\n  onWatchError(query: Query, error: Error): void {\n    const queryInfo = this.queries.get(query);\n    if (queryInfo) {\n      for (const listener of queryInfo.listeners) {\n        listener.onError(error);\n      }\n    }\n\n    // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n    // after an error.\n    this.queries.delete(query);\n  }\n\n  onOnlineStateChange(onlineState: OnlineState): void {\n    this.onlineState = onlineState;\n    let raisedEvent = false;\n    this.queries.forEach((_, queryInfo) => {\n      for (const listener of queryInfo.listeners) {\n        // Run global snapshot listeners if a consistent snapshot has been emitted.\n        if (listener.applyOnlineStateChange(onlineState)) {\n          raisedEvent = true;\n        }\n      }\n    });\n    if (raisedEvent) {\n      this.raiseSnapshotsInSyncEvent();\n    }\n  }\n\n  addSnapshotsInSyncListener(observer: Observer<void>): void {\n    this.snapshotsInSyncListeners.add(observer);\n    // Immediately fire an initial event, indicating all existing listeners\n    // are in-sync.\n    observer.next();\n  }\n\n  removeSnapshotsInSyncListener(observer: Observer<void>): void {\n    this.snapshotsInSyncListeners.delete(observer);\n  }\n\n  // Call all global snapshot listeners that have been set.\n  private raiseSnapshotsInSyncEvent(): void {\n    this.snapshotsInSyncListeners.forEach(observer => {\n      observer.next();\n    });\n  }\n}\n\nexport interface ListenOptions {\n  /** Raise events even when only the metadata changes */\n  readonly includeMetadataChanges?: boolean;\n\n  /**\n   * Wait for a sync with the server when online, but still raise events while\n   * offline.\n   */\n  readonly waitForSyncWhenOnline?: boolean;\n}\n\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nexport class QueryListener {\n  /**\n   * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n   * observer. This flag is set to true once we've actually raised an event.\n   */\n  private raisedInitialEvent = false;\n\n  private options: ListenOptions;\n\n  private snap: ViewSnapshot | null = null;\n\n  private onlineState = OnlineState.Unknown;\n\n  constructor(\n    readonly query: Query,\n    private queryObserver: Observer<ViewSnapshot>,\n    options?: ListenOptions\n  ) {\n    this.options = options || {};\n  }\n\n  /**\n   * Applies the new ViewSnapshot to this listener, raising a user-facing event\n   * if applicable (depending on what changed, whether the user has opted into\n   * metadata-only changes, etc.). Returns true if a user-facing event was\n   * indeed raised.\n   */\n  onViewSnapshot(snap: ViewSnapshot): boolean {\n    debugAssert(\n      snap.docChanges.length > 0 || snap.syncStateChanged,\n      'We got a new snapshot with no changes?'\n    );\n\n    if (!this.options.includeMetadataChanges) {\n      // Remove the metadata only changes.\n      const docChanges: DocumentViewChange[] = [];\n      for (const docChange of snap.docChanges) {\n        if (docChange.type !== ChangeType.Metadata) {\n          docChanges.push(docChange);\n        }\n      }\n      snap = new ViewSnapshot(\n        snap.query,\n        snap.docs,\n        snap.oldDocs,\n        docChanges,\n        snap.mutatedKeys,\n        snap.fromCache,\n        snap.syncStateChanged,\n        /* excludesMetadataChanges= */ true\n      );\n    }\n    let raisedEvent = false;\n    if (!this.raisedInitialEvent) {\n      if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n        this.raiseInitialEvent(snap);\n        raisedEvent = true;\n      }\n    } else if (this.shouldRaiseEvent(snap)) {\n      this.queryObserver.next(snap);\n      raisedEvent = true;\n    }\n\n    this.snap = snap;\n    return raisedEvent;\n  }\n\n  onError(error: Error): void {\n    this.queryObserver.error(error);\n  }\n\n  /** Returns whether a snapshot was raised. */\n  applyOnlineStateChange(onlineState: OnlineState): boolean {\n    this.onlineState = onlineState;\n    let raisedEvent = false;\n    if (\n      this.snap &&\n      !this.raisedInitialEvent &&\n      this.shouldRaiseInitialEvent(this.snap, onlineState)\n    ) {\n      this.raiseInitialEvent(this.snap);\n      raisedEvent = true;\n    }\n    return raisedEvent;\n  }\n\n  private shouldRaiseInitialEvent(\n    snap: ViewSnapshot,\n    onlineState: OnlineState\n  ): boolean {\n    debugAssert(\n      !this.raisedInitialEvent,\n      'Determining whether to raise first event but already had first event'\n    );\n\n    // Always raise the first event when we're synced\n    if (!snap.fromCache) {\n      return true;\n    }\n\n    // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n    // or Online if we wait long enough).\n    const maybeOnline = onlineState !== OnlineState.Offline;\n    // Don't raise the event if we're online, aren't synced yet (checked\n    // above) and are waiting for a sync.\n    if (this.options.waitForSyncWhenOnline && maybeOnline) {\n      debugAssert(\n        snap.fromCache,\n        'Waiting for sync, but snapshot is not from cache'\n      );\n      return false;\n    }\n\n    // Raise data from cache if we have any documents or we are offline\n    return !snap.docs.isEmpty() || onlineState === OnlineState.Offline;\n  }\n\n  private shouldRaiseEvent(snap: ViewSnapshot): boolean {\n    // We don't need to handle includeDocumentMetadataChanges here because\n    // the Metadata only changes have already been stripped out if needed.\n    // At this point the only changes we will see are the ones we should\n    // propagate.\n    if (snap.docChanges.length > 0) {\n      return true;\n    }\n\n    const hasPendingWritesChanged =\n      this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n    if (snap.syncStateChanged || hasPendingWritesChanged) {\n      return this.options.includeMetadataChanges === true;\n    }\n\n    // Generally we should have hit one of the cases above, but it's possible\n    // to get here if there were only metadata docChanges and they got\n    // stripped out.\n    return false;\n  }\n\n  private raiseInitialEvent(snap: ViewSnapshot): void {\n    debugAssert(\n      !this.raisedInitialEvent,\n      'Trying to raise initial events for second time'\n    );\n    snap = ViewSnapshot.fromInitialDocuments(\n      snap.query,\n      snap.docs,\n      snap.mutatedKeys,\n      snap.fromCache\n    );\n    this.raisedInitialEvent = true;\n    this.queryObserver.next(snap);\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { QueryEngine } from './query_engine';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { LimitType, Query } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport {\n  DocumentKeySet,\n  DocumentMap,\n  MaybeDocumentMap\n} from '../model/collections';\nimport { Document } from '../model/document';\nimport { debugAssert } from '../util/assert';\nimport { getLogLevel, LogLevel, logDebug } from '../util/log';\nimport { SortedSet } from '../util/sorted_set';\n\n// TOOD(b/140938512): Drop SimpleQueryEngine and rename IndexFreeQueryEngine.\n\n/**\n * A query engine that takes advantage of the target document mapping in the\n * QueryCache. The IndexFreeQueryEngine optimizes query execution by only\n * reading the documents that previously matched a query plus any documents that were\n * edited after the query was last listened to.\n *\n * There are some cases where Index-Free queries are not guaranteed to produce\n * the same results as full collection scans. In these cases, the\n * IndexFreeQueryEngine falls back to full query processing. These cases are:\n *\n * - Limit queries where a document that matched the query previously no longer\n *   matches the query.\n *\n * - Limit queries where a document edit may cause the document to sort below\n *   another document that is in the local cache.\n *\n * - Queries that have never been CURRENT or free of Limbo documents.\n */\nexport class IndexFreeQueryEngine implements QueryEngine {\n  private localDocumentsView: LocalDocumentsView | undefined;\n\n  setLocalDocumentsView(localDocuments: LocalDocumentsView): void {\n    this.localDocumentsView = localDocuments;\n  }\n\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query,\n    lastLimboFreeSnapshotVersion: SnapshotVersion,\n    remoteKeys: DocumentKeySet\n  ): PersistencePromise<DocumentMap> {\n    debugAssert(\n      this.localDocumentsView !== undefined,\n      'setLocalDocumentsView() not called'\n    );\n\n    // Queries that match all documents don't benefit from using\n    // IndexFreeQueries. It is more efficient to scan all documents in a\n    // collection, rather than to perform individual lookups.\n    if (query.matchesAllDocuments()) {\n      return this.executeFullCollectionScan(transaction, query);\n    }\n\n    // Queries that have never seen a snapshot without limbo free documents\n    // should also be run as a full collection scan.\n    if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {\n      return this.executeFullCollectionScan(transaction, query);\n    }\n\n    return this.localDocumentsView!.getDocuments(transaction, remoteKeys).next(\n      documents => {\n        const previousResults = this.applyQuery(query, documents);\n\n        if (\n          (query.hasLimitToFirst() || query.hasLimitToLast()) &&\n          this.needsRefill(\n            query.limitType,\n            previousResults,\n            remoteKeys,\n            lastLimboFreeSnapshotVersion\n          )\n        ) {\n          return this.executeFullCollectionScan(transaction, query);\n        }\n\n        if (getLogLevel() <= LogLevel.DEBUG) {\n          logDebug(\n            'IndexFreeQueryEngine',\n            'Re-using previous result from %s to execute query: %s',\n            lastLimboFreeSnapshotVersion.toString(),\n            query.toString()\n          );\n        }\n\n        // Retrieve all results for documents that were updated since the last\n        // limbo-document free remote snapshot.\n        return this.localDocumentsView!.getDocumentsMatchingQuery(\n          transaction,\n          query,\n          lastLimboFreeSnapshotVersion\n        ).next(updatedResults => {\n          // We merge `previousResults` into `updateResults`, since\n          // `updateResults` is already a DocumentMap. If a document is\n          // contained in both lists, then its contents are the same.\n          previousResults.forEach(doc => {\n            updatedResults = updatedResults.insert(doc.key, doc);\n          });\n          return updatedResults;\n        });\n      }\n    );\n  }\n\n  /** Applies the query filter and sorting to the provided documents.  */\n  private applyQuery(\n    query: Query,\n    documents: MaybeDocumentMap\n  ): SortedSet<Document> {\n    // Sort the documents and re-apply the query filter since previously\n    // matching documents do not necessarily still match the query.\n    let queryResults = new SortedSet<Document>((d1, d2) =>\n      query.docComparator(d1, d2)\n    );\n    documents.forEach((_, maybeDoc) => {\n      if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n        queryResults = queryResults.add(maybeDoc);\n      }\n    });\n    return queryResults;\n  }\n\n  /**\n   * Determines if a limit query needs to be refilled from cache, making it\n   * ineligible for index-free execution.\n   *\n   * @param sortedPreviousResults The documents that matched the query when it\n   * was last synchronized, sorted by the query's comparator.\n   * @param remoteKeys The document keys that matched the query at the last\n   * snapshot.\n   * @param limboFreeSnapshotVersion The version of the snapshot when the query\n   * was last synchronized.\n   */\n  private needsRefill(\n    limitType: LimitType,\n    sortedPreviousResults: SortedSet<Document>,\n    remoteKeys: DocumentKeySet,\n    limboFreeSnapshotVersion: SnapshotVersion\n  ): boolean {\n    // The query needs to be refilled if a previously matching document no\n    // longer matches.\n    if (remoteKeys.size !== sortedPreviousResults.size) {\n      return true;\n    }\n\n    // Limit queries are not eligible for index-free query execution if there is\n    // a potential that an older document from cache now sorts before a document\n    // that was previously part of the limit. This, however, can only happen if\n    // the document at the edge of the limit goes out of limit.\n    // If a document that is not the limit boundary sorts differently,\n    // the boundary of the limit itself did not change and documents from cache\n    // will continue to be \"rejected\" by this boundary. Therefore, we can ignore\n    // any modifications that don't affect the last document.\n    const docAtLimitEdge =\n      limitType === LimitType.First\n        ? sortedPreviousResults.last()\n        : sortedPreviousResults.first();\n    if (!docAtLimitEdge) {\n      // We don't need to refill the query if there were already no documents.\n      return false;\n    }\n    return (\n      docAtLimitEdge.hasPendingWrites ||\n      docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0\n    );\n  }\n\n  private executeFullCollectionScan(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<DocumentMap> {\n    if (getLogLevel() <= LogLevel.DEBUG) {\n      logDebug(\n        'IndexFreeQueryEngine',\n        'Using full collection scan to execute query:',\n        query.toString()\n      );\n    }\n\n    return this.localDocumentsView!.getDocumentsMatchingQuery(\n      transaction,\n      query,\n      SnapshotVersion.min()\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Timestamp } from '../api/timestamp';\nimport { Query } from '../core/query';\nimport { BatchId } from '../core/types';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { MutationBatch, BATCHID_UNKNOWN } from '../model/mutation_batch';\nimport { debugAssert, hardAssert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedMap } from '../util/sorted_map';\nimport { SortedSet } from '../util/sorted_set';\n\nimport { IndexManager } from './index_manager';\nimport { MutationQueue } from './mutation_queue';\nimport { PersistenceTransaction, ReferenceDelegate } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\n\nexport class MemoryMutationQueue implements MutationQueue {\n  /**\n   * The set of all mutations that have been sent but not yet been applied to\n   * the backend.\n   */\n  private mutationQueue: MutationBatch[] = [];\n\n  /** Next value to use when assigning sequential IDs to each mutation batch. */\n  private nextBatchId: BatchId = 1;\n\n  /** An ordered mapping between documents and the mutations batch IDs. */\n  private batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n\n  constructor(\n    private readonly indexManager: IndexManager,\n    private readonly referenceDelegate: ReferenceDelegate\n  ) {}\n\n  checkEmpty(transaction: PersistenceTransaction): PersistencePromise<boolean> {\n    return PersistencePromise.resolve(this.mutationQueue.length === 0);\n  }\n\n  addMutationBatch(\n    transaction: PersistenceTransaction,\n    localWriteTime: Timestamp,\n    baseMutations: Mutation[],\n    mutations: Mutation[]\n  ): PersistencePromise<MutationBatch> {\n    debugAssert(mutations.length !== 0, 'Mutation batches should not be empty');\n\n    const batchId = this.nextBatchId;\n    this.nextBatchId++;\n\n    if (this.mutationQueue.length > 0) {\n      const prior = this.mutationQueue[this.mutationQueue.length - 1];\n      debugAssert(\n        prior.batchId < batchId,\n        'Mutation batchIDs must be monotonically increasing order'\n      );\n    }\n\n    const batch = new MutationBatch(\n      batchId,\n      localWriteTime,\n      baseMutations,\n      mutations\n    );\n    this.mutationQueue.push(batch);\n\n    // Track references by document key and index collection parents.\n    for (const mutation of mutations) {\n      this.batchesByDocumentKey = this.batchesByDocumentKey.add(\n        new DocReference(mutation.key, batchId)\n      );\n\n      this.indexManager.addToCollectionParentIndex(\n        transaction,\n        mutation.key.path.popLast()\n      );\n    }\n\n    return PersistencePromise.resolve(batch);\n  }\n\n  lookupMutationBatch(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    return PersistencePromise.resolve(this.findMutationBatch(batchId));\n  }\n\n  getNextMutationBatchAfterBatchId(\n    transaction: PersistenceTransaction,\n    batchId: BatchId\n  ): PersistencePromise<MutationBatch | null> {\n    const nextBatchId = batchId + 1;\n\n    // The requested batchId may still be out of range so normalize it to the\n    // start of the queue.\n    const rawIndex = this.indexOfBatchId(nextBatchId);\n    const index = rawIndex < 0 ? 0 : rawIndex;\n    return PersistencePromise.resolve(\n      this.mutationQueue.length > index ? this.mutationQueue[index] : null\n    );\n  }\n\n  getHighestUnacknowledgedBatchId(): PersistencePromise<BatchId> {\n    return PersistencePromise.resolve(\n      this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1\n    );\n  }\n\n  getAllMutationBatches(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<MutationBatch[]> {\n    return PersistencePromise.resolve(this.mutationQueue.slice());\n  }\n\n  getAllMutationBatchesAffectingDocumentKey(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MutationBatch[]> {\n    const start = new DocReference(documentKey, 0);\n    const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n    const result: MutationBatch[] = [];\n    this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n      debugAssert(\n        documentKey.isEqual(ref.key),\n        \"Should only iterate over a single key's batches\"\n      );\n      const batch = this.findMutationBatch(ref.targetOrBatchId);\n      debugAssert(\n        batch !== null,\n        'Batches in the index must exist in the main table'\n      );\n      result.push(batch!);\n    });\n\n    return PersistencePromise.resolve(result);\n  }\n\n  getAllMutationBatchesAffectingDocumentKeys(\n    transaction: PersistenceTransaction,\n    documentKeys: SortedMap<DocumentKey, unknown>\n  ): PersistencePromise<MutationBatch[]> {\n    let uniqueBatchIDs = new SortedSet<number>(primitiveComparator);\n\n    documentKeys.forEach(documentKey => {\n      const start = new DocReference(documentKey, 0);\n      const end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n      this.batchesByDocumentKey.forEachInRange([start, end], ref => {\n        debugAssert(\n          documentKey.isEqual(ref.key),\n          \"For each key, should only iterate over a single key's batches\"\n        );\n\n        uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n      });\n    });\n\n    return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n  }\n\n  getAllMutationBatchesAffectingQuery(\n    transaction: PersistenceTransaction,\n    query: Query\n  ): PersistencePromise<MutationBatch[]> {\n    debugAssert(\n      !query.isCollectionGroupQuery(),\n      'CollectionGroup queries should be handled in LocalDocumentsView'\n    );\n    // Use the query path as a prefix for testing if a document matches the\n    // query.\n    const prefix = query.path;\n    const immediateChildrenPathLength = prefix.length + 1;\n\n    // Construct a document reference for actually scanning the index. Unlike\n    // the prefix the document key in this reference must have an even number of\n    // segments. The empty segment can be used a suffix of the query path\n    // because it precedes all other segments in an ordered traversal.\n    let startPath = prefix;\n    if (!DocumentKey.isDocumentKey(startPath)) {\n      startPath = startPath.child('');\n    }\n\n    const start = new DocReference(new DocumentKey(startPath), 0);\n\n    // Find unique batchIDs referenced by all documents potentially matching the\n    // query.\n    let uniqueBatchIDs = new SortedSet<number>(primitiveComparator);\n\n    this.batchesByDocumentKey.forEachWhile(ref => {\n      const rowKeyPath = ref.key.path;\n      if (!prefix.isPrefixOf(rowKeyPath)) {\n        return false;\n      } else {\n        // Rows with document keys more than one segment longer than the query\n        // path can't be matches. For example, a query on 'rooms' can't match\n        // the document /rooms/abc/messages/xyx.\n        // TODO(mcg): we'll need a different scanner when we implement\n        // ancestor queries.\n        if (rowKeyPath.length === immediateChildrenPathLength) {\n          uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n        }\n        return true;\n      }\n    }, start);\n\n    return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));\n  }\n\n  private findMutationBatches(batchIDs: SortedSet<number>): MutationBatch[] {\n    // Construct an array of matching batches, sorted by batchID to ensure that\n    // multiple mutations affecting the same document key are applied in order.\n    const result: MutationBatch[] = [];\n    batchIDs.forEach(batchId => {\n      const batch = this.findMutationBatch(batchId);\n      if (batch !== null) {\n        result.push(batch);\n      }\n    });\n    return result;\n  }\n\n  removeMutationBatch(\n    transaction: PersistenceTransaction,\n    batch: MutationBatch\n  ): PersistencePromise<void> {\n    // Find the position of the first batch for removal.\n    const batchIndex = this.indexOfExistingBatchId(batch.batchId, 'removed');\n    hardAssert(\n      batchIndex === 0,\n      'Can only remove the first entry of the mutation queue'\n    );\n    this.mutationQueue.shift();\n\n    let references = this.batchesByDocumentKey;\n    return PersistencePromise.forEach(batch.mutations, (mutation: Mutation) => {\n      const ref = new DocReference(mutation.key, batch.batchId);\n      references = references.delete(ref);\n      return this.referenceDelegate.markPotentiallyOrphaned(\n        transaction,\n        mutation.key\n      );\n    }).next(() => {\n      this.batchesByDocumentKey = references;\n    });\n  }\n\n  removeCachedMutationKeys(batchId: BatchId): void {\n    // No-op since the memory mutation queue does not maintain a separate cache.\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    const ref = new DocReference(key, 0);\n    const firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n    return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n  }\n\n  performConsistencyCheck(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    if (this.mutationQueue.length === 0) {\n      debugAssert(\n        this.batchesByDocumentKey.isEmpty(),\n        'Document leak -- detected dangling mutation references when queue is empty.'\n      );\n    }\n    return PersistencePromise.resolve();\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue and asserts that\n   * the resulting index is within the bounds of the queue.\n   *\n   * @param batchId The batchId to search for\n   * @param action A description of what the caller is doing, phrased in passive\n   * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n   */\n  private indexOfExistingBatchId(batchId: BatchId, action: string): number {\n    const index = this.indexOfBatchId(batchId);\n    debugAssert(\n      index >= 0 && index < this.mutationQueue.length,\n      'Batches must exist to be ' + action\n    );\n    return index;\n  }\n\n  /**\n   * Finds the index of the given batchId in the mutation queue. This operation\n   * is O(1).\n   *\n   * @return The computed index of the batch with the given batchId, based on\n   * the state of the queue. Note this index can be negative if the requested\n   * batchId has already been remvoed from the queue or past the end of the\n   * queue if the batchId is larger than the last added batch.\n   */\n  private indexOfBatchId(batchId: BatchId): number {\n    if (this.mutationQueue.length === 0) {\n      // As an index this is past the end of the queue\n      return 0;\n    }\n\n    // Examine the front of the queue to figure out the difference between the\n    // batchId and indexes in the array. Note that since the queue is ordered\n    // by batchId, if the first batch has a larger batchId then the requested\n    // batchId doesn't exist in the queue.\n    const firstBatchId = this.mutationQueue[0].batchId;\n    return batchId - firstBatchId;\n  }\n\n  /**\n   * A version of lookupMutationBatch that doesn't return a promise, this makes\n   * other functions that uses this code easier to read and more efficent.\n   */\n  private findMutationBatch(batchId: BatchId): MutationBatch | null {\n    const index = this.indexOfBatchId(batchId);\n    if (index < 0 || index >= this.mutationQueue.length) {\n      return null;\n    }\n\n    const batch = this.mutationQueue[index];\n    debugAssert(batch.batchId === batchId, 'If found batch must match');\n    return batch;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Query } from '../core/query';\nimport {\n  DocumentKeySet,\n  DocumentMap,\n  documentMap,\n  DocumentSizeEntry,\n  NullableMaybeDocumentMap,\n  nullableMaybeDocumentMap\n} from '../model/collections';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { debugAssert } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nimport { IndexManager } from './index_manager';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { RemoteDocumentCache } from './remote_document_cache';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\n\nexport type DocumentSizer = (doc: MaybeDocument) => number;\n\n/** Miscellaneous collection types / constants. */\ninterface MemoryRemoteDocumentCacheEntry extends DocumentSizeEntry {\n  readTime: SnapshotVersion;\n}\n\ntype DocumentEntryMap = SortedMap<DocumentKey, MemoryRemoteDocumentCacheEntry>;\nfunction documentEntryMap(): DocumentEntryMap {\n  return new SortedMap<DocumentKey, MemoryRemoteDocumentCacheEntry>(\n    DocumentKey.comparator\n  );\n}\n\nexport class MemoryRemoteDocumentCache implements RemoteDocumentCache {\n  /** Underlying cache of documents and their read times. */\n  private docs = documentEntryMap();\n\n  /** Size of all cached documents. */\n  private size = 0;\n\n  /**\n   * @param sizer Used to assess the size of a document. For eager GC, this is expected to just\n   * return 0 to avoid unnecessarily doing the work of calculating the size.\n   */\n  constructor(\n    private readonly indexManager: IndexManager,\n    private readonly sizer: DocumentSizer\n  ) {}\n\n  /**\n   * Adds the supplied entry to the cache and updates the cache size as appropriate.\n   *\n   * All calls of `addEntry`  are required to go through the RemoteDocumentChangeBuffer\n   * returned by `newChangeBuffer()`.\n   */\n  private addEntry(\n    transaction: PersistenceTransaction,\n    doc: MaybeDocument,\n    readTime: SnapshotVersion\n  ): PersistencePromise<void> {\n    debugAssert(\n      !readTime.isEqual(SnapshotVersion.min()),\n      'Cannot add a document with a read time of zero'\n    );\n\n    const key = doc.key;\n    const entry = this.docs.get(key);\n    const previousSize = entry ? entry.size : 0;\n    const currentSize = this.sizer(doc);\n\n    this.docs = this.docs.insert(key, {\n      maybeDocument: doc,\n      size: currentSize,\n      readTime\n    });\n\n    this.size += currentSize - previousSize;\n\n    return this.indexManager.addToCollectionParentIndex(\n      transaction,\n      key.path.popLast()\n    );\n  }\n\n  /**\n   * Removes the specified entry from the cache and updates the cache size as appropriate.\n   *\n   * All calls of `removeEntry` are required to go through the RemoteDocumentChangeBuffer\n   * returned by `newChangeBuffer()`.\n   */\n  private removeEntry(documentKey: DocumentKey): void {\n    const entry = this.docs.get(documentKey);\n    if (entry) {\n      this.docs = this.docs.remove(documentKey);\n      this.size -= entry.size;\n    }\n  }\n\n  getEntry(\n    transaction: PersistenceTransaction,\n    documentKey: DocumentKey\n  ): PersistencePromise<MaybeDocument | null> {\n    const entry = this.docs.get(documentKey);\n    return PersistencePromise.resolve(entry ? entry.maybeDocument : null);\n  }\n\n  getEntries(\n    transaction: PersistenceTransaction,\n    documentKeys: DocumentKeySet\n  ): PersistencePromise<NullableMaybeDocumentMap> {\n    let results = nullableMaybeDocumentMap();\n    documentKeys.forEach(documentKey => {\n      const entry = this.docs.get(documentKey);\n      results = results.insert(documentKey, entry ? entry.maybeDocument : null);\n    });\n    return PersistencePromise.resolve(results);\n  }\n\n  getDocumentsMatchingQuery(\n    transaction: PersistenceTransaction,\n    query: Query,\n    sinceReadTime: SnapshotVersion\n  ): PersistencePromise<DocumentMap> {\n    debugAssert(\n      !query.isCollectionGroupQuery(),\n      'CollectionGroup queries should be handled in LocalDocumentsView'\n    );\n    let results = documentMap();\n\n    // Documents are ordered by key, so we can use a prefix scan to narrow down\n    // the documents we need to match the query against.\n    const prefix = new DocumentKey(query.path.child(''));\n    const iterator = this.docs.getIteratorFrom(prefix);\n    while (iterator.hasNext()) {\n      const {\n        key,\n        value: { maybeDocument, readTime }\n      } = iterator.getNext();\n      if (!query.path.isPrefixOf(key.path)) {\n        break;\n      }\n      if (readTime.compareTo(sinceReadTime) <= 0) {\n        continue;\n      }\n      if (maybeDocument instanceof Document && query.matches(maybeDocument)) {\n        results = results.insert(maybeDocument.key, maybeDocument);\n      }\n    }\n    return PersistencePromise.resolve(results);\n  }\n\n  forEachDocumentKey(\n    transaction: PersistenceTransaction,\n    f: (key: DocumentKey) => PersistencePromise<void>\n  ): PersistencePromise<void> {\n    return PersistencePromise.forEach(this.docs, (key: DocumentKey) => f(key));\n  }\n\n  newChangeBuffer(options?: {\n    trackRemovals: boolean;\n  }): RemoteDocumentChangeBuffer {\n    // `trackRemovals` is ignores since the MemoryRemoteDocumentCache keeps\n    // a separate changelog and does not need special handling for removals.\n    return new MemoryRemoteDocumentCache.RemoteDocumentChangeBuffer(this);\n  }\n\n  getSize(txn: PersistenceTransaction): PersistencePromise<number> {\n    return PersistencePromise.resolve(this.size);\n  }\n\n  /**\n   * Handles the details of adding and updating documents in the MemoryRemoteDocumentCache.\n   */\n  private static RemoteDocumentChangeBuffer = class extends RemoteDocumentChangeBuffer {\n    constructor(private readonly documentCache: MemoryRemoteDocumentCache) {\n      super();\n    }\n\n    protected applyChanges(\n      transaction: PersistenceTransaction\n    ): PersistencePromise<void> {\n      const promises: Array<PersistencePromise<void>> = [];\n      this.changes.forEach((key, doc) => {\n        if (doc) {\n          promises.push(\n            this.documentCache.addEntry(transaction, doc, this.readTime)\n          );\n        } else {\n          this.documentCache.removeEntry(key);\n        }\n      });\n      return PersistencePromise.waitFor(promises);\n    }\n\n    protected getFromCache(\n      transaction: PersistenceTransaction,\n      documentKey: DocumentKey\n    ): PersistencePromise<MaybeDocument | null> {\n      return this.documentCache.getEntry(transaction, documentKey);\n    }\n\n    protected getAllFromCache(\n      transaction: PersistenceTransaction,\n      documentKeys: DocumentKeySet\n    ): PersistencePromise<NullableMaybeDocumentMap> {\n      return this.documentCache.getEntries(transaction, documentKeys);\n    }\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetIdGenerator } from '../core/target_id_generator';\nimport { ListenSequenceNumber, TargetId } from '../core/types';\nimport { DocumentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { debugAssert } from '../util/assert';\nimport { ObjectMap } from '../util/obj_map';\n\nimport { ActiveTargets } from './lru_garbage_collector';\nimport { MemoryPersistence } from './memory_persistence';\nimport { PersistenceTransaction } from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\nimport { TargetCache } from './target_cache';\nimport { TargetData } from './target_data';\nimport { Target } from '../core/target';\n\nexport class MemoryTargetCache implements TargetCache {\n  /**\n   * Maps a target to the data about that target\n   */\n  private targets = new ObjectMap<Target, TargetData>(t => t.canonicalId());\n\n  /** The last received snapshot version. */\n  private lastRemoteSnapshotVersion = SnapshotVersion.min();\n  /** The highest numbered target ID encountered. */\n  private highestTargetId: TargetId = 0;\n  /** The highest sequence number encountered. */\n  private highestSequenceNumber: ListenSequenceNumber = 0;\n  /**\n   * A ordered bidirectional mapping between documents and the remote target\n   * IDs.\n   */\n  private references = new ReferenceSet();\n\n  private targetCount = 0;\n\n  private targetIdGenerator = TargetIdGenerator.forTargetCache();\n\n  constructor(private readonly persistence: MemoryPersistence) {}\n\n  forEachTarget(\n    txn: PersistenceTransaction,\n    f: (q: TargetData) => void\n  ): PersistencePromise<void> {\n    this.targets.forEach((_, targetData) => f(targetData));\n    return PersistencePromise.resolve();\n  }\n\n  getLastRemoteSnapshotVersion(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<SnapshotVersion> {\n    return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);\n  }\n\n  getHighestSequenceNumber(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<ListenSequenceNumber> {\n    return PersistencePromise.resolve(this.highestSequenceNumber);\n  }\n\n  allocateTargetId(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<TargetId> {\n    this.highestTargetId = this.targetIdGenerator.next();\n    return PersistencePromise.resolve(this.highestTargetId);\n  }\n\n  setTargetsMetadata(\n    transaction: PersistenceTransaction,\n    highestListenSequenceNumber: number,\n    lastRemoteSnapshotVersion?: SnapshotVersion\n  ): PersistencePromise<void> {\n    if (lastRemoteSnapshotVersion) {\n      this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n    }\n    if (highestListenSequenceNumber > this.highestSequenceNumber) {\n      this.highestSequenceNumber = highestListenSequenceNumber;\n    }\n    return PersistencePromise.resolve();\n  }\n\n  private saveTargetData(targetData: TargetData): void {\n    this.targets.set(targetData.target, targetData);\n    const targetId = targetData.targetId;\n    if (targetId > this.highestTargetId) {\n      this.targetIdGenerator = new TargetIdGenerator(targetId);\n      this.highestTargetId = targetId;\n    }\n    if (targetData.sequenceNumber > this.highestSequenceNumber) {\n      this.highestSequenceNumber = targetData.sequenceNumber;\n    }\n  }\n\n  addTargetData(\n    transaction: PersistenceTransaction,\n    targetData: TargetData\n  ): PersistencePromise<void> {\n    debugAssert(\n      !this.targets.has(targetData.target),\n      'Adding a target that already exists'\n    );\n    this.saveTargetData(targetData);\n    this.targetCount += 1;\n    return PersistencePromise.resolve();\n  }\n\n  updateTargetData(\n    transaction: PersistenceTransaction,\n    targetData: TargetData\n  ): PersistencePromise<void> {\n    debugAssert(\n      this.targets.has(targetData.target),\n      'Updating a non-existent target'\n    );\n    this.saveTargetData(targetData);\n    return PersistencePromise.resolve();\n  }\n\n  removeTargetData(\n    transaction: PersistenceTransaction,\n    targetData: TargetData\n  ): PersistencePromise<void> {\n    debugAssert(this.targetCount > 0, 'Removing a target from an empty cache');\n    debugAssert(\n      this.targets.has(targetData.target),\n      'Removing a non-existent target from the cache'\n    );\n    this.targets.delete(targetData.target);\n    this.references.removeReferencesForId(targetData.targetId);\n    this.targetCount -= 1;\n    return PersistencePromise.resolve();\n  }\n\n  removeTargets(\n    transaction: PersistenceTransaction,\n    upperBound: ListenSequenceNumber,\n    activeTargetIds: ActiveTargets\n  ): PersistencePromise<number> {\n    let count = 0;\n    const removals: Array<PersistencePromise<void>> = [];\n    this.targets.forEach((key, targetData) => {\n      if (\n        targetData.sequenceNumber <= upperBound &&\n        activeTargetIds.get(targetData.targetId) === null\n      ) {\n        this.targets.delete(key);\n        removals.push(\n          this.removeMatchingKeysForTargetId(transaction, targetData.targetId)\n        );\n        count++;\n      }\n    });\n    return PersistencePromise.waitFor(removals).next(() => count);\n  }\n\n  getTargetCount(\n    transaction: PersistenceTransaction\n  ): PersistencePromise<number> {\n    return PersistencePromise.resolve(this.targetCount);\n  }\n\n  getTargetData(\n    transaction: PersistenceTransaction,\n    target: Target\n  ): PersistencePromise<TargetData | null> {\n    const targetData = this.targets.get(target) || null;\n    return PersistencePromise.resolve(targetData);\n  }\n\n  addMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.addReferences(keys, targetId);\n    return PersistencePromise.resolve();\n  }\n\n  removeMatchingKeys(\n    txn: PersistenceTransaction,\n    keys: DocumentKeySet,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.removeReferences(keys, targetId);\n    const referenceDelegate = this.persistence.referenceDelegate;\n    const promises: Array<PersistencePromise<void>> = [];\n    if (referenceDelegate) {\n      keys.forEach(key => {\n        promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));\n      });\n    }\n    return PersistencePromise.waitFor(promises);\n  }\n\n  removeMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<void> {\n    this.references.removeReferencesForId(targetId);\n    return PersistencePromise.resolve();\n  }\n\n  getMatchingKeysForTargetId(\n    txn: PersistenceTransaction,\n    targetId: TargetId\n  ): PersistencePromise<DocumentKeySet> {\n    const matchingKeys = this.references.referencesForId(targetId);\n    return PersistencePromise.resolve(matchingKeys);\n  }\n\n  containsKey(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    return PersistencePromise.resolve(this.references.containsKey(key));\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { Document, MaybeDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { logDebug } from '../util/log';\nimport { ObjectMap } from '../util/obj_map';\nimport { encodeResourcePath } from './encoded_resource_path';\nimport {\n  ActiveTargets,\n  LruDelegate,\n  LruGarbageCollector,\n  LruParams\n} from './lru_garbage_collector';\nimport { ListenSequence } from '../core/listen_sequence';\nimport { ListenSequenceNumber, TargetId } from '../core/types';\nimport { estimateByteSize } from '../model/values';\nimport { MemoryIndexManager } from './memory_index_manager';\nimport { MemoryMutationQueue } from './memory_mutation_queue';\nimport { MemoryRemoteDocumentCache } from './memory_remote_document_cache';\nimport { MemoryTargetCache } from './memory_target_cache';\nimport { MutationQueue } from './mutation_queue';\nimport {\n  Persistence,\n  PersistenceTransaction,\n  PersistenceTransactionMode,\n  ReferenceDelegate\n} from './persistence';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\nimport { TargetData } from './target_data';\n\nconst LOG_TAG = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nexport class MemoryPersistence implements Persistence {\n  /**\n   * Note that these are retained here to make it easier to write tests\n   * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n   * can create a new LocalStore wrapping this Persistence instance and this\n   * will make the in-memory persistence layer behave as if it were actually\n   * persisting values.\n   */\n  private readonly indexManager: MemoryIndexManager;\n  private mutationQueues: { [user: string]: MemoryMutationQueue } = {};\n  private readonly remoteDocumentCache: MemoryRemoteDocumentCache;\n  private readonly targetCache: MemoryTargetCache;\n  private readonly listenSequence = new ListenSequence(0);\n\n  private _started = false;\n\n  readonly referenceDelegate: MemoryReferenceDelegate;\n\n  /**\n   * The constructor accepts a factory for creating a reference delegate. This\n   * allows both the delegate and this instance to have strong references to\n   * each other without having nullable fields that would then need to be\n   * checked or asserted on every access.\n   */\n  constructor(\n    referenceDelegateFactory: (p: MemoryPersistence) => MemoryReferenceDelegate\n  ) {\n    this._started = true;\n    this.referenceDelegate = referenceDelegateFactory(this);\n    this.targetCache = new MemoryTargetCache(this);\n    const sizer = (doc: MaybeDocument): number =>\n      this.referenceDelegate.documentSize(doc);\n    this.indexManager = new MemoryIndexManager();\n    this.remoteDocumentCache = new MemoryRemoteDocumentCache(\n      this.indexManager,\n      sizer\n    );\n  }\n\n  start(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  shutdown(): Promise<void> {\n    // No durable state to ensure is closed on shutdown.\n    this._started = false;\n    return Promise.resolve();\n  }\n\n  get started(): boolean {\n    return this._started;\n  }\n\n  setDatabaseDeletedListener(): void {\n    // No op.\n  }\n\n  getIndexManager(): MemoryIndexManager {\n    return this.indexManager;\n  }\n\n  getMutationQueue(user: User): MutationQueue {\n    let queue = this.mutationQueues[user.toKey()];\n    if (!queue) {\n      queue = new MemoryMutationQueue(\n        this.indexManager,\n        this.referenceDelegate\n      );\n      this.mutationQueues[user.toKey()] = queue;\n    }\n    return queue;\n  }\n\n  getTargetCache(): MemoryTargetCache {\n    return this.targetCache;\n  }\n\n  getRemoteDocumentCache(): MemoryRemoteDocumentCache {\n    return this.remoteDocumentCache;\n  }\n\n  runTransaction<T>(\n    action: string,\n    mode: PersistenceTransactionMode,\n    transactionOperation: (\n      transaction: PersistenceTransaction\n    ) => PersistencePromise<T>\n  ): Promise<T> {\n    logDebug(LOG_TAG, 'Starting transaction:', action);\n    const txn = new MemoryTransaction(this.listenSequence.next());\n    this.referenceDelegate.onTransactionStarted();\n    return transactionOperation(txn)\n      .next(result => {\n        return this.referenceDelegate\n          .onTransactionCommitted(txn)\n          .next(() => result);\n      })\n      .toPromise()\n      .then(result => {\n        txn.raiseOnCommittedEvent();\n        return result;\n      });\n  }\n\n  mutationQueuesContainKey(\n    transaction: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    return PersistencePromise.or(\n      Object.values(this.mutationQueues).map(queue => () =>\n        queue.containsKey(transaction, key)\n      )\n    );\n  }\n}\n\n/**\n * Memory persistence is not actually transactional, but future implementations\n * may have transaction-scoped state.\n */\nexport class MemoryTransaction extends PersistenceTransaction {\n  constructor(readonly currentSequenceNumber: ListenSequenceNumber) {\n    super();\n  }\n}\n\nexport interface MemoryReferenceDelegate extends ReferenceDelegate {\n  documentSize(doc: MaybeDocument): number;\n  onTransactionStarted(): void;\n  onTransactionCommitted(txn: PersistenceTransaction): PersistencePromise<void>;\n}\n\nexport class MemoryEagerDelegate implements MemoryReferenceDelegate {\n  /** Tracks all documents that are active in Query views. */\n  private localViewReferences: ReferenceSet = new ReferenceSet();\n  /** The list of documents that are potentially GCed after each transaction. */\n  private _orphanedDocuments: Set<DocumentKey> | null = null;\n\n  private constructor(private readonly persistence: MemoryPersistence) {}\n\n  static factory(persistence: MemoryPersistence): MemoryEagerDelegate {\n    return new MemoryEagerDelegate(persistence);\n  }\n\n  private get orphanedDocuments(): Set<DocumentKey> {\n    if (!this._orphanedDocuments) {\n      throw fail('orphanedDocuments is only valid during a transaction.');\n    } else {\n      return this._orphanedDocuments;\n    }\n  }\n\n  addReference(\n    txn: PersistenceTransaction,\n    targetId: TargetId,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.localViewReferences.addReference(key, targetId);\n    this.orphanedDocuments.delete(key);\n    return PersistencePromise.resolve();\n  }\n\n  removeReference(\n    txn: PersistenceTransaction,\n    targetId: TargetId,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.localViewReferences.removeReference(key, targetId);\n    this.orphanedDocuments.add(key);\n    return PersistencePromise.resolve();\n  }\n\n  markPotentiallyOrphaned(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.orphanedDocuments.add(key);\n    return PersistencePromise.resolve();\n  }\n\n  removeTarget(\n    txn: PersistenceTransaction,\n    targetData: TargetData\n  ): PersistencePromise<void> {\n    const orphaned = this.localViewReferences.removeReferencesForId(\n      targetData.targetId\n    );\n    orphaned.forEach(key => this.orphanedDocuments.add(key));\n    const cache = this.persistence.getTargetCache();\n    return cache\n      .getMatchingKeysForTargetId(txn, targetData.targetId)\n      .next(keys => {\n        keys.forEach(key => this.orphanedDocuments.add(key));\n      })\n      .next(() => cache.removeTargetData(txn, targetData));\n  }\n\n  onTransactionStarted(): void {\n    this._orphanedDocuments = new Set<DocumentKey>();\n  }\n\n  onTransactionCommitted(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    // Remove newly orphaned documents.\n    const cache = this.persistence.getRemoteDocumentCache();\n    const changeBuffer = cache.newChangeBuffer();\n    return PersistencePromise.forEach(\n      this.orphanedDocuments,\n      (key: DocumentKey) => {\n        return this.isReferenced(txn, key).next(isReferenced => {\n          if (!isReferenced) {\n            changeBuffer.removeEntry(key);\n          }\n        });\n      }\n    ).next(() => {\n      this._orphanedDocuments = null;\n      return changeBuffer.apply(txn);\n    });\n  }\n\n  updateLimboDocument(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    return this.isReferenced(txn, key).next(isReferenced => {\n      if (isReferenced) {\n        this.orphanedDocuments.delete(key);\n      } else {\n        this.orphanedDocuments.add(key);\n      }\n    });\n  }\n\n  documentSize(doc: MaybeDocument): number {\n    // For eager GC, we don't care about the document size, there are no size thresholds.\n    return 0;\n  }\n\n  private isReferenced(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<boolean> {\n    return PersistencePromise.or([\n      () =>\n        PersistencePromise.resolve(this.localViewReferences.containsKey(key)),\n      () => this.persistence.getTargetCache().containsKey(txn, key),\n      () => this.persistence.mutationQueuesContainKey(txn, key)\n    ]);\n  }\n}\n\nexport class MemoryLruDelegate implements ReferenceDelegate, LruDelegate {\n  private orphanedSequenceNumbers: ObjectMap<\n    DocumentKey,\n    ListenSequenceNumber\n  > = new ObjectMap(k => encodeResourcePath(k.path));\n\n  readonly garbageCollector: LruGarbageCollector;\n\n  constructor(\n    private readonly persistence: MemoryPersistence,\n    lruParams: LruParams\n  ) {\n    this.garbageCollector = new LruGarbageCollector(this, lruParams);\n  }\n\n  // No-ops, present so memory persistence doesn't have to care which delegate\n  // it has.\n  onTransactionStarted(): void {}\n\n  onTransactionCommitted(\n    txn: PersistenceTransaction\n  ): PersistencePromise<void> {\n    return PersistencePromise.resolve();\n  }\n\n  forEachTarget(\n    txn: PersistenceTransaction,\n    f: (q: TargetData) => void\n  ): PersistencePromise<void> {\n    return this.persistence.getTargetCache().forEachTarget(txn, f);\n  }\n\n  getSequenceNumberCount(\n    txn: PersistenceTransaction\n  ): PersistencePromise<number> {\n    const docCountPromise = this.orphanedDocumentCount(txn);\n    const targetCountPromise = this.persistence\n      .getTargetCache()\n      .getTargetCount(txn);\n    return targetCountPromise.next(targetCount =>\n      docCountPromise.next(docCount => targetCount + docCount)\n    );\n  }\n\n  private orphanedDocumentCount(\n    txn: PersistenceTransaction\n  ): PersistencePromise<number> {\n    let orphanedCount = 0;\n    return this.forEachOrphanedDocumentSequenceNumber(txn, _ => {\n      orphanedCount++;\n    }).next(() => orphanedCount);\n  }\n\n  forEachOrphanedDocumentSequenceNumber(\n    txn: PersistenceTransaction,\n    f: (sequenceNumber: ListenSequenceNumber) => void\n  ): PersistencePromise<void> {\n    return PersistencePromise.forEach(\n      this.orphanedSequenceNumbers,\n      (key, sequenceNumber) => {\n        // Pass in the exact sequence number as the upper bound so we know it won't be pinned by\n        // being too recent.\n        return this.isPinned(txn, key, sequenceNumber).next(isPinned => {\n          if (!isPinned) {\n            return f(sequenceNumber);\n          } else {\n            return PersistencePromise.resolve();\n          }\n        });\n      }\n    );\n  }\n\n  removeTargets(\n    txn: PersistenceTransaction,\n    upperBound: ListenSequenceNumber,\n    activeTargetIds: ActiveTargets\n  ): PersistencePromise<number> {\n    return this.persistence\n      .getTargetCache()\n      .removeTargets(txn, upperBound, activeTargetIds);\n  }\n\n  removeOrphanedDocuments(\n    txn: PersistenceTransaction,\n    upperBound: ListenSequenceNumber\n  ): PersistencePromise<number> {\n    let count = 0;\n    const cache = this.persistence.getRemoteDocumentCache();\n    const changeBuffer = cache.newChangeBuffer();\n    const p = cache.forEachDocumentKey(txn, key => {\n      return this.isPinned(txn, key, upperBound).next(isPinned => {\n        if (!isPinned) {\n          count++;\n          changeBuffer.removeEntry(key);\n        }\n      });\n    });\n    return p.next(() => changeBuffer.apply(txn)).next(() => count);\n  }\n\n  markPotentiallyOrphaned(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n    return PersistencePromise.resolve();\n  }\n\n  removeTarget(\n    txn: PersistenceTransaction,\n    targetData: TargetData\n  ): PersistencePromise<void> {\n    const updated = targetData.withSequenceNumber(txn.currentSequenceNumber);\n    return this.persistence.getTargetCache().updateTargetData(txn, updated);\n  }\n\n  addReference(\n    txn: PersistenceTransaction,\n    targetId: TargetId,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n    return PersistencePromise.resolve();\n  }\n\n  removeReference(\n    txn: PersistenceTransaction,\n    targetId: TargetId,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n    return PersistencePromise.resolve();\n  }\n\n  updateLimboDocument(\n    txn: PersistenceTransaction,\n    key: DocumentKey\n  ): PersistencePromise<void> {\n    this.orphanedSequenceNumbers.set(key, txn.currentSequenceNumber);\n    return PersistencePromise.resolve();\n  }\n\n  documentSize(maybeDoc: MaybeDocument): number {\n    let documentSize = maybeDoc.key.toString().length;\n    if (maybeDoc instanceof Document) {\n      documentSize += estimateByteSize(maybeDoc.toProto());\n    }\n    return documentSize;\n  }\n\n  private isPinned(\n    txn: PersistenceTransaction,\n    key: DocumentKey,\n    upperBound: ListenSequenceNumber\n  ): PersistencePromise<boolean> {\n    return PersistencePromise.or([\n      () => this.persistence.mutationQueuesContainKey(txn, key),\n      () => this.persistence.getTargetCache().containsKey(txn, key),\n      () => {\n        const orphanedAt = this.orphanedSequenceNumbers.get(key);\n        return PersistencePromise.resolve(\n          orphanedAt !== undefined && orphanedAt > upperBound\n        );\n      }\n    ]);\n  }\n\n  getCacheSize(txn: PersistenceTransaction): PersistencePromise<number> {\n    return this.persistence.getRemoteDocumentCache().getSize(txn);\n  }\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ClientId,\n  MemorySharedClientState,\n  SharedClientState,\n  WebStorageSharedClientState\n} from '../local/shared_client_state';\nimport { LocalStore, MultiTabLocalStore } from '../local/local_store';\nimport { MultiTabSyncEngine, SyncEngine } from './sync_engine';\nimport { RemoteStore } from '../remote/remote_store';\nimport { EventManager } from './event_manager';\nimport { AsyncQueue } from '../util/async_queue';\nimport { DatabaseInfo } from './database_info';\nimport { Platform } from '../platform/platform';\nimport { Datastore } from '../remote/datastore';\nimport { User } from '../auth/user';\nimport { PersistenceSettings } from './firestore_client';\nimport { debugAssert } from '../util/assert';\nimport { GarbageCollectionScheduler, Persistence } from '../local/persistence';\nimport { Code, FirestoreError } from '../util/error';\nimport { OnlineStateSource } from './types';\nimport { LruParams, LruScheduler } from '../local/lru_garbage_collector';\nimport { IndexFreeQueryEngine } from '../local/index_free_query_engine';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport {\n  MemoryEagerDelegate,\n  MemoryPersistence\n} from '../local/memory_persistence';\n\nconst MEMORY_ONLY_PERSISTENCE_ERROR_MESSAGE =\n  'You are using the memory-only build of Firestore. Persistence support is ' +\n  'only available via the @firebase/firestore bundle or the ' +\n  'firebase-firestore.js build.';\n\nexport interface ComponentConfiguration {\n  asyncQueue: AsyncQueue;\n  databaseInfo: DatabaseInfo;\n  platform: Platform;\n  datastore: Datastore;\n  clientId: ClientId;\n  initialUser: User;\n  maxConcurrentLimboResolutions: number;\n  persistenceSettings: PersistenceSettings;\n}\n\n/**\n * Initializes and wires up all core components for Firestore. Implementations\n * override `initialize()` to provide all components.\n */\nexport interface ComponentProvider {\n  persistence: Persistence;\n  sharedClientState: SharedClientState;\n  localStore: LocalStore;\n  syncEngine: SyncEngine;\n  gcScheduler: GarbageCollectionScheduler | null;\n  remoteStore: RemoteStore;\n  eventManager: EventManager;\n\n  initialize(cfg: ComponentConfiguration): Promise<void>;\n\n  clearPersistence(databaseId: DatabaseInfo): Promise<void>;\n}\n\n/**\n * Provides all components needed for Firestore with in-memory persistence.\n * Uses EagerGC garbage collection.\n */\nexport class MemoryComponentProvider implements ComponentProvider {\n  persistence!: Persistence;\n  sharedClientState!: SharedClientState;\n  localStore!: LocalStore;\n  syncEngine!: SyncEngine;\n  gcScheduler!: GarbageCollectionScheduler | null;\n  remoteStore!: RemoteStore;\n  eventManager!: EventManager;\n\n  async initialize(cfg: ComponentConfiguration): Promise<void> {\n    this.sharedClientState = this.createSharedClientState(cfg);\n    this.persistence = this.createPersistence(cfg);\n    await this.persistence.start();\n    this.gcScheduler = this.createGarbageCollectionScheduler(cfg);\n    this.localStore = this.createLocalStore(cfg);\n    this.remoteStore = this.createRemoteStore(cfg);\n    this.syncEngine = this.createSyncEngine(cfg);\n    this.eventManager = this.createEventManager(cfg);\n\n    this.sharedClientState.onlineStateHandler = onlineState =>\n      this.syncEngine.applyOnlineStateChange(\n        onlineState,\n        OnlineStateSource.SharedClientState\n      );\n    this.remoteStore.syncEngine = this.syncEngine;\n\n    await this.localStore.start();\n    await this.sharedClientState.start();\n    await this.remoteStore.start();\n\n    await this.remoteStore.applyPrimaryState(this.syncEngine.isPrimaryClient);\n  }\n\n  createEventManager(cfg: ComponentConfiguration): EventManager {\n    return new EventManager(this.syncEngine);\n  }\n\n  createGarbageCollectionScheduler(\n    cfg: ComponentConfiguration\n  ): GarbageCollectionScheduler | null {\n    return null;\n  }\n\n  createLocalStore(cfg: ComponentConfiguration): LocalStore {\n    return new LocalStore(\n      this.persistence,\n      new IndexFreeQueryEngine(),\n      cfg.initialUser\n    );\n  }\n\n  createPersistence(cfg: ComponentConfiguration): Persistence {\n    if (cfg.persistenceSettings.durable) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        MEMORY_ONLY_PERSISTENCE_ERROR_MESSAGE\n      );\n    }\n    return new MemoryPersistence(MemoryEagerDelegate.factory);\n  }\n\n  createRemoteStore(cfg: ComponentConfiguration): RemoteStore {\n    return new RemoteStore(\n      this.localStore,\n      cfg.datastore,\n      cfg.asyncQueue,\n      onlineState =>\n        this.syncEngine.applyOnlineStateChange(\n          onlineState,\n          OnlineStateSource.RemoteStore\n        ),\n      cfg.platform.newConnectivityMonitor()\n    );\n  }\n\n  createSharedClientState(cfg: ComponentConfiguration): SharedClientState {\n    return new MemorySharedClientState();\n  }\n\n  createSyncEngine(cfg: ComponentConfiguration): SyncEngine {\n    return new SyncEngine(\n      this.localStore,\n      this.remoteStore,\n      cfg.datastore,\n      this.sharedClientState,\n      cfg.initialUser,\n      cfg.maxConcurrentLimboResolutions\n    );\n  }\n\n  clearPersistence(databaseInfo: DatabaseInfo): Promise<void> {\n    throw new FirestoreError(\n      Code.FAILED_PRECONDITION,\n      MEMORY_ONLY_PERSISTENCE_ERROR_MESSAGE\n    );\n  }\n}\n\n/**\n * Provides all components needed for Firestore with IndexedDB persistence.\n */\nexport class IndexedDbComponentProvider extends MemoryComponentProvider {\n  persistence!: IndexedDbPersistence;\n\n  // TODO(tree-shaking): Create an IndexedDbComponentProvider and a\n  // MultiTabComponentProvider. The IndexedDbComponentProvider should depend\n  // on LocalStore and SyncEngine.\n  localStore!: MultiTabLocalStore;\n  syncEngine!: MultiTabSyncEngine;\n\n  async initialize(cfg: ComponentConfiguration): Promise<void> {\n    await super.initialize(cfg);\n\n    // NOTE: This will immediately call the listener, so we make sure to\n    // set it after localStore / remoteStore are started.\n    await this.persistence.setPrimaryStateListener(async isPrimary => {\n      await (this.syncEngine as MultiTabSyncEngine).applyPrimaryState(\n        isPrimary\n      );\n      if (this.gcScheduler) {\n        if (isPrimary && !this.gcScheduler.started) {\n          this.gcScheduler.start(this.localStore);\n        } else if (!isPrimary) {\n          this.gcScheduler.stop();\n        }\n      }\n    });\n  }\n\n  createLocalStore(cfg: ComponentConfiguration): LocalStore {\n    return new MultiTabLocalStore(\n      this.persistence,\n      new IndexFreeQueryEngine(),\n      cfg.initialUser\n    );\n  }\n\n  createSyncEngine(cfg: ComponentConfiguration): SyncEngine {\n    const syncEngine = new MultiTabSyncEngine(\n      this.localStore,\n      this.remoteStore,\n      cfg.datastore,\n      this.sharedClientState,\n      cfg.initialUser,\n      cfg.maxConcurrentLimboResolutions\n    );\n    if (this.sharedClientState instanceof WebStorageSharedClientState) {\n      this.sharedClientState.syncEngine = syncEngine;\n    }\n    return syncEngine;\n  }\n\n  createGarbageCollectionScheduler(\n    cfg: ComponentConfiguration\n  ): GarbageCollectionScheduler | null {\n    const garbageCollector = this.persistence.referenceDelegate\n      .garbageCollector;\n    return new LruScheduler(garbageCollector, cfg.asyncQueue);\n  }\n\n  createPersistence(cfg: ComponentConfiguration): Persistence {\n    debugAssert(\n      cfg.persistenceSettings.durable,\n      'Can only start durable persistence'\n    );\n\n    const persistenceKey = IndexedDbPersistence.buildStoragePrefix(\n      cfg.databaseInfo\n    );\n    const serializer = cfg.platform.newSerializer(cfg.databaseInfo.databaseId);\n    return new IndexedDbPersistence(\n      cfg.persistenceSettings.synchronizeTabs,\n      persistenceKey,\n      cfg.clientId,\n      cfg.platform,\n      LruParams.withCacheSize(cfg.persistenceSettings.cacheSizeBytes),\n      cfg.asyncQueue,\n      serializer,\n      this.sharedClientState,\n      cfg.persistenceSettings.forceOwningTab\n    );\n  }\n\n  createSharedClientState(cfg: ComponentConfiguration): SharedClientState {\n    if (\n      cfg.persistenceSettings.durable &&\n      cfg.persistenceSettings.synchronizeTabs\n    ) {\n      if (!WebStorageSharedClientState.isAvailable(cfg.platform)) {\n        throw new FirestoreError(\n          Code.UNIMPLEMENTED,\n          'IndexedDB persistence is only available on platforms that support LocalStorage.'\n        );\n      }\n      const persistenceKey = IndexedDbPersistence.buildStoragePrefix(\n        cfg.databaseInfo\n      );\n      return new WebStorageSharedClientState(\n        cfg.asyncQueue,\n        cfg.platform,\n        persistenceKey,\n        cfg.clientId,\n        cfg.initialUser\n      );\n    }\n    return new MemorySharedClientState();\n  }\n\n  clearPersistence(databaseInfo: DatabaseInfo): Promise<void> {\n    const persistenceKey = IndexedDbPersistence.buildStoragePrefix(\n      databaseInfo\n    );\n    return IndexedDbPersistence.clearPersistence(persistenceKey);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CredentialsProvider } from '../api/credentials';\nimport { User } from '../auth/user';\nimport { LocalStore } from '../local/local_store';\nimport { GarbageCollectionScheduler, Persistence } from '../local/persistence';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { Mutation } from '../model/mutation';\nimport { Platform } from '../platform/platform';\nimport { newDatastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { AsyncQueue, wrapInUserErrorIfRecoverable } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { logDebug } from '../util/log';\nimport { Deferred } from '../util/promise';\nimport {\n  EventManager,\n  ListenOptions,\n  Observer,\n  QueryListener\n} from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { View } from './view';\n\nimport { SharedClientState } from '../local/shared_client_state';\nimport { AutoId } from '../util/misc';\nimport { DatabaseId, DatabaseInfo } from './database_info';\nimport { Query } from './query';\nimport { Transaction } from './transaction';\nimport { ViewSnapshot } from './view_snapshot';\nimport {\n  ComponentProvider,\n  MemoryComponentProvider\n} from './component_provider';\n\nconst LOG_TAG = 'FirestoreClient';\nconst MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;\n\n/** DOMException error code constants. */\nconst DOM_EXCEPTION_INVALID_STATE = 11;\nconst DOM_EXCEPTION_ABORTED = 20;\nconst DOM_EXCEPTION_QUOTA_EXCEEDED = 22;\n\nexport type PersistenceSettings =\n  | {\n      readonly durable: false;\n    }\n  | {\n      readonly durable: true;\n      readonly cacheSizeBytes: number;\n      readonly synchronizeTabs: boolean;\n      readonly forceOwningTab: boolean;\n    };\n\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nexport class FirestoreClient {\n  // NOTE: These should technically have '|undefined' in the types, since\n  // they're initialized asynchronously rather than in the constructor, but\n  // given that all work is done on the async queue and we assert that\n  // initialization completes before any other work is queued, we're cheating\n  // with the types rather than littering the code with '!' or unnecessary\n  // undefined checks.\n  private eventMgr!: EventManager;\n  private persistence!: Persistence;\n  private localStore!: LocalStore;\n  private remoteStore!: RemoteStore;\n  private syncEngine!: SyncEngine;\n  private gcScheduler!: GarbageCollectionScheduler | null;\n\n  // PORTING NOTE: SharedClientState is only used for multi-tab web.\n  private sharedClientState!: SharedClientState;\n\n  private readonly clientId = AutoId.newId();\n\n  constructor(\n    private platform: Platform,\n    private databaseInfo: DatabaseInfo,\n    private credentials: CredentialsProvider,\n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    private asyncQueue: AsyncQueue\n  ) {}\n\n  /**\n   * Starts up the FirestoreClient, returning only whether or not enabling\n   * persistence succeeded.\n   *\n   * The intent here is to \"do the right thing\" as far as users are concerned.\n   * Namely, in cases where offline persistence is requested and possible,\n   * enable it, but otherwise fall back to persistence disabled. For the most\n   * part we expect this to succeed one way or the other so we don't expect our\n   * users to actually wait on the firestore.enablePersistence Promise since\n   * they generally won't care.\n   *\n   * Of course some users actually do care about whether or not persistence\n   * was successfully enabled, so the Promise returned from this method\n   * indicates this outcome.\n   *\n   * This presents a problem though: even before enablePersistence resolves or\n   * rejects, users may have made calls to e.g. firestore.collection() which\n   * means that the FirestoreClient in there will be available and will be\n   * enqueuing actions on the async queue.\n   *\n   * Meanwhile any failure of an operation on the async queue causes it to\n   * panic and reject any further work, on the premise that unhandled errors\n   * are fatal.\n   *\n   * Consequently the fallback is handled internally here in start, and if the\n   * fallback succeeds we signal success to the async queue even though the\n   * start() itself signals failure.\n   *\n   * @param componentProvider Provider that returns all core components.\n   * @param persistenceSettings Settings object to configure offline\n   *     persistence.\n   * @returns A deferred result indicating the user-visible result of enabling\n   *     offline persistence. This method will reject this if IndexedDB fails to\n   *     start for any reason. If usePersistence is false this is\n   *     unconditionally resolved.\n   */\n  start(\n    componentProvider: ComponentProvider,\n    persistenceSettings: PersistenceSettings\n  ): Promise<void> {\n    this.verifyNotTerminated();\n    // We defer our initialization until we get the current user from\n    // setChangeListener(). We block the async queue until we got the initial\n    // user and the initialization is completed. This will prevent any scheduled\n    // work from happening before initialization is completed.\n    //\n    // If initializationDone resolved then the FirestoreClient is in a usable\n    // state.\n    const initializationDone = new Deferred<void>();\n\n    // If usePersistence is true, certain classes of errors while starting are\n    // recoverable but only by falling back to persistence disabled.\n    //\n    // If there's an error in the first case but not in recovery we cannot\n    // reject the promise blocking the async queue because this will cause the\n    // async queue to panic.\n    const persistenceResult = new Deferred<void>();\n\n    let initialized = false;\n    this.credentials.setChangeListener(user => {\n      if (!initialized) {\n        initialized = true;\n\n        logDebug(LOG_TAG, 'Initializing. user=', user.uid);\n\n        return this.initializeComponents(\n          componentProvider,\n          persistenceSettings,\n          user,\n          persistenceResult\n        ).then(initializationDone.resolve, initializationDone.reject);\n      } else {\n        this.asyncQueue.enqueueRetryable(() => {\n          return this.handleCredentialChange(user);\n        });\n      }\n    });\n\n    // Block the async queue until initialization is done\n    this.asyncQueue.enqueueAndForget(() => {\n      return initializationDone.promise;\n    });\n\n    // Return only the result of enabling persistence. Note that this does not\n    // need to await the completion of initializationDone because the result of\n    // this method should not reflect any other kind of failure to start.\n    return persistenceResult.promise;\n  }\n\n  /** Enables the network connection and requeues all pending operations. */\n  enableNetwork(): Promise<void> {\n    this.verifyNotTerminated();\n    return this.asyncQueue.enqueue(() => {\n      return this.syncEngine.enableNetwork();\n    });\n  }\n\n  /**\n   * Initializes persistent storage, attempting to use IndexedDB if\n   * usePersistence is true or memory-only if false.\n   *\n   * If IndexedDB fails because it's already open in another tab or because the\n   * platform can't possibly support our implementation then this method rejects\n   * the persistenceResult and falls back on memory-only persistence.\n   *\n   * @param componentProvider The provider that provides all core componennts\n   *     for IndexedDB or memory-backed persistence\n   * @param persistenceSettings Settings object to configure offline persistence\n   * @param user The initial user\n   * @param persistenceResult A deferred result indicating the user-visible\n   *     result of enabling offline persistence. This method will reject this if\n   *     IndexedDB fails to start for any reason. If usePersistence is false\n   *     this is unconditionally resolved.\n   * @returns a Promise indicating whether or not initialization should\n   *     continue, i.e. that one of the persistence implementations actually\n   *     succeeded.\n   */\n  private async initializeComponents(\n    componentProvider: ComponentProvider,\n    persistenceSettings: PersistenceSettings,\n    user: User,\n    persistenceResult: Deferred<void>\n  ): Promise<void> {\n    try {\n      // TODO(mrschmidt): Ideally, ComponentProvider would also initialize\n      // Datastore (without duplicating the initializing logic once per\n      // provider).\n\n      const connection = await this.platform.loadConnection(this.databaseInfo);\n      const serializer = this.platform.newSerializer(\n        this.databaseInfo.databaseId\n      );\n      const datastore = newDatastore(connection, this.credentials, serializer);\n\n      await componentProvider.initialize({\n        asyncQueue: this.asyncQueue,\n        databaseInfo: this.databaseInfo,\n        platform: this.platform,\n        datastore,\n        clientId: this.clientId,\n        initialUser: user,\n        maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS,\n        persistenceSettings\n      });\n\n      this.persistence = componentProvider.persistence;\n      this.sharedClientState = componentProvider.sharedClientState;\n      this.localStore = componentProvider.localStore;\n      this.remoteStore = componentProvider.remoteStore;\n      this.syncEngine = componentProvider.syncEngine;\n      this.gcScheduler = componentProvider.gcScheduler;\n      this.eventMgr = componentProvider.eventManager;\n\n      // When a user calls clearPersistence() in one client, all other clients\n      // need to be terminated to allow the delete to succeed.\n      this.persistence.setDatabaseDeletedListener(async () => {\n        await this.terminate();\n      });\n\n      persistenceResult.resolve();\n    } catch (error) {\n      // Regardless of whether or not the retry succeeds, from an user\n      // perspective, offline persistence has failed.\n      persistenceResult.reject(error);\n\n      // An unknown failure on the first stage shuts everything down.\n      if (!this.canFallback(error)) {\n        throw error;\n      }\n      console.warn(\n        'Error enabling offline persistence. Falling back to' +\n          ' persistence disabled: ' +\n          error\n      );\n      return this.initializeComponents(\n        new MemoryComponentProvider(),\n        { durable: false },\n        user,\n        persistenceResult\n      );\n    }\n  }\n\n  /**\n   * Decides whether the provided error allows us to gracefully disable\n   * persistence (as opposed to crashing the client).\n   */\n  private canFallback(error: FirestoreError | DOMException): boolean {\n    if (error.name === 'FirebaseError') {\n      return (\n        error.code === Code.FAILED_PRECONDITION ||\n        error.code === Code.UNIMPLEMENTED\n      );\n    } else if (\n      typeof DOMException !== 'undefined' &&\n      error instanceof DOMException\n    ) {\n      // There are a few known circumstances where we can open IndexedDb but\n      // trying to read/write will fail (e.g. quota exceeded). For\n      // well-understood cases, we attempt to detect these and then gracefully\n      // fall back to memory persistence.\n      // NOTE: Rather than continue to add to this list, we could decide to\n      // always fall back, with the risk that we might accidentally hide errors\n      // representing actual SDK bugs.\n      return (\n        // When the browser is out of quota we could get either quota exceeded\n        // or an aborted error depending on whether the error happened during\n        // schema migration.\n        error.code === DOM_EXCEPTION_QUOTA_EXCEEDED ||\n        error.code === DOM_EXCEPTION_ABORTED ||\n        // Firefox Private Browsing mode disables IndexedDb and returns\n        // INVALID_STATE for any usage.\n        error.code === DOM_EXCEPTION_INVALID_STATE\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks that the client has not been terminated. Ensures that other methods on\n   * this class cannot be called after the client is terminated.\n   */\n  private verifyNotTerminated(): void {\n    if (this.asyncQueue.isShuttingDown) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'The client has already been terminated.'\n      );\n    }\n  }\n\n  private handleCredentialChange(user: User): Promise<void> {\n    this.asyncQueue.verifyOperationInProgress();\n\n    logDebug(LOG_TAG, 'Credential Changed. Current user: ' + user.uid);\n    return this.syncEngine.handleCredentialChange(user);\n  }\n\n  /** Disables the network connection. Pending operations will not complete. */\n  disableNetwork(): Promise<void> {\n    this.verifyNotTerminated();\n    return this.asyncQueue.enqueue(() => {\n      return this.syncEngine.disableNetwork();\n    });\n  }\n\n  terminate(): Promise<void> {\n    return this.asyncQueue.enqueueAndInitiateShutdown(async () => {\n      // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n      if (this.gcScheduler) {\n        this.gcScheduler.stop();\n      }\n\n      await this.remoteStore.shutdown();\n      await this.sharedClientState.shutdown();\n      await this.persistence.shutdown();\n\n      // `removeChangeListener` must be called after shutting down the\n      // RemoteStore as it will prevent the RemoteStore from retrieving\n      // auth tokens.\n      this.credentials.removeChangeListener();\n    });\n  }\n\n  /**\n   * Returns a Promise that resolves when all writes that were pending at the time this\n   * method was called received server acknowledgement. An acknowledgement can be either acceptance\n   * or rejection.\n   */\n  waitForPendingWrites(): Promise<void> {\n    this.verifyNotTerminated();\n\n    const deferred = new Deferred<void>();\n    this.asyncQueue.enqueueAndForget(() => {\n      return this.syncEngine.registerPendingWritesCallback(deferred);\n    });\n    return deferred.promise;\n  }\n\n  listen(\n    query: Query,\n    observer: Observer<ViewSnapshot>,\n    options: ListenOptions\n  ): QueryListener {\n    this.verifyNotTerminated();\n    const listener = new QueryListener(query, observer, options);\n    this.asyncQueue.enqueueAndForget(() => this.eventMgr.listen(listener));\n    return listener;\n  }\n\n  unlisten(listener: QueryListener): void {\n    // Checks for termination but does not raise error, allowing unlisten after\n    // termination to be a no-op.\n    if (this.clientTerminated) {\n      return;\n    }\n    this.asyncQueue.enqueueAndForget(() => {\n      return this.eventMgr.unlisten(listener);\n    });\n  }\n\n  async getDocumentFromLocalCache(\n    docKey: DocumentKey\n  ): Promise<Document | null> {\n    this.verifyNotTerminated();\n    const deferred = new Deferred<Document | null>();\n    await this.asyncQueue.enqueue(async () => {\n      try {\n        const maybeDoc = await this.localStore.readDocument(docKey);\n        if (maybeDoc instanceof Document) {\n          deferred.resolve(maybeDoc);\n        } else if (maybeDoc instanceof NoDocument) {\n          deferred.resolve(null);\n        } else {\n          deferred.reject(\n            new FirestoreError(\n              Code.UNAVAILABLE,\n              'Failed to get document from cache. (However, this document may ' +\n                \"exist on the server. Run again without setting 'source' in \" +\n                'the GetOptions to attempt to retrieve the document from the ' +\n                'server.)'\n            )\n          );\n        }\n      } catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(\n          e,\n          `Failed to get document '${docKey} from cache`\n        );\n        deferred.reject(firestoreError);\n      }\n    });\n\n    return deferred.promise;\n  }\n\n  async getDocumentsFromLocalCache(query: Query): Promise<ViewSnapshot> {\n    this.verifyNotTerminated();\n    const deferred = new Deferred<ViewSnapshot>();\n    await this.asyncQueue.enqueue(async () => {\n      try {\n        const queryResult = await this.localStore.executeQuery(\n          query,\n          /* usePreviousResults= */ true\n        );\n        const view = new View(query, queryResult.remoteKeys);\n        const viewDocChanges = view.computeDocChanges(queryResult.documents);\n        const viewChange = view.applyChanges(\n          viewDocChanges,\n          /* updateLimboDocuments= */ false\n        );\n        deferred.resolve(viewChange.snapshot!);\n      } catch (e) {\n        const firestoreError = wrapInUserErrorIfRecoverable(\n          e,\n          `Failed to execute query '${query} against cache`\n        );\n        deferred.reject(firestoreError);\n      }\n    });\n    return deferred.promise;\n  }\n\n  write(mutations: Mutation[]): Promise<void> {\n    this.verifyNotTerminated();\n    const deferred = new Deferred<void>();\n    this.asyncQueue.enqueueAndForget(() =>\n      this.syncEngine.write(mutations, deferred)\n    );\n    return deferred.promise;\n  }\n\n  databaseId(): DatabaseId {\n    return this.databaseInfo.databaseId;\n  }\n\n  addSnapshotsInSyncListener(observer: Observer<void>): void {\n    this.verifyNotTerminated();\n    this.asyncQueue.enqueueAndForget(() => {\n      this.eventMgr.addSnapshotsInSyncListener(observer);\n      return Promise.resolve();\n    });\n  }\n\n  removeSnapshotsInSyncListener(observer: Observer<void>): void {\n    // Checks for shutdown but does not raise error, allowing remove after\n    // shutdown to be a no-op.\n    if (this.clientTerminated) {\n      return;\n    }\n    this.asyncQueue.enqueueAndForget(() => {\n      this.eventMgr.removeSnapshotsInSyncListener(observer);\n      return Promise.resolve();\n    });\n  }\n\n  get clientTerminated(): boolean {\n    // Technically, the asyncQueue is still running, but only accepting operations\n    // related to termination or supposed to be run after termination. It is effectively\n    // terminated to the eyes of users.\n    return this.asyncQueue.isShuttingDown;\n  }\n\n  transaction<T>(\n    updateFunction: (transaction: Transaction) => Promise<T>\n  ): Promise<T> {\n    this.verifyNotTerminated();\n    const deferred = new Deferred<T>();\n    this.asyncQueue.enqueueAndForget(() => {\n      this.syncEngine.runTransaction(this.asyncQueue, updateFunction, deferred);\n      return Promise.resolve();\n    });\n    return deferred.promise;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Observer } from '../core/event_manager';\nimport { EventHandler } from './misc';\n\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nexport class AsyncObserver<T> implements Observer<T> {\n  /**\n   * When set to true, will not raise future events. Necessary to deal with\n   * async detachment of listener.\n   */\n  private muted = false;\n\n  constructor(private observer: Observer<T>) {}\n\n  next(value: T): void {\n    this.scheduleEvent(this.observer.next, value);\n  }\n\n  error(error: Error): void {\n    this.scheduleEvent(this.observer.error, error);\n  }\n\n  mute(): void {\n    this.muted = true;\n  }\n\n  private scheduleEvent<E>(eventHandler: EventHandler<E>, event: E): void {\n    if (!this.muted) {\n      setTimeout(() => {\n        if (!this.muted) {\n          eventHandler(event);\n        }\n      }, 0);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from './assert';\nimport { Code, FirestoreError } from './error';\nimport { Dict, forEach } from './obj';\nimport { DocumentKey } from '../model/document_key';\nimport { ResourcePath } from '../model/path';\n\n/** Types accepted by validateType() and related methods for validation. */\nexport type ValidationType =\n  | 'undefined'\n  | 'object'\n  | 'function'\n  | 'boolean'\n  | 'number'\n  | 'string'\n  | 'non-empty string';\n\n/**\n * Validates that no arguments were passed in the invocation of functionName.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateNoArgs('myFunction', arguments);\n */\nexport function validateNoArgs(functionName: string, args: IArguments): void {\n  if (args.length !== 0) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() does not support arguments, ` +\n        'but was called with ' +\n        formatPlural(args.length, 'argument') +\n        '.'\n    );\n  }\n}\n\n/**\n * Validates the invocation of functionName has the exact number of arguments.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateExactNumberOfArgs('myFunction', arguments, 2);\n */\nexport function validateExactNumberOfArgs(\n  functionName: string,\n  args: IArguments,\n  numberOfArgs: number\n): void {\n  if (args.length !== numberOfArgs) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires ` +\n        formatPlural(numberOfArgs, 'argument') +\n        ', but was called with ' +\n        formatPlural(args.length, 'argument') +\n        '.'\n    );\n  }\n}\n\n/**\n * Validates the invocation of functionName has at least the provided number of\n * arguments (but can have many more).\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateAtLeastNumberOfArgs('myFunction', arguments, 2);\n */\nexport function validateAtLeastNumberOfArgs(\n  functionName: string,\n  args: IArguments,\n  minNumberOfArgs: number\n): void {\n  if (args.length < minNumberOfArgs) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires at least ` +\n        formatPlural(minNumberOfArgs, 'argument') +\n        ', but was called with ' +\n        formatPlural(args.length, 'argument') +\n        '.'\n    );\n  }\n}\n\n/**\n * Validates the invocation of functionName has number of arguments between\n * the values provided.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);\n */\nexport function validateBetweenNumberOfArgs(\n  functionName: string,\n  args: IArguments,\n  minNumberOfArgs: number,\n  maxNumberOfArgs: number\n): void {\n  if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires between ${minNumberOfArgs} and ` +\n        `${maxNumberOfArgs} arguments, but was called with ` +\n        formatPlural(args.length, 'argument') +\n        '.'\n    );\n  }\n}\n\n/**\n * Validates the provided argument is an array and has as least the expected\n * number of elements.\n */\nexport function validateNamedArrayAtLeastNumberOfElements<T>(\n  functionName: string,\n  value: T[],\n  name: string,\n  minNumberOfElements: number\n): void {\n  if (!(value instanceof Array) || value.length < minNumberOfElements) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires its ${name} argument to be an ` +\n        'array with at least ' +\n        `${formatPlural(minNumberOfElements, 'element')}.`\n    );\n  }\n}\n\n/**\n * Validates the provided positional argument has the native JavaScript type\n * using typeof checks.\n */\nexport function validateArgType(\n  functionName: string,\n  type: ValidationType,\n  position: number,\n  argument: unknown\n): void {\n  validateType(functionName, type, `${ordinal(position)} argument`, argument);\n}\n\n/**\n * Validates the provided argument has the native JavaScript type using\n * typeof checks or is undefined.\n */\nexport function validateOptionalArgType(\n  functionName: string,\n  type: ValidationType,\n  position: number,\n  argument: unknown\n): void {\n  if (argument !== undefined) {\n    validateArgType(functionName, type, position, argument);\n  }\n}\n\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks.\n */\nexport function validateNamedType(\n  functionName: string,\n  type: ValidationType,\n  optionName: string,\n  argument: unknown\n): void {\n  validateType(functionName, type, `${optionName} option`, argument);\n}\n\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks or is undefined.\n */\nexport function validateNamedOptionalType(\n  functionName: string,\n  type: ValidationType,\n  optionName: string,\n  argument: unknown\n): void {\n  if (argument !== undefined) {\n    validateNamedType(functionName, type, optionName, argument);\n  }\n}\n\nexport function validateArrayElements<T>(\n  functionName: string,\n  optionName: string,\n  typeDescription: string,\n  argument: T[],\n  validator: (arg0: T) => boolean\n): void {\n  if (!(argument instanceof Array)) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires its ${optionName} ` +\n        `option to be an array, but it was: ${valueDescription(argument)}`\n    );\n  }\n\n  for (let i = 0; i < argument.length; ++i) {\n    if (!validator(argument[i])) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function ${functionName}() requires all ${optionName} ` +\n          `elements to be ${typeDescription}, but the value at index ${i} ` +\n          `was: ${valueDescription(argument[i])}`\n      );\n    }\n  }\n}\n\nexport function validateOptionalArrayElements<T>(\n  functionName: string,\n  optionName: string,\n  typeDescription: string,\n  argument: T[] | undefined,\n  validator: (arg0: T) => boolean\n): void {\n  if (argument !== undefined) {\n    validateArrayElements(\n      functionName,\n      optionName,\n      typeDescription,\n      argument,\n      validator\n    );\n  }\n}\n\n/**\n * Validates that the provided named option equals one of the expected values.\n */\nexport function validateNamedPropertyEquals<T>(\n  functionName: string,\n  inputName: string,\n  optionName: string,\n  input: T,\n  expected: T[]\n): void {\n  const expectedDescription: string[] = [];\n\n  for (const val of expected) {\n    if (val === input) {\n      return;\n    }\n    expectedDescription.push(valueDescription(val));\n  }\n\n  const actualDescription = valueDescription(input);\n  throw new FirestoreError(\n    Code.INVALID_ARGUMENT,\n    `Invalid value ${actualDescription} provided to function ${functionName}() for option ` +\n      `\"${optionName}\". Acceptable values: ${expectedDescription.join(', ')}`\n  );\n}\n\n/**\n * Validates that the provided named option equals one of the expected values or\n * is undefined.\n */\nexport function validateNamedOptionalPropertyEquals<T>(\n  functionName: string,\n  inputName: string,\n  optionName: string,\n  input: T,\n  expected: T[]\n): void {\n  if (input !== undefined) {\n    validateNamedPropertyEquals(\n      functionName,\n      inputName,\n      optionName,\n      input,\n      expected\n    );\n  }\n}\n\n/**\n * Validates that the provided argument is a valid enum.\n *\n * @param functionName Function making the validation call.\n * @param enums Array containing all possible values for the enum.\n * @param position Position of the argument in `functionName`.\n * @param argument Argument to validate.\n * @return The value as T if the argument can be converted.\n */\nexport function validateStringEnum<T>(\n  functionName: string,\n  enums: T[],\n  position: number,\n  argument: unknown\n): T {\n  if (!enums.some(element => element === argument)) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid value ${valueDescription(argument)} provided to function ` +\n        `${functionName}() for its ${ordinal(position)} argument. Acceptable ` +\n        `values: ${enums.join(', ')}`\n    );\n  }\n  return argument as T;\n}\n\n/**\n * Validates that `path` refers to a document (indicated by the fact it contains\n * an even numbers of segments).\n */\nexport function validateDocumentPath(path: ResourcePath): void {\n  if (!DocumentKey.isDocumentKey(path)) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid document path (${path}). Path points to a collection.`\n    );\n  }\n}\n\n/**\n * Validates that `path` refers to a collection (indicated by the fact it\n * contains an odd numbers of segments).\n */\nexport function validateCollectionPath(path: ResourcePath): void {\n  if (DocumentKey.isDocumentKey(path)) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid collection path (${path}). Path points to a document.`\n    );\n  }\n}\n\n/** Helper to validate the type of a provided input. */\nfunction validateType(\n  functionName: string,\n  type: ValidationType,\n  inputName: string,\n  input: unknown\n): void {\n  let valid = false;\n  if (type === 'object') {\n    valid = isPlainObject(input);\n  } else if (type === 'non-empty string') {\n    valid = typeof input === 'string' && input !== '';\n  } else {\n    valid = typeof input === type;\n  }\n\n  if (!valid) {\n    const description = valueDescription(input);\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires its ${inputName} ` +\n        `to be of type ${type}, but it was: ${description}`\n    );\n  }\n}\n\n/**\n * Returns true if it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nexport function isPlainObject(input: unknown): boolean {\n  return (\n    typeof input === 'object' &&\n    input !== null &&\n    (Object.getPrototypeOf(input) === Object.prototype ||\n      Object.getPrototypeOf(input) === null)\n  );\n}\n\n/** Returns a string describing the type / value of the provided input. */\nexport function valueDescription(input: unknown): string {\n  if (input === undefined) {\n    return 'undefined';\n  } else if (input === null) {\n    return 'null';\n  } else if (typeof input === 'string') {\n    if (input.length > 20) {\n      input = `${input.substring(0, 20)}...`;\n    }\n    return JSON.stringify(input);\n  } else if (typeof input === 'number' || typeof input === 'boolean') {\n    return '' + input;\n  } else if (typeof input === 'object') {\n    if (input instanceof Array) {\n      return 'an array';\n    } else {\n      const customObjectName = tryGetCustomObjectType(input!);\n      if (customObjectName) {\n        return `a custom ${customObjectName} object`;\n      } else {\n        return 'an object';\n      }\n    }\n  } else if (typeof input === 'function') {\n    return 'a function';\n  } else {\n    return fail('Unknown wrong type: ' + typeof input);\n  }\n}\n\n/** Hacky method to try to get the constructor name for an object. */\nexport function tryGetCustomObjectType(input: object): string | null {\n  if (input.constructor) {\n    const funcNameRegex = /function\\s+([^\\s(]+)\\s*\\(/;\n    const results = funcNameRegex.exec(input.constructor.toString());\n    if (results && results.length > 1) {\n      return results[1];\n    }\n  }\n  return null;\n}\n\n/** Validates the provided argument is defined. */\nexport function validateDefined(\n  functionName: string,\n  position: number,\n  argument: unknown\n): void {\n  if (argument === undefined) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires a valid ${ordinal(position)} ` +\n        `argument, but it was undefined.`\n    );\n  }\n}\n\n/**\n * Validates the provided positional argument is an object, and its keys and\n * values match the expected keys and types provided in optionTypes.\n */\nexport function validateOptionNames(\n  functionName: string,\n  options: object,\n  optionNames: string[]\n): void {\n  forEach(options as Dict<unknown>, (key, _) => {\n    if (optionNames.indexOf(key) < 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Unknown option '${key}' passed to function ${functionName}(). ` +\n          'Available options: ' +\n          optionNames.join(', ')\n      );\n    }\n  });\n}\n\n/**\n * Helper method to throw an error that the provided argument did not pass\n * an instanceof check.\n */\nexport function invalidClassError(\n  functionName: string,\n  type: string,\n  position: number,\n  argument: unknown\n): Error {\n  const description = valueDescription(argument);\n  return new FirestoreError(\n    Code.INVALID_ARGUMENT,\n    `Function ${functionName}() requires its ${ordinal(position)} ` +\n      `argument to be a ${type}, but it was: ${description}`\n  );\n}\n\nexport function validatePositiveNumber(\n  functionName: string,\n  position: number,\n  n: number\n): void {\n  if (n <= 0) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${functionName}() requires its ${ordinal(\n        position\n      )} argument to be a positive number, but it was: ${n}.`\n    );\n  }\n}\n\n/** Converts a number to its english word representation */\nfunction ordinal(num: number): string {\n  switch (num) {\n    case 1:\n      return 'first';\n    case 2:\n      return 'second';\n    case 3:\n      return 'third';\n    default:\n      return num + 'th';\n  }\n}\n\n/**\n * Formats the given word as plural conditionally given the preceding number.\n */\nfunction formatPlural(num: number, str: string): string {\n  return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from '@firebase/firestore-types';\n\nimport { FieldPath as InternalFieldPath } from '../model/path';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  invalidClassError,\n  validateArgType,\n  validateNamedArrayAtLeastNumberOfElements\n} from '../util/input_validation';\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n\n/**\n * A field class base class that is shared by the lite, full and legacy SDK,\n * which supports shared code that deals with FieldPaths.\n */\nexport abstract class BaseFieldPath {\n  /** Internal representation of a Firestore field path. */\n  readonly _internalPath: InternalFieldPath;\n\n  constructor(fieldNames: string[]) {\n    validateNamedArrayAtLeastNumberOfElements(\n      'FieldPath',\n      fieldNames,\n      'fieldNames',\n      1\n    );\n\n    for (let i = 0; i < fieldNames.length; ++i) {\n      validateArgType('FieldPath', 'string', i, fieldNames[i]);\n      if (fieldNames[i].length === 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid field name at argument $(i + 1). ` +\n            'Field names must not be empty.'\n        );\n      }\n    }\n\n    this._internalPath = new InternalFieldPath(fieldNames);\n  }\n}\n\n/**\n * A FieldPath refers to a field in a document. The path may consist of a single\n * field name (referring to a top-level field in the document), or a list of\n * field names (referring to a nested field in the document).\n */\nexport class FieldPath extends BaseFieldPath implements firestore.FieldPath {\n  /**\n   * Creates a FieldPath from the provided field names. If more than one field\n   * name is provided, the path will point to a nested field in a document.\n   *\n   * @param fieldNames A list of field names.\n   */\n  constructor(...fieldNames: string[]) {\n    super(fieldNames);\n  }\n\n  /**\n   * Internal Note: The backend doesn't technically support querying by\n   * document ID. Instead it queries by the entire document name (full path\n   * included), but in the cases we currently support documentId(), the net\n   * effect is the same.\n   */\n  private static readonly _DOCUMENT_ID = new FieldPath(\n    InternalFieldPath.keyField().canonicalString()\n  );\n\n  static documentId(): FieldPath {\n    return FieldPath._DOCUMENT_ID;\n  }\n\n  isEqual(other: firestore.FieldPath): boolean {\n    if (!(other instanceof FieldPath)) {\n      throw invalidClassError('isEqual', 'FieldPath', 1, other);\n    }\n    return this._internalPath.isEqual(other._internalPath);\n  }\n}\n\n/**\n * Matches any characters in a field path string that are reserved.\n */\nconst RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n\n/**\n * Parses a field path string into a FieldPath, treating dots as separators.\n */\nexport function fromDotSeparatedString(path: string): FieldPath {\n  const found = path.search(RESERVED);\n  if (found >= 0) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid field path (${path}). Paths must not contain ` +\n        `'~', '*', '/', '[', or ']'`\n    );\n  }\n  try {\n    return new FieldPath(...path.split('.'));\n  } catch (e) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid field path (${path}). Paths must not be empty, ` +\n        `begin with '.', end with '.', or contain '..'`\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { User } from '../auth/user';\nimport { hardAssert, debugAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  FirebaseAuthInternal,\n  FirebaseAuthInternalName\n} from '@firebase/auth-interop-types';\nimport { Provider } from '@firebase/component';\nimport { logDebug } from '../util/log';\n\n// TODO(mikelehen): This should be split into multiple files and probably\n// moved to an auth/ folder to match other platforms.\n\nexport interface FirstPartyCredentialsSettings {\n  type: 'gapi';\n  client: unknown;\n  sessionIndex: string;\n}\n\nexport interface ProviderCredentialsSettings {\n  type: 'provider';\n  client: CredentialsProvider;\n}\n\n/** Settings for private credentials */\nexport type CredentialsSettings =\n  | FirstPartyCredentialsSettings\n  | ProviderCredentialsSettings;\n\nexport type TokenType = 'OAuth' | 'FirstParty';\nexport interface Token {\n  /** Type of token. */\n  type: TokenType;\n\n  /**\n   * The user with which the token is associated (used for persisting user\n   * state on disk, etc.).\n   */\n  user: User;\n\n  /** Extra header values to be passed along with a request */\n  authHeaders: { [header: string]: string };\n}\n\nexport class OAuthToken implements Token {\n  type = 'OAuth' as TokenType;\n  authHeaders: { [header: string]: string };\n  constructor(value: string, public user: User) {\n    this.authHeaders = {};\n    // Set the headers using Object Literal notation to avoid minification\n    this.authHeaders['Authorization'] = `Bearer ${value}`;\n  }\n}\n\n/**\n * A Listener for credential change events. The listener should fetch a new\n * token and may need to invalidate other state if the current user has also\n * changed.\n */\nexport type CredentialChangeListener = (user: User) => void;\n\n/**\n * Provides methods for getting the uid and token for the current user and\n * listening for changes.\n */\nexport interface CredentialsProvider {\n  /** Requests a token for the current user. */\n  getToken(): Promise<Token | null>;\n\n  /**\n   * Marks the last retrieved token as invalid, making the next GetToken request\n   * force-refresh the token.\n   */\n  invalidateToken(): void;\n\n  /**\n   * Specifies a listener to be notified of credential changes\n   * (sign-in / sign-out, token changes). It is immediately called once with the\n   * initial user.\n   */\n  setChangeListener(changeListener: CredentialChangeListener): void;\n\n  /** Removes the previously-set change listener. */\n  removeChangeListener(): void;\n}\n\n/** A CredentialsProvider that always yields an empty token. */\nexport class EmptyCredentialsProvider implements CredentialsProvider {\n  /**\n   * Stores the listener registered with setChangeListener()\n   * This isn't actually necessary since the UID never changes, but we use this\n   * to verify the listen contract is adhered to in tests.\n   */\n  private changeListener: CredentialChangeListener | null = null;\n\n  getToken(): Promise<Token | null> {\n    return Promise.resolve<Token | null>(null);\n  }\n\n  invalidateToken(): void {}\n\n  setChangeListener(changeListener: CredentialChangeListener): void {\n    debugAssert(\n      !this.changeListener,\n      'Can only call setChangeListener() once.'\n    );\n    this.changeListener = changeListener;\n    // Fire with initial user.\n    changeListener(User.UNAUTHENTICATED);\n  }\n\n  removeChangeListener(): void {\n    debugAssert(\n      this.changeListener !== null,\n      'removeChangeListener() when no listener registered'\n    );\n    this.changeListener = null;\n  }\n}\n\nexport class FirebaseCredentialsProvider implements CredentialsProvider {\n  /**\n   * The auth token listener registered with FirebaseApp, retained here so we\n   * can unregister it.\n   */\n  private tokenListener: ((token: string | null) => void) | null = null;\n\n  /** Tracks the current User. */\n  private currentUser: User = User.UNAUTHENTICATED;\n  private receivedInitialUser: boolean = false;\n\n  /**\n   * Counter used to detect if the token changed while a getToken request was\n   * outstanding.\n   */\n  private tokenCounter = 0;\n\n  /** The listener registered with setChangeListener(). */\n  private changeListener: CredentialChangeListener | null = null;\n\n  private forceRefresh = false;\n\n  private auth: FirebaseAuthInternal | null;\n\n  constructor(authProvider: Provider<FirebaseAuthInternalName>) {\n    this.tokenListener = () => {\n      this.tokenCounter++;\n      this.currentUser = this.getUser();\n      this.receivedInitialUser = true;\n      if (this.changeListener) {\n        this.changeListener(this.currentUser);\n      }\n    };\n\n    this.tokenCounter = 0;\n\n    this.auth = authProvider.getImmediate({ optional: true });\n\n    if (this.auth) {\n      this.auth.addAuthTokenListener(this.tokenListener!);\n    } else {\n      // if auth is not available, invoke tokenListener once with null token\n      this.tokenListener(null);\n      authProvider.get().then(\n        auth => {\n          this.auth = auth;\n          if (this.tokenListener) {\n            // tokenListener can be removed by removeChangeListener()\n            this.auth.addAuthTokenListener(this.tokenListener);\n          }\n        },\n        () => {\n          /* this.authProvider.get() never rejects */\n        }\n      );\n    }\n  }\n\n  getToken(): Promise<Token | null> {\n    debugAssert(\n      this.tokenListener != null,\n      'getToken cannot be called after listener removed.'\n    );\n\n    // Take note of the current value of the tokenCounter so that this method\n    // can fail (with an ABORTED error) if there is a token change while the\n    // request is outstanding.\n    const initialTokenCounter = this.tokenCounter;\n    const forceRefresh = this.forceRefresh;\n    this.forceRefresh = false;\n\n    if (!this.auth) {\n      return Promise.resolve(null);\n    }\n\n    return this.auth.getToken(forceRefresh).then(tokenData => {\n      // Cancel the request since the token changed while the request was\n      // outstanding so the response is potentially for a previous user (which\n      // user, we can't be sure).\n      if (this.tokenCounter !== initialTokenCounter) {\n        logDebug(\n          'FirebaseCredentialsProvider',\n          'getToken aborted due to token change.'\n        );\n        return this.getToken();\n      } else {\n        if (tokenData) {\n          hardAssert(\n            typeof tokenData.accessToken === 'string',\n            'Invalid tokenData returned from getToken():' + tokenData\n          );\n          return new OAuthToken(tokenData.accessToken, this.currentUser);\n        } else {\n          return null;\n        }\n      }\n    });\n  }\n\n  invalidateToken(): void {\n    this.forceRefresh = true;\n  }\n\n  setChangeListener(changeListener: CredentialChangeListener): void {\n    debugAssert(\n      !this.changeListener,\n      'Can only call setChangeListener() once.'\n    );\n    this.changeListener = changeListener;\n\n    // Fire the initial event\n    if (this.receivedInitialUser) {\n      changeListener(this.currentUser);\n    }\n  }\n\n  removeChangeListener(): void {\n    debugAssert(\n      this.tokenListener != null,\n      'removeChangeListener() called twice'\n    );\n    debugAssert(\n      this.changeListener !== null,\n      'removeChangeListener() called when no listener registered'\n    );\n\n    if (this.auth) {\n      this.auth.removeAuthTokenListener(this.tokenListener!);\n    }\n    this.tokenListener = null;\n    this.changeListener = null;\n  }\n\n  // Auth.getUid() can return null even with a user logged in. It is because\n  // getUid() is synchronous, but the auth code populating Uid is asynchronous.\n  // This method should only be called in the AuthTokenListener callback\n  // to guarantee to get the actual user.\n  private getUser(): User {\n    const currentUid = this.auth && this.auth.getUid();\n    hardAssert(\n      currentUid === null || typeof currentUid === 'string',\n      'Received invalid UID: ' + currentUid\n    );\n    return new User(currentUid);\n  }\n}\n\n// Manual type definition for the subset of Gapi we use.\ninterface Gapi {\n  auth: {\n    getAuthHeaderValueForFirstParty: (\n      userIdentifiers: Array<{ [key: string]: string }>\n    ) => string | null;\n  };\n}\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * Technically this may no longer be necessary since the SDK should gracefully\n * recover from unauthenticated errors (see b/33147818 for context), but it's\n * safer to keep the implementation as-is.\n */\nexport class FirstPartyToken implements Token {\n  type = 'FirstParty' as TokenType;\n  user = User.FIRST_PARTY;\n\n  constructor(private gapi: Gapi, private sessionIndex: string) {}\n\n  get authHeaders(): { [header: string]: string } {\n    const headers: { [header: string]: string } = {\n      'X-Goog-AuthUser': this.sessionIndex\n    };\n    const authHeader = this.gapi.auth.getAuthHeaderValueForFirstParty([]);\n    if (authHeader) {\n      headers['Authorization'] = authHeader;\n    }\n    return headers;\n  }\n}\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nexport class FirstPartyCredentialsProvider implements CredentialsProvider {\n  constructor(private gapi: Gapi, private sessionIndex: string) {}\n\n  getToken(): Promise<Token | null> {\n    return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n  }\n\n  setChangeListener(changeListener: CredentialChangeListener): void {\n    // Fire with initial uid.\n    changeListener(User.FIRST_PARTY);\n  }\n\n  removeChangeListener(): void {}\n\n  invalidateToken(): void {}\n}\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(\n  credentials?: CredentialsSettings\n): CredentialsProvider {\n  if (!credentials) {\n    return new EmptyCredentialsProvider();\n  }\n\n  switch (credentials.type) {\n    case 'gapi':\n      const client = credentials.client as Gapi;\n      // Make sure this really is a Gapi client.\n      hardAssert(\n        !!(\n          typeof client === 'object' &&\n          client !== null &&\n          client['auth'] &&\n          client['auth']['getAuthHeaderValueForFirstParty']\n        ),\n        'unexpected gapi interface'\n      );\n      return new FirstPartyCredentialsProvider(\n        client,\n        credentials.sessionIndex || '0'\n      );\n\n    case 'provider':\n      return credentials.client;\n\n    default:\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'makeCredentialsProvider failed due to invalid credential type'\n      );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject } from '../model/object_value';\n\n/**\n * Observer/Subscribe interfaces.\n */\nexport type NextFn<T> = (value: T) => void;\nexport type ErrorFn = (error: Error) => void;\nexport type CompleteFn = () => void;\n\n// Allow for any of the Observer methods to be undefined.\nexport interface PartialObserver<T> {\n  next?: NextFn<T>;\n  error?: ErrorFn;\n  complete?: CompleteFn;\n}\n\nexport interface Unsubscribe {\n  (): void;\n}\n\nexport function isPartialObserver(obj: unknown): boolean {\n  return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj: unknown, methods: string[]): boolean {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const object = obj as JsonObject<unknown>;\n  for (const method of methods) {\n    if (method in object && typeof object[method] === 'function') {\n      return true;\n    }\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PlatformSupport } from '../platform/platform';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  invalidClassError,\n  validateArgType,\n  validateExactNumberOfArgs\n} from '../util/input_validation';\nimport { ByteString } from '../util/byte_string';\n\n/** Helper function to assert Uint8Array is available at runtime. */\nfunction assertUint8ArrayAvailable(): void {\n  if (typeof Uint8Array === 'undefined') {\n    throw new FirestoreError(\n      Code.UNIMPLEMENTED,\n      'Uint8Arrays are not available in this environment.'\n    );\n  }\n}\n\n/** Helper function to assert Base64 functions are available at runtime. */\nfunction assertBase64Available(): void {\n  if (!PlatformSupport.getPlatform().base64Available) {\n    throw new FirestoreError(\n      Code.UNIMPLEMENTED,\n      'Blobs are unavailable in Firestore in this environment.'\n    );\n  }\n}\n\n/**\n * Immutable class holding a blob (binary data).\n * This class is directly exposed in the public API.\n *\n * Note that while you can't hide the constructor in JavaScript code, we are\n * using the hack above to make sure no-one outside this module can call it.\n */\nexport class Blob {\n  // Prefix with underscore to signal that we consider this not part of the\n  // public API and to prevent it from showing up for autocompletion.\n  _byteString: ByteString;\n\n  constructor(byteString: ByteString) {\n    assertBase64Available();\n    this._byteString = byteString;\n  }\n\n  static fromBase64String(base64: string): Blob {\n    validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);\n    validateArgType('Blob.fromBase64String', 'string', 1, base64);\n    assertBase64Available();\n    try {\n      return new Blob(ByteString.fromBase64String(base64));\n    } catch (e) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Failed to construct Blob from Base64 string: ' + e\n      );\n    }\n  }\n\n  static fromUint8Array(array: Uint8Array): Blob {\n    validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);\n    assertUint8ArrayAvailable();\n    if (!(array instanceof Uint8Array)) {\n      throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);\n    }\n    return new Blob(ByteString.fromUint8Array(array));\n  }\n\n  toBase64(): string {\n    validateExactNumberOfArgs('Blob.toBase64', arguments, 0);\n    assertBase64Available();\n    return this._byteString.toBase64();\n  }\n\n  toUint8Array(): Uint8Array {\n    validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);\n    assertUint8ArrayAvailable();\n    return this._byteString.toUint8Array();\n  }\n\n  toString(): string {\n    return 'Blob(base64: ' + this.toBase64() + ')';\n  }\n\n  isEqual(other: Blob): boolean {\n    return this._byteString.isEqual(other._byteString);\n  }\n}\n","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { Timestamp } from '../api/timestamp';\nimport { debugAssert } from '../util/assert';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport {\n  valueEquals,\n  isArray,\n  isInteger,\n  isNumber,\n  normalizeNumber\n} from './values';\nimport { serverTimestamp } from './server_timestamps';\nimport { arrayEquals } from '../util/misc';\n\n/** Represents a transform within a TransformMutation. */\nexport interface TransformOperation {\n  /**\n   * Computes the local transform result against the provided `previousValue`,\n   * optionally using the provided localWriteTime.\n   */\n  applyToLocalView(\n    previousValue: api.Value | null,\n    localWriteTime: Timestamp\n  ): api.Value;\n\n  /**\n   * Computes a final transform result after the transform has been acknowledged\n   * by the server, potentially using the server-provided transformResult.\n   */\n  applyToRemoteDocument(\n    previousValue: api.Value | null,\n    transformResult: api.Value | null\n  ): api.Value;\n\n  /**\n   * If this transform operation is not idempotent, returns the base value to\n   * persist for this transform. If a base value is returned, the transform\n   * operation is always applied to this base value, even if document has\n   * already been updated.\n   *\n   * Base values provide consistent behavior for non-idempotent transforms and\n   * allow us to return the same latency-compensated value even if the backend\n   * has already applied the transform operation. The base value is null for\n   * idempotent transforms, as they can be re-played even if the backend has\n   * already applied them.\n   *\n   * @return a base value to store along with the mutation, or null for\n   * idempotent transforms.\n   */\n  computeBaseValue(previousValue: api.Value | null): api.Value | null;\n\n  isEqual(other: TransformOperation): boolean;\n}\n\n/** Transforms a value into a server-generated timestamp. */\nexport class ServerTimestampTransform implements TransformOperation {\n  private constructor() {}\n  static instance = new ServerTimestampTransform();\n\n  applyToLocalView(\n    previousValue: api.Value | null,\n    localWriteTime: Timestamp\n  ): api.Value {\n    return serverTimestamp(localWriteTime!, previousValue);\n  }\n\n  applyToRemoteDocument(\n    previousValue: api.Value | null,\n    transformResult: api.Value | null\n  ): api.Value {\n    return transformResult!;\n  }\n\n  computeBaseValue(previousValue: api.Value | null): api.Value | null {\n    return null; // Server timestamps are idempotent and don't require a base value.\n  }\n\n  isEqual(other: TransformOperation): boolean {\n    return other instanceof ServerTimestampTransform;\n  }\n}\n\n/** Transforms an array value via a union operation. */\nexport class ArrayUnionTransformOperation implements TransformOperation {\n  constructor(readonly elements: api.Value[]) {}\n\n  applyToLocalView(\n    previousValue: api.Value | null,\n    localWriteTime: Timestamp\n  ): api.Value {\n    return this.apply(previousValue);\n  }\n\n  applyToRemoteDocument(\n    previousValue: api.Value | null,\n    transformResult: api.Value | null\n  ): api.Value {\n    // The server just sends null as the transform result for array operations,\n    // so we have to calculate a result the same as we do for local\n    // applications.\n    return this.apply(previousValue);\n  }\n\n  private apply(previousValue: api.Value | null): api.Value {\n    const values = coercedFieldValuesArray(previousValue);\n    for (const toUnion of this.elements) {\n      if (!values.some(element => valueEquals(element, toUnion))) {\n        values.push(toUnion);\n      }\n    }\n    return { arrayValue: { values } };\n  }\n\n  computeBaseValue(previousValue: api.Value | null): api.Value | null {\n    return null; // Array transforms are idempotent and don't require a base value.\n  }\n\n  isEqual(other: TransformOperation): boolean {\n    return (\n      other instanceof ArrayUnionTransformOperation &&\n      arrayEquals(this.elements, other.elements, valueEquals)\n    );\n  }\n}\n\n/** Transforms an array value via a remove operation. */\nexport class ArrayRemoveTransformOperation implements TransformOperation {\n  constructor(readonly elements: api.Value[]) {}\n\n  applyToLocalView(\n    previousValue: api.Value | null,\n    localWriteTime: Timestamp\n  ): api.Value {\n    return this.apply(previousValue);\n  }\n\n  applyToRemoteDocument(\n    previousValue: api.Value | null,\n    transformResult: api.Value | null\n  ): api.Value {\n    // The server just sends null as the transform result for array operations,\n    // so we have to calculate a result the same as we do for local\n    // applications.\n    return this.apply(previousValue);\n  }\n\n  private apply(previousValue: api.Value | null): api.Value {\n    let values = coercedFieldValuesArray(previousValue);\n    for (const toRemove of this.elements) {\n      values = values.filter(element => !valueEquals(element, toRemove));\n    }\n    return { arrayValue: { values } };\n  }\n\n  computeBaseValue(previousValue: api.Value | null): api.Value | null {\n    return null; // Array transforms are idempotent and don't require a base value.\n  }\n\n  isEqual(other: TransformOperation): boolean {\n    return (\n      other instanceof ArrayRemoveTransformOperation &&\n      arrayEquals(this.elements, other.elements, valueEquals)\n    );\n  }\n}\n\n/**\n * Implements the backend semantics for locally computed NUMERIC_ADD (increment)\n * transforms. Converts all field values to integers or doubles, but unlike the\n * backend does not cap integer values at 2^63. Instead, JavaScript number\n * arithmetic is used and precision loss can occur for values greater than 2^53.\n */\nexport class NumericIncrementTransformOperation implements TransformOperation {\n  constructor(\n    private readonly serializer: JsonProtoSerializer,\n    readonly operand: api.Value\n  ) {\n    debugAssert(\n      isNumber(operand),\n      'NumericIncrementTransform transform requires a NumberValue'\n    );\n  }\n\n  applyToLocalView(\n    previousValue: api.Value | null,\n    localWriteTime: Timestamp\n  ): api.Value {\n    // PORTING NOTE: Since JavaScript's integer arithmetic is limited to 53 bit\n    // precision and resolves overflows by reducing precision, we do not\n    // manually cap overflows at 2^63.\n    const baseValue = this.computeBaseValue(previousValue);\n    const sum = this.asNumber(baseValue) + this.asNumber(this.operand);\n    if (isInteger(baseValue) && isInteger(this.operand)) {\n      return this.serializer.toInteger(sum);\n    } else {\n      return this.serializer.toDouble(sum);\n    }\n  }\n\n  applyToRemoteDocument(\n    previousValue: api.Value | null,\n    transformResult: api.Value | null\n  ): api.Value {\n    debugAssert(\n      transformResult !== null,\n      \"Didn't receive transformResult for NUMERIC_ADD transform\"\n    );\n    return transformResult;\n  }\n\n  /**\n   * Inspects the provided value, returning the provided value if it is already\n   * a NumberValue, otherwise returning a coerced value of 0.\n   */\n  computeBaseValue(previousValue: api.Value | null): api.Value {\n    return isNumber(previousValue) ? previousValue! : { integerValue: 0 };\n  }\n\n  isEqual(other: TransformOperation): boolean {\n    return (\n      other instanceof NumericIncrementTransformOperation &&\n      valueEquals(this.operand, other.operand)\n    );\n  }\n\n  private asNumber(value: api.Value): number {\n    return normalizeNumber(value.integerValue || value.doubleValue);\n  }\n}\n\nfunction coercedFieldValuesArray(value: api.Value | null): api.Value[] {\n  return isArray(value) && value.arrayValue.values\n    ? value.arrayValue.values.slice()\n    : [];\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from '@firebase/firestore-types';\nimport {\n  validateArgType,\n  validateAtLeastNumberOfArgs,\n  validateExactNumberOfArgs,\n  validateNoArgs\n} from '../util/input_validation';\nimport { FieldTransform } from '../model/mutation';\nimport {\n  ArrayRemoveTransformOperation,\n  ArrayUnionTransformOperation,\n  NumericIncrementTransformOperation,\n  ServerTimestampTransform\n} from '../model/transform_operation';\nimport { ParseContext, parseData, UserDataSource } from './user_data_reader';\nimport { debugAssert } from '../util/assert';\n\n/**\n * An opaque base class for FieldValue sentinel objects in our public API that\n * is shared between the full, lite and legacy SDK.\n */\nexport abstract class SerializableFieldValue {\n  /** The public API endpoint that returns this class. */\n  abstract readonly _methodName: string;\n\n  /** A pointer to the implementing class. */\n  readonly _delegate: SerializableFieldValue = this;\n\n  abstract _toFieldTransform(context: ParseContext): FieldTransform | null;\n\n  abstract isEqual(other: SerializableFieldValue): boolean;\n}\n\nexport class DeleteFieldValueImpl extends SerializableFieldValue {\n  constructor(readonly _methodName: string) {\n    super();\n  }\n\n  _toFieldTransform(context: ParseContext): null {\n    if (context.dataSource === UserDataSource.MergeSet) {\n      // No transform to add for a delete, but we need to add it to our\n      // fieldMask so it gets deleted.\n      context.fieldMask.push(context.path!);\n    } else if (context.dataSource === UserDataSource.Update) {\n      debugAssert(\n        context.path!.length > 0,\n        `${this._methodName}() at the top level should have already ` +\n          'been handled.'\n      );\n      throw context.createError(\n        `${this._methodName}() can only appear at the top level ` +\n          'of your update data'\n      );\n    } else {\n      // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n      throw context.createError(\n        `${this._methodName}() cannot be used with set() unless you pass ` +\n          '{merge:true}'\n      );\n    }\n    return null;\n  }\n\n  isEqual(other: FieldValue): boolean {\n    return other instanceof DeleteFieldValueImpl;\n  }\n}\n\nexport class ServerTimestampFieldValueImpl extends SerializableFieldValue {\n  constructor(readonly _methodName: string) {\n    super();\n  }\n\n  _toFieldTransform(context: ParseContext): FieldTransform {\n    return new FieldTransform(context.path!, ServerTimestampTransform.instance);\n  }\n\n  isEqual(other: FieldValue): boolean {\n    return other instanceof ServerTimestampFieldValueImpl;\n  }\n}\n\nexport class ArrayUnionFieldValueImpl extends SerializableFieldValue {\n  constructor(\n    readonly _methodName: string,\n    private readonly _elements: unknown[]\n  ) {\n    super();\n  }\n\n  _toFieldTransform(context: ParseContext): FieldTransform {\n    // Although array transforms are used with writes, the actual elements\n    // being uniomed or removed are not considered writes since they cannot\n    // contain any FieldValue sentinels, etc.\n    const parseContext = new ParseContext(\n      {\n        dataSource: UserDataSource.Argument,\n        methodName: this._methodName,\n        arrayElement: true\n      },\n      context.databaseId,\n      context.serializer,\n      context.ignoreUndefinedProperties\n    );\n    const parsedElements = this._elements.map(\n      element => parseData(element, parseContext)!\n    );\n    const arrayUnion = new ArrayUnionTransformOperation(parsedElements);\n    return new FieldTransform(context.path!, arrayUnion);\n  }\n\n  isEqual(other: FieldValue): boolean {\n    // TODO(mrschmidt): Implement isEquals\n    return this === other;\n  }\n}\n\nexport class ArrayRemoveFieldValueImpl extends SerializableFieldValue {\n  constructor(readonly _methodName: string, readonly _elements: unknown[]) {\n    super();\n  }\n\n  _toFieldTransform(context: ParseContext): FieldTransform {\n    // Although array transforms are used with writes, the actual elements\n    // being unioned or removed are not considered writes since they cannot\n    // contain any FieldValue sentinels, etc.\n    const parseContext = new ParseContext(\n      {\n        dataSource: UserDataSource.Argument,\n        methodName: this._methodName,\n        arrayElement: true\n      },\n      context.databaseId,\n      context.serializer,\n      context.ignoreUndefinedProperties\n    );\n    const parsedElements = this._elements.map(\n      element => parseData(element, parseContext)!\n    );\n    const arrayUnion = new ArrayRemoveTransformOperation(parsedElements);\n    return new FieldTransform(context.path!, arrayUnion);\n  }\n\n  isEqual(other: FieldValue): boolean {\n    // TODO(mrschmidt): Implement isEquals\n    return this === other;\n  }\n}\n\nexport class NumericIncrementFieldValueImpl extends SerializableFieldValue {\n  constructor(readonly _methodName: string, private readonly _operand: number) {\n    super();\n  }\n\n  _toFieldTransform(context: ParseContext): FieldTransform {\n    const parseContext = new ParseContext(\n      {\n        dataSource: UserDataSource.Argument,\n        methodName: this._methodName\n      },\n      context.databaseId,\n      context.serializer,\n      context.ignoreUndefinedProperties\n    );\n    const operand = parseData(this._operand, parseContext)!;\n    const numericIncrement = new NumericIncrementTransformOperation(\n      context.serializer,\n      operand\n    );\n    return new FieldTransform(context.path!, numericIncrement);\n  }\n\n  isEqual(other: FieldValue): boolean {\n    // TODO(mrschmidt): Implement isEquals\n    return this === other;\n  }\n}\n\n/** The public FieldValue class of the lite API. */\nexport abstract class FieldValue extends SerializableFieldValue\n  implements firestore.FieldValue {\n  static delete(): firestore.FieldValue {\n    validateNoArgs('FieldValue.delete', arguments);\n    return new FieldValueDelegate(\n      new DeleteFieldValueImpl('FieldValue.delete')\n    );\n  }\n\n  static serverTimestamp(): firestore.FieldValue {\n    validateNoArgs('FieldValue.serverTimestamp', arguments);\n    return new FieldValueDelegate(\n      new ServerTimestampFieldValueImpl('FieldValue.serverTimestamp')\n    );\n  }\n\n  static arrayUnion(...elements: unknown[]): firestore.FieldValue {\n    validateAtLeastNumberOfArgs('FieldValue.arrayUnion', arguments, 1);\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new FieldValueDelegate(\n      new ArrayUnionFieldValueImpl('FieldValue.arrayUnion', elements)\n    );\n  }\n\n  static arrayRemove(...elements: unknown[]): firestore.FieldValue {\n    validateAtLeastNumberOfArgs('FieldValue.arrayRemove', arguments, 1);\n    // NOTE: We don't actually parse the data until it's used in set() or\n    // update() since we'd need the Firestore instance to do this.\n    return new FieldValueDelegate(\n      new ArrayRemoveFieldValueImpl('FieldValue.arrayRemove', elements)\n    );\n  }\n\n  static increment(n: number): firestore.FieldValue {\n    validateArgType('FieldValue.increment', 'number', 1, n);\n    validateExactNumberOfArgs('FieldValue.increment', arguments, 1);\n    return new FieldValueDelegate(\n      new NumericIncrementFieldValueImpl('FieldValue.increment', n)\n    );\n  }\n}\n\n/**\n * A delegate class that allows the FieldValue implementations returned by\n * deleteField(), serverTimestamp(), arrayUnion(), arrayRemove() and\n * increment() to be an instance of the legacy FieldValue class declared above.\n *\n * We don't directly subclass `FieldValue` in the various field value\n * implementations as the base FieldValue class differs between the lite, full\n * and legacy SDK.\n */\nclass FieldValueDelegate extends FieldValue implements firestore.FieldValue {\n  readonly _methodName: string;\n\n  constructor(readonly _delegate: SerializableFieldValue) {\n    super();\n    this._methodName = _delegate._methodName;\n  }\n\n  _toFieldTransform(context: ParseContext): FieldTransform | null {\n    return this._delegate._toFieldTransform(context);\n  }\n\n  isEqual(other: firestore.FieldValue): boolean {\n    if (!(other instanceof FieldValueDelegate)) {\n      return false;\n    }\n    return this._delegate.isEqual(other._delegate);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  validateArgType,\n  validateExactNumberOfArgs\n} from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\n\n/**\n * Immutable class representing a geo point as latitude-longitude pair.\n * This class is directly exposed in the public API, including its constructor.\n */\nexport class GeoPoint {\n  // Prefix with underscore to signal this is a private variable in JS and\n  // prevent it showing up for autocompletion when typing latitude or longitude.\n  private _lat: number;\n  private _long: number;\n\n  constructor(latitude: number, longitude: number) {\n    validateExactNumberOfArgs('GeoPoint', arguments, 2);\n    validateArgType('GeoPoint', 'number', 1, latitude);\n    validateArgType('GeoPoint', 'number', 2, longitude);\n    if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Latitude must be a number between -90 and 90, but was: ' + latitude\n      );\n    }\n    if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Longitude must be a number between -180 and 180, but was: ' + longitude\n      );\n    }\n\n    this._lat = latitude;\n    this._long = longitude;\n  }\n\n  /**\n   * Returns the latitude of this geo point, a number between -90 and 90.\n   */\n  get latitude(): number {\n    return this._lat;\n  }\n\n  /**\n   * Returns the longitude of this geo point, a number between -180 and 180.\n   */\n  get longitude(): number {\n    return this._long;\n  }\n\n  isEqual(other: GeoPoint): boolean {\n    return this._lat === other._lat && this._long === other._long;\n  }\n\n  /**\n   * Actually private to JS consumers of our API, so this function is prefixed\n   * with an underscore.\n   */\n  _compareTo(other: GeoPoint): number {\n    return (\n      primitiveComparator(this._lat, other._lat) ||\n      primitiveComparator(this._long, other._long)\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from '@firebase/firestore-types';\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { Timestamp } from './timestamp';\nimport { DatabaseId } from '../core/database_info';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  PatchMutation,\n  Precondition,\n  SetMutation,\n  TransformMutation\n} from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { debugAssert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { Dict, forEach, isEmpty } from '../util/obj';\nimport { ObjectValue, ObjectValueBuilder } from '../model/object_value';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { Blob } from './blob';\nimport { BaseFieldPath, fromDotSeparatedString } from './field_path';\nimport { DeleteFieldValueImpl, SerializableFieldValue } from './field_value';\nimport { GeoPoint } from './geo_point';\nimport { PlatformSupport } from '../platform/platform';\n\nconst RESERVED_FIELD_REGEX = /^__.*__$/;\n\n/**\n * An untyped Firestore Data Converter interface that is shared between the\n * lite, full and legacy SDK.\n */\nexport interface UntypedFirestoreDataConverter<T> {\n  toFirestore(modelObject: T): firestore.DocumentData;\n  fromFirestore(snapshot: unknown, options?: unknown): T;\n}\n\n/**\n * A reference to a document in a Firebase project.\n *\n * This class serves as a common base class for the public DocumentReferences\n * exposed in the lite, full and legacy SDK.\n */\nexport class DocumentKeyReference<T> {\n  constructor(\n    public readonly _databaseId: DatabaseId,\n    public readonly _key: DocumentKey,\n    public readonly _converter: UntypedFirestoreDataConverter<T> | null\n  ) {}\n}\n\n/** The result of parsing document data (e.g. for a setData call). */\nexport class ParsedSetData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask | null,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [] as Mutation[];\n    if (this.fieldMask !== null) {\n      mutations.push(\n        new PatchMutation(key, this.data, this.fieldMask, precondition)\n      );\n    } else {\n      mutations.push(new SetMutation(key, this.data, precondition));\n    }\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nexport class ParsedUpdateData {\n  constructor(\n    readonly data: ObjectValue,\n    readonly fieldMask: FieldMask,\n    readonly fieldTransforms: FieldTransform[]\n  ) {}\n\n  toMutations(key: DocumentKey, precondition: Precondition): Mutation[] {\n    const mutations = [\n      new PatchMutation(key, this.data, this.fieldMask, precondition)\n    ] as Mutation[];\n    if (this.fieldTransforms.length > 0) {\n      mutations.push(new TransformMutation(key, this.fieldTransforms));\n    }\n    return mutations;\n  }\n}\n\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nexport const enum UserDataSource {\n  Set,\n  Update,\n  MergeSet,\n  /**\n   * Indicates the source is a where clause, cursor bound, arrayUnion()\n   * element, etc. Of note, isWrite(source) will return false.\n   */\n  Argument,\n  /**\n   * Indicates that the source is an Argument that may directly contain nested\n   * arrays (e.g. the operand of an `in` query).\n   */\n  ArrayArgument\n}\n\nfunction isWrite(dataSource: UserDataSource): boolean {\n  switch (dataSource) {\n    case UserDataSource.Set: // fall through\n    case UserDataSource.MergeSet: // fall through\n    case UserDataSource.Update:\n      return true;\n    case UserDataSource.Argument:\n    case UserDataSource.ArrayArgument:\n      return false;\n    default:\n      throw fail(`Unexpected case for UserDataSource: ${dataSource}`);\n  }\n}\n\n/** Contains the settings that are mutated as we parse user data. */\ninterface ContextSettings {\n  /** Indicates what kind of API method this data came from. */\n  readonly dataSource: UserDataSource;\n  /** The name of the method the user called to create the ParseContext. */\n  readonly methodName: string;\n  /**\n   * A path within the object being parsed. This could be an empty path (in\n   * which case the context represents the root of the data being parsed), or a\n   * nonempty path (indicating the context represents a nested location within\n   * the data).\n   */\n  readonly path?: FieldPath;\n  /**\n   * Whether or not this context corresponds to an element of an array.\n   * If not set, elements are treated as if they were outside of arrays.\n   */\n  readonly arrayElement?: boolean;\n}\n\n/** A \"context\" object passed around while parsing user data. */\nexport class ParseContext {\n  readonly fieldTransforms: FieldTransform[];\n  readonly fieldMask: FieldPath[];\n  /**\n   * Initializes a ParseContext with the given source and path.\n   *\n   * @param settings The settings for the parser.\n   * @param databaseId The database ID of the Firestore instance.\n   * @param serializer The serializer to use to generate the Value proto.\n   * @param ignoreUndefinedProperties Whether to ignore undefined properties\n   * rather than throw.\n   * @param fieldTransforms A mutable list of field transforms encountered while\n   *     parsing the data.\n   * @param fieldMask A mutable list of field paths encountered while parsing\n   *     the data.\n   *\n   * TODO(b/34871131): We don't support array paths right now, so path can be\n   * null to indicate the context represents any location within an array (in\n   * which case certain features will not work and errors will be somewhat\n   * compromised).\n   */\n  constructor(\n    readonly settings: ContextSettings,\n    readonly databaseId: DatabaseId,\n    readonly serializer: JsonProtoSerializer,\n    readonly ignoreUndefinedProperties: boolean,\n    fieldTransforms?: FieldTransform[],\n    fieldMask?: FieldPath[]\n  ) {\n    // Minor hack: If fieldTransforms is undefined, we assume this is an\n    // external call and we need to validate the entire path.\n    if (fieldTransforms === undefined) {\n      this.validatePath();\n    }\n    this.fieldTransforms = fieldTransforms || [];\n    this.fieldMask = fieldMask || [];\n  }\n\n  get path(): FieldPath | undefined {\n    return this.settings.path;\n  }\n\n  get dataSource(): UserDataSource {\n    return this.settings.dataSource;\n  }\n\n  /** Returns a new context with the specified settings overwritten. */\n  contextWith(configuration: Partial<ContextSettings>): ParseContext {\n    return new ParseContext(\n      { ...this.settings, ...configuration },\n      this.databaseId,\n      this.serializer,\n      this.ignoreUndefinedProperties,\n      this.fieldTransforms,\n      this.fieldMask\n    );\n  }\n\n  childContextForField(field: string): ParseContext {\n    const childPath = this.path?.child(field);\n    const context = this.contextWith({ path: childPath, arrayElement: false });\n    context.validatePathSegment(field);\n    return context;\n  }\n\n  childContextForFieldPath(field: FieldPath): ParseContext {\n    const childPath = this.path?.child(field);\n    const context = this.contextWith({ path: childPath, arrayElement: false });\n    context.validatePath();\n    return context;\n  }\n\n  childContextForArray(index: number): ParseContext {\n    // TODO(b/34871131): We don't support array paths right now; so make path\n    // undefined.\n    return this.contextWith({ path: undefined, arrayElement: true });\n  }\n\n  createError(reason: string): Error {\n    const fieldDescription =\n      !this.path || this.path.isEmpty()\n        ? ''\n        : ` (found in field ${this.path.toString()})`;\n    return new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${this.settings.methodName}() called with invalid data. ` +\n        reason +\n        fieldDescription\n    );\n  }\n\n  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */\n  contains(fieldPath: FieldPath): boolean {\n    return (\n      this.fieldMask.find(field => fieldPath.isPrefixOf(field)) !== undefined ||\n      this.fieldTransforms.find(transform =>\n        fieldPath.isPrefixOf(transform.field)\n      ) !== undefined\n    );\n  }\n\n  private validatePath(): void {\n    // TODO(b/34871131): Remove null check once we have proper paths for fields\n    // within arrays.\n    if (!this.path) {\n      return;\n    }\n    for (let i = 0; i < this.path.length; i++) {\n      this.validatePathSegment(this.path.get(i));\n    }\n  }\n\n  private validatePathSegment(segment: string): void {\n    if (segment.length === 0) {\n      throw this.createError('Document fields must not be empty');\n    }\n    if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n      throw this.createError('Document fields cannot begin and end with \"__\"');\n    }\n  }\n}\n\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nexport class UserDataReader {\n  private readonly serializer: JsonProtoSerializer;\n\n  constructor(\n    private readonly databaseId: DatabaseId,\n    private readonly ignoreUndefinedProperties: boolean,\n    serializer?: JsonProtoSerializer\n  ) {\n    this.serializer =\n      serializer || PlatformSupport.getPlatform().newSerializer(databaseId);\n  }\n\n  /** Parse document data from a set() call. */\n  parseSetData(\n    methodName: string,\n    input: unknown,\n    options: firestore.SetOptions = {}\n  ): ParsedSetData {\n    const context = this.createContext(\n      options.merge || options.mergeFields\n        ? UserDataSource.MergeSet\n        : UserDataSource.Set,\n      methodName\n    );\n    validatePlainObject('Data must be an object, but it was:', context, input);\n    const updateData = parseObject(input, context)!;\n\n    let fieldMask: FieldMask | null;\n    let fieldTransforms: FieldTransform[];\n\n    if (options.merge) {\n      fieldMask = new FieldMask(context.fieldMask);\n      fieldTransforms = context.fieldTransforms;\n    } else if (options.mergeFields) {\n      const validatedFieldPaths: FieldPath[] = [];\n\n      for (const stringOrFieldPath of options.mergeFields) {\n        let fieldPath: FieldPath;\n\n        if (stringOrFieldPath instanceof BaseFieldPath) {\n          fieldPath = stringOrFieldPath._internalPath;\n        } else if (typeof stringOrFieldPath === 'string') {\n          fieldPath = fieldPathFromDotSeparatedString(\n            methodName,\n            stringOrFieldPath\n          );\n        } else {\n          throw fail(\n            'Expected stringOrFieldPath to be a string or a FieldPath'\n          );\n        }\n\n        if (!context.contains(fieldPath)) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Field '${fieldPath}' is specified in your field mask but missing from your input data.`\n          );\n        }\n\n        if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {\n          validatedFieldPaths.push(fieldPath);\n        }\n      }\n\n      fieldMask = new FieldMask(validatedFieldPaths);\n      fieldTransforms = context.fieldTransforms.filter(transform =>\n        fieldMask!.covers(transform.field)\n      );\n    } else {\n      fieldMask = null;\n      fieldTransforms = context.fieldTransforms;\n    }\n\n    return new ParsedSetData(\n      new ObjectValue(updateData),\n      fieldMask,\n      fieldTransforms\n    );\n  }\n\n  /** Parse update data from an update() call. */\n  parseUpdateData(methodName: string, input: unknown): ParsedUpdateData {\n    const context = this.createContext(UserDataSource.Update, methodName);\n    validatePlainObject('Data must be an object, but it was:', context, input);\n\n    const fieldMaskPaths: FieldPath[] = [];\n    const updateData = new ObjectValueBuilder();\n    forEach(input as Dict<unknown>, (key, value) => {\n      const path = fieldPathFromDotSeparatedString(methodName, key);\n\n      const childContext = context.childContextForFieldPath(path);\n      if (\n        value instanceof SerializableFieldValue &&\n        value._delegate instanceof DeleteFieldValueImpl\n      ) {\n        // Add it to the field mask, but don't add anything to updateData.\n        fieldMaskPaths.push(path);\n      } else {\n        const parsedValue = parseData(value, childContext);\n        if (parsedValue != null) {\n          fieldMaskPaths.push(path);\n          updateData.set(path, parsedValue);\n        }\n      }\n    });\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(\n      updateData.build(),\n      mask,\n      context.fieldTransforms\n    );\n  }\n\n  /** Parse update data from a list of field/value arguments. */\n  parseUpdateVarargs(\n    methodName: string,\n    field: string | BaseFieldPath,\n    value: unknown,\n    moreFieldsAndValues: unknown[]\n  ): ParsedUpdateData {\n    const context = this.createContext(UserDataSource.Update, methodName);\n    const keys = [fieldPathFromArgument(methodName, field)];\n    const values = [value];\n\n    if (moreFieldsAndValues.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function ${methodName}() needs to be called with an even number ` +\n          'of arguments that alternate between field names and values.'\n      );\n    }\n\n    for (let i = 0; i < moreFieldsAndValues.length; i += 2) {\n      keys.push(\n        fieldPathFromArgument(\n          methodName,\n          moreFieldsAndValues[i] as string | BaseFieldPath\n        )\n      );\n      values.push(moreFieldsAndValues[i + 1]);\n    }\n\n    const fieldMaskPaths: FieldPath[] = [];\n    const updateData = new ObjectValueBuilder();\n\n    // We iterate in reverse order to pick the last value for a field if the\n    // user specified the field multiple times.\n    for (let i = keys.length - 1; i >= 0; --i) {\n      if (!fieldMaskContains(fieldMaskPaths, keys[i])) {\n        const path = keys[i];\n        const value = values[i];\n        const childContext = context.childContextForFieldPath(path);\n        if (\n          value instanceof SerializableFieldValue &&\n          value._delegate instanceof DeleteFieldValueImpl\n        ) {\n          // Add it to the field mask, but don't add anything to updateData.\n          fieldMaskPaths.push(path);\n        } else {\n          const parsedValue = parseData(value, childContext);\n          if (parsedValue != null) {\n            fieldMaskPaths.push(path);\n            updateData.set(path, parsedValue);\n          }\n        }\n      }\n    }\n\n    const mask = new FieldMask(fieldMaskPaths);\n    return new ParsedUpdateData(\n      updateData.build(),\n      mask,\n      context.fieldTransforms\n    );\n  }\n\n  /** Creates a new top-level parse context. */\n  private createContext(\n    dataSource: UserDataSource,\n    methodName: string\n  ): ParseContext {\n    return new ParseContext(\n      {\n        dataSource,\n        methodName,\n        path: FieldPath.EMPTY_PATH,\n        arrayElement: false\n      },\n      this.databaseId,\n      this.serializer,\n      this.ignoreUndefinedProperties\n    );\n  }\n\n  /**\n   * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n   * bound).\n   *\n   * @param allowArrays Whether the query value is an array that may directly\n   * contain additional arrays (e.g. the operand of an `in` query).\n   */\n  parseQueryValue(\n    methodName: string,\n    input: unknown,\n    allowArrays = false\n  ): api.Value {\n    const context = this.createContext(\n      allowArrays ? UserDataSource.ArrayArgument : UserDataSource.Argument,\n      methodName\n    );\n    const parsed = parseData(input, context);\n    debugAssert(parsed != null, 'Parsed data should not be null.');\n    debugAssert(\n      context.fieldTransforms.length === 0,\n      'Field transforms should have been disallowed.'\n    );\n    return parsed;\n  }\n}\n\n/**\n * Parses user data to Protobuf Values.\n *\n * @param input Data to be parsed.\n * @param context A context object representing the current path being parsed,\n * the source of the data being parsed, etc.\n * @return The parsed value, or null if the value was a FieldValue sentinel\n * that should not be included in the resulting parsed data.\n */\nexport function parseData(\n  input: unknown,\n  context: ParseContext\n): api.Value | null {\n  if (looksLikeJsonObject(input)) {\n    validatePlainObject('Unsupported field value:', context, input);\n    return parseObject(input, context);\n  } else if (input instanceof SerializableFieldValue) {\n    // FieldValues usually parse into transforms (except FieldValue.delete())\n    // in which case we do not want to include this field in our parsed data\n    // (as doing so will overwrite the field directly prior to the transform\n    // trying to transform it). So we don't add this location to\n    // context.fieldMask and we return null as our parsing result.\n    parseSentinelFieldValue(input, context);\n    return null;\n  } else {\n    // If context.path is null we are inside an array and we don't support\n    // field mask paths more granular than the top-level array.\n    if (context.path) {\n      context.fieldMask.push(context.path);\n    }\n\n    if (input instanceof Array) {\n      // TODO(b/34871131): Include the path containing the array in the error\n      // message.\n      // In the case of IN queries, the parsed data is an array (representing\n      // the set of values to be included for the IN query) that may directly\n      // contain additional arrays (each representing an individual field\n      // value), so we disable this validation.\n      if (\n        context.settings.arrayElement &&\n        context.dataSource !== UserDataSource.ArrayArgument\n      ) {\n        throw context.createError('Nested arrays are not supported');\n      }\n      return parseArray(input as unknown[], context);\n    } else {\n      return parseScalarValue(input, context);\n    }\n  }\n}\n\nfunction parseObject(\n  obj: Dict<unknown>,\n  context: ParseContext\n): { mapValue: api.MapValue } {\n  const fields: Dict<api.Value> = {};\n\n  if (isEmpty(obj)) {\n    // If we encounter an empty object, we explicitly add it to the update\n    // mask to ensure that the server creates a map entry.\n    if (context.path && context.path.length > 0) {\n      context.fieldMask.push(context.path);\n    }\n  } else {\n    forEach(obj, (key: string, val: unknown) => {\n      const parsedValue = parseData(val, context.childContextForField(key));\n      if (parsedValue != null) {\n        fields[key] = parsedValue;\n      }\n    });\n  }\n\n  return { mapValue: { fields } };\n}\n\nfunction parseArray(array: unknown[], context: ParseContext): api.Value {\n  const values: api.Value[] = [];\n  let entryIndex = 0;\n  for (const entry of array) {\n    let parsedEntry = parseData(\n      entry,\n      context.childContextForArray(entryIndex)\n    );\n    if (parsedEntry == null) {\n      // Just include nulls in the array for fields being replaced with a\n      // sentinel.\n      parsedEntry = { nullValue: 'NULL_VALUE' };\n    }\n    values.push(parsedEntry);\n    entryIndex++;\n  }\n  return { arrayValue: { values } };\n}\n\n/**\n * \"Parses\" the provided FieldValueImpl, adding any necessary transforms to\n * context.fieldTransforms.\n */\nfunction parseSentinelFieldValue(\n  value: SerializableFieldValue,\n  context: ParseContext\n): void {\n  // Sentinels are only supported with writes, and not within arrays.\n  if (!isWrite(context.dataSource)) {\n    throw context.createError(\n      `${value._methodName}() can only be used with update() and set()`\n    );\n  }\n  if (!context.path) {\n    throw context.createError(\n      `${value._methodName}() is not currently supported inside arrays`\n    );\n  }\n\n  const fieldTransform = value._toFieldTransform(context);\n  if (fieldTransform) {\n    context.fieldTransforms.push(fieldTransform);\n  }\n}\n\n/**\n * Helper to parse a scalar value (i.e. not an Object, Array, or FieldValue)\n *\n * @return The parsed value\n */\nfunction parseScalarValue(\n  value: unknown,\n  context: ParseContext\n): api.Value | null {\n  if (value === null) {\n    return { nullValue: 'NULL_VALUE' };\n  } else if (typeof value === 'number') {\n    return context.serializer.toNumber(value);\n  } else if (typeof value === 'boolean') {\n    return { booleanValue: value };\n  } else if (typeof value === 'string') {\n    return { stringValue: value };\n  } else if (value instanceof Date) {\n    const timestamp = Timestamp.fromDate(value);\n    return { timestampValue: context.serializer.toTimestamp(timestamp) };\n  } else if (value instanceof Timestamp) {\n    // Firestore backend truncates precision down to microseconds. To ensure\n    // offline mode works the same with regards to truncation, perform the\n    // truncation immediately without waiting for the backend to do that.\n    const timestamp = new Timestamp(\n      value.seconds,\n      Math.floor(value.nanoseconds / 1000) * 1000\n    );\n    return { timestampValue: context.serializer.toTimestamp(timestamp) };\n  } else if (value instanceof GeoPoint) {\n    return {\n      geoPointValue: {\n        latitude: value.latitude,\n        longitude: value.longitude\n      }\n    };\n  } else if (value instanceof Blob) {\n    return { bytesValue: context.serializer.toBytes(value) };\n  } else if (value instanceof DocumentKeyReference) {\n    const thisDb = context.databaseId;\n    const otherDb = value._databaseId;\n    if (!otherDb.isEqual(thisDb)) {\n      throw context.createError(\n        'Document reference is for database ' +\n          `${otherDb.projectId}/${otherDb.database} but should be ` +\n          `for database ${thisDb.projectId}/${thisDb.database}`\n      );\n    }\n    return {\n      referenceValue: context.serializer.toResourceName(\n        value._key.path,\n        value._databaseId\n      )\n    };\n  } else if (value === undefined && context.ignoreUndefinedProperties) {\n    return null;\n  } else {\n    throw context.createError(\n      `Unsupported field value: ${valueDescription(value)}`\n    );\n  }\n}\n\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input: unknown): boolean {\n  return (\n    typeof input === 'object' &&\n    input !== null &&\n    !(input instanceof Array) &&\n    !(input instanceof Date) &&\n    !(input instanceof Timestamp) &&\n    !(input instanceof GeoPoint) &&\n    !(input instanceof Blob) &&\n    !(input instanceof DocumentKeyReference) &&\n    !(input instanceof SerializableFieldValue)\n  );\n}\n\nfunction validatePlainObject(\n  message: string,\n  context: ParseContext,\n  input: unknown\n): asserts input is Dict<unknown> {\n  if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n    const description = valueDescription(input);\n    if (description === 'an object') {\n      // Massage the error if it was an object.\n      throw context.createError(message + ' a custom object');\n    } else {\n      throw context.createError(message + ' ' + description);\n    }\n  }\n}\n\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(\n  methodName: string,\n  path: string | BaseFieldPath\n): FieldPath {\n  if (path instanceof BaseFieldPath) {\n    return path._internalPath;\n  } else if (typeof path === 'string') {\n    return fieldPathFromDotSeparatedString(methodName, path);\n  } else {\n    const message = 'Field path arguments must be of type string or FieldPath.';\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nexport function fieldPathFromDotSeparatedString(\n  methodName: string,\n  path: string\n): FieldPath {\n  try {\n    return fromDotSeparatedString(path)._internalPath;\n  } catch (e) {\n    const message = errorMessage(e);\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Function ${methodName}() called with invalid data. ${message}`\n    );\n  }\n}\n\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error: Error | object): string {\n  return error instanceof Error ? error.message : error.toString();\n}\n\n/** Checks `haystack` if FieldPath `needle` is present. Runs in O(n). */\nfunction fieldMaskContains(haystack: FieldPath[], needle: FieldPath): boolean {\n  return haystack.some(v => v.isEqual(needle));\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport class ExistenceFilter {\n  // TODO(b/33078163): just use simplest form of existence filter for now\n  constructor(public count: number) {}\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Blob } from '../api/blob';\nimport { Timestamp } from '../api/timestamp';\nimport { DatabaseId } from '../core/database_info';\nimport {\n  Bound,\n  Direction,\n  FieldFilter,\n  Filter,\n  LimitType,\n  Operator,\n  OrderBy,\n  Query\n} from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Target } from '../core/target';\nimport { TargetId } from '../core/types';\nimport { TargetData, TargetPurpose } from '../local/target_data';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ObjectValue } from '../model/object_value';\nimport {\n  DeleteMutation,\n  FieldMask,\n  FieldTransform,\n  Mutation,\n  MutationResult,\n  PatchMutation,\n  Precondition,\n  SetMutation,\n  TransformMutation,\n  VerifyMutation\n} from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport * as api from '../protos/firestore_proto_api';\nimport { debugAssert, fail, hardAssert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { ByteString } from '../util/byte_string';\nimport {\n  isNegativeZero,\n  isNullOrUndefined,\n  isSafeInteger\n} from '../util/types';\nimport {\n  ArrayRemoveTransformOperation,\n  ArrayUnionTransformOperation,\n  NumericIncrementTransformOperation,\n  ServerTimestampTransform,\n  TransformOperation\n} from '../model/transform_operation';\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode } from './rpc_error';\nimport {\n  DocumentWatchChange,\n  ExistenceFilterChange,\n  WatchChange,\n  WatchTargetChange,\n  WatchTargetChangeState\n} from './watch_change';\nimport { isNanValue, isNullValue, normalizeTimestamp } from '../model/values';\n\nconst DIRECTIONS = (() => {\n  const dirs: { [dir: string]: api.OrderDirection } = {};\n  dirs[Direction.ASCENDING] = 'ASCENDING';\n  dirs[Direction.DESCENDING] = 'DESCENDING';\n  return dirs;\n})();\n\nconst OPERATORS = (() => {\n  const ops: { [op: string]: api.FieldFilterOp } = {};\n  ops[Operator.LESS_THAN] = 'LESS_THAN';\n  ops[Operator.LESS_THAN_OR_EQUAL] = 'LESS_THAN_OR_EQUAL';\n  ops[Operator.GREATER_THAN] = 'GREATER_THAN';\n  ops[Operator.GREATER_THAN_OR_EQUAL] = 'GREATER_THAN_OR_EQUAL';\n  ops[Operator.EQUAL] = 'EQUAL';\n  ops[Operator.ARRAY_CONTAINS] = 'ARRAY_CONTAINS';\n  ops[Operator.IN] = 'IN';\n  ops[Operator.ARRAY_CONTAINS_ANY] = 'ARRAY_CONTAINS_ANY';\n  return ops;\n})();\n\nfunction assertPresent(value: unknown, description: string): asserts value {\n  debugAssert(!isNullOrUndefined(value), description + ' is missing');\n}\n\nexport interface SerializerOptions {\n  /**\n   * The serializer supports both Protobuf.js and Proto3 JSON formats. By\n   * setting this flag to true, the serializer will use the Proto3 JSON format.\n   *\n   * For a description of the Proto3 JSON format check\n   * https://developers.google.com/protocol-buffers/docs/proto3#json\n   */\n  useProto3Json: boolean;\n}\n\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nexport class JsonProtoSerializer {\n  constructor(\n    private databaseId: DatabaseId,\n    private options: SerializerOptions\n  ) {}\n\n  fromRpcStatus(status: api.Status): FirestoreError {\n    const code =\n      status.code === undefined\n        ? Code.UNKNOWN\n        : mapCodeFromRpcCode(status.code);\n    return new FirestoreError(code, status.message || '');\n  }\n\n  /**\n   * Returns a value for a number (or null) that's appropriate to put into\n   * a google.protobuf.Int32Value proto.\n   * DO NOT USE THIS FOR ANYTHING ELSE.\n   * This method cheats. It's typed as returning \"number\" because that's what\n   * our generated proto interfaces say Int32Value must be. But GRPC actually\n   * expects a { value: <number> } struct.\n   */\n  private toInt32Proto(val: number | null): number | { value: number } | null {\n    if (this.options.useProto3Json || isNullOrUndefined(val)) {\n      return val;\n    } else {\n      return { value: val };\n    }\n  }\n\n  /**\n   * Returns a number (or null) from a google.protobuf.Int32Value proto.\n   */\n  private fromInt32Proto(\n    val: number | { value: number } | undefined\n  ): number | null {\n    let result;\n    if (typeof val === 'object') {\n      result = val.value;\n    } else {\n      result = val;\n    }\n    return isNullOrUndefined(result) ? null : result;\n  }\n\n  /**\n   * Returns an IntegerValue for `value`.\n   */\n  toInteger(value: number): api.Value {\n    return { integerValue: '' + value };\n  }\n\n  /**\n   * Returns an DoubleValue for `value` that is encoded based the serializer's\n   * `useProto3Json` setting.\n   */\n  toDouble(value: number): api.Value {\n    if (this.options.useProto3Json) {\n      if (isNaN(value)) {\n        return { doubleValue: 'NaN' };\n      } else if (value === Infinity) {\n        return { doubleValue: 'Infinity' };\n      } else if (value === -Infinity) {\n        return { doubleValue: '-Infinity' };\n      }\n    }\n    return { doubleValue: isNegativeZero(value) ? '-0' : value };\n  }\n\n  /**\n   * Returns a value for a number that's appropriate to put into a proto.\n   * The return value is an IntegerValue if it can safely represent the value,\n   * otherwise a DoubleValue is returned.\n   */\n  toNumber(value: number): api.Value {\n    return isSafeInteger(value) ? this.toInteger(value) : this.toDouble(value);\n  }\n\n  /**\n   * Returns a value for a Date that's appropriate to put into a proto.\n   */\n  toTimestamp(timestamp: Timestamp): api.Timestamp {\n    if (this.options.useProto3Json) {\n      // Serialize to ISO-8601 date format, but with full nano resolution.\n      // Since JS Date has only millis, let's only use it for the seconds and\n      // then manually add the fractions to the end.\n      const jsDateStr = new Date(timestamp.seconds * 1000).toISOString();\n      // Remove .xxx frac part and Z in the end.\n      const strUntilSeconds = jsDateStr.replace(/\\.\\d*/, '').replace('Z', '');\n      // Pad the fraction out to 9 digits (nanos).\n      const nanoStr = ('000000000' + timestamp.nanoseconds).slice(-9);\n\n      return `${strUntilSeconds}.${nanoStr}Z`;\n    } else {\n      return {\n        seconds: '' + timestamp.seconds,\n        nanos: timestamp.nanoseconds\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } as any;\n    }\n  }\n\n  private fromTimestamp(date: api.Timestamp): Timestamp {\n    const timestamp = normalizeTimestamp(date);\n    return new Timestamp(timestamp.seconds, timestamp.nanos);\n  }\n\n  /**\n   * Returns a value for bytes that's appropriate to put in a proto.\n   *\n   * Visible for testing.\n   */\n  toBytes(bytes: Blob | ByteString): string | Uint8Array {\n    if (this.options.useProto3Json) {\n      return bytes.toBase64();\n    } else {\n      return bytes.toUint8Array();\n    }\n  }\n\n  /**\n   * Returns a ByteString based on the proto string value.\n   */\n  fromBytes(value: string | Uint8Array | undefined): ByteString {\n    if (this.options.useProto3Json) {\n      hardAssert(\n        value === undefined || typeof value === 'string',\n        'value must be undefined or a string when using proto3 Json'\n      );\n      return ByteString.fromBase64String(value ? value : '');\n    } else {\n      hardAssert(\n        value === undefined || value instanceof Uint8Array,\n        'value must be undefined or Uint8Array'\n      );\n      return ByteString.fromUint8Array(value ? value : new Uint8Array());\n    }\n  }\n\n  toVersion(version: SnapshotVersion): api.Timestamp {\n    return this.toTimestamp(version.toTimestamp());\n  }\n\n  fromVersion(version: api.Timestamp): SnapshotVersion {\n    hardAssert(!!version, \"Trying to deserialize version that isn't set\");\n    return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n  }\n\n  toResourceName(path: ResourcePath, databaseId?: DatabaseId): string {\n    return this.fullyQualifiedPrefixPath(databaseId || this.databaseId)\n      .child('documents')\n      .child(path)\n      .canonicalString();\n  }\n\n  fromResourceName(name: string): ResourcePath {\n    const resource = ResourcePath.fromString(name);\n    hardAssert(\n      isValidResourceName(resource),\n      'Tried to deserialize invalid key ' + resource.toString()\n    );\n    return resource;\n  }\n\n  toName(key: DocumentKey): string {\n    return this.toResourceName(key.path);\n  }\n\n  fromName(name: string): DocumentKey {\n    const resource = this.fromResourceName(name);\n    hardAssert(\n      resource.get(1) === this.databaseId.projectId,\n      'Tried to deserialize key from different project: ' +\n        resource.get(1) +\n        ' vs ' +\n        this.databaseId.projectId\n    );\n    hardAssert(\n      (!resource.get(3) && !this.databaseId.database) ||\n        resource.get(3) === this.databaseId.database,\n      'Tried to deserialize key from different database: ' +\n        resource.get(3) +\n        ' vs ' +\n        this.databaseId.database\n    );\n    return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n  }\n\n  toQueryPath(path: ResourcePath): string {\n    return this.toResourceName(path);\n  }\n\n  fromQueryPath(name: string): ResourcePath {\n    const resourceName = this.fromResourceName(name);\n    // In v1beta1 queries for collections at the root did not have a trailing\n    // \"/documents\". In v1 all resource paths contain \"/documents\". Preserve the\n    // ability to read the v1beta1 form for compatibility with queries persisted\n    // in the local target cache.\n    if (resourceName.length === 4) {\n      return ResourcePath.EMPTY_PATH;\n    }\n    return this.extractLocalPathFromResourceName(resourceName);\n  }\n\n  get encodedDatabaseId(): string {\n    const path = new ResourcePath([\n      'projects',\n      this.databaseId.projectId,\n      'databases',\n      this.databaseId.database\n    ]);\n    return path.canonicalString();\n  }\n\n  private fullyQualifiedPrefixPath(databaseId: DatabaseId): ResourcePath {\n    return new ResourcePath([\n      'projects',\n      databaseId.projectId,\n      'databases',\n      databaseId.database\n    ]);\n  }\n\n  private extractLocalPathFromResourceName(\n    resourceName: ResourcePath\n  ): ResourcePath {\n    hardAssert(\n      resourceName.length > 4 && resourceName.get(4) === 'documents',\n      'tried to deserialize invalid key ' + resourceName.toString()\n    );\n    return resourceName.popFirst(5);\n  }\n\n  /** Creates an api.Document from key and fields (but no create/update time) */\n  toMutationDocument(key: DocumentKey, fields: ObjectValue): api.Document {\n    return {\n      name: this.toName(key),\n      fields: fields.proto.mapValue.fields\n    };\n  }\n\n  toDocument(document: Document): api.Document {\n    debugAssert(\n      !document.hasLocalMutations,\n      \"Can't serialize documents with mutations.\"\n    );\n    return {\n      name: this.toName(document.key),\n      fields: document.toProto().mapValue.fields,\n      updateTime: this.toTimestamp(document.version.toTimestamp())\n    };\n  }\n\n  fromDocument(\n    document: api.Document,\n    hasCommittedMutations?: boolean\n  ): Document {\n    const key = this.fromName(document.name!);\n    const version = this.fromVersion(document.updateTime!);\n    const data = new ObjectValue({ mapValue: { fields: document.fields } });\n    return new Document(key, version, data, {\n      hasCommittedMutations: !!hasCommittedMutations\n    });\n  }\n\n  private fromFound(doc: api.BatchGetDocumentsResponse): Document {\n    hardAssert(\n      !!doc.found,\n      'Tried to deserialize a found document from a missing document.'\n    );\n    assertPresent(doc.found.name, 'doc.found.name');\n    assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n    const key = this.fromName(doc.found.name);\n    const version = this.fromVersion(doc.found.updateTime);\n    const data = new ObjectValue({ mapValue: { fields: doc.found.fields } });\n    return new Document(key, version, data, {});\n  }\n\n  private fromMissing(result: api.BatchGetDocumentsResponse): NoDocument {\n    hardAssert(\n      !!result.missing,\n      'Tried to deserialize a missing document from a found document.'\n    );\n    hardAssert(\n      !!result.readTime,\n      'Tried to deserialize a missing document without a read time.'\n    );\n    const key = this.fromName(result.missing);\n    const version = this.fromVersion(result.readTime);\n    return new NoDocument(key, version);\n  }\n\n  fromMaybeDocument(result: api.BatchGetDocumentsResponse): MaybeDocument {\n    if ('found' in result) {\n      return this.fromFound(result);\n    } else if ('missing' in result) {\n      return this.fromMissing(result);\n    }\n    return fail('invalid batch get response: ' + JSON.stringify(result));\n  }\n\n  fromWatchChange(change: api.ListenResponse): WatchChange {\n    let watchChange: WatchChange;\n    if ('targetChange' in change) {\n      assertPresent(change.targetChange, 'targetChange');\n      // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n      // if unset\n      const state = this.fromWatchTargetChangeState(\n        change.targetChange.targetChangeType || 'NO_CHANGE'\n      );\n      const targetIds: TargetId[] = change.targetChange.targetIds || [];\n\n      const resumeToken = this.fromBytes(change.targetChange.resumeToken);\n      const causeProto = change.targetChange!.cause;\n      const cause = causeProto && this.fromRpcStatus(causeProto);\n      watchChange = new WatchTargetChange(\n        state,\n        targetIds,\n        resumeToken,\n        cause || null\n      );\n    } else if ('documentChange' in change) {\n      assertPresent(change.documentChange, 'documentChange');\n      const entityChange = change.documentChange;\n      assertPresent(entityChange.document, 'documentChange.name');\n      assertPresent(entityChange.document.name, 'documentChange.document.name');\n      assertPresent(\n        entityChange.document.updateTime,\n        'documentChange.document.updateTime'\n      );\n      const key = this.fromName(entityChange.document.name);\n      const version = this.fromVersion(entityChange.document.updateTime);\n      const data = new ObjectValue({\n        mapValue: { fields: entityChange.document.fields }\n      });\n      const doc = new Document(key, version, data, {});\n      const updatedTargetIds = entityChange.targetIds || [];\n      const removedTargetIds = entityChange.removedTargetIds || [];\n      watchChange = new DocumentWatchChange(\n        updatedTargetIds,\n        removedTargetIds,\n        doc.key,\n        doc\n      );\n    } else if ('documentDelete' in change) {\n      assertPresent(change.documentDelete, 'documentDelete');\n      const docDelete = change.documentDelete;\n      assertPresent(docDelete.document, 'documentDelete.document');\n      const key = this.fromName(docDelete.document);\n      const version = docDelete.readTime\n        ? this.fromVersion(docDelete.readTime)\n        : SnapshotVersion.min();\n      const doc = new NoDocument(key, version);\n      const removedTargetIds = docDelete.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n    } else if ('documentRemove' in change) {\n      assertPresent(change.documentRemove, 'documentRemove');\n      const docRemove = change.documentRemove;\n      assertPresent(docRemove.document, 'documentRemove');\n      const key = this.fromName(docRemove.document);\n      const removedTargetIds = docRemove.removedTargetIds || [];\n      watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n    } else if ('filter' in change) {\n      // TODO(dimond): implement existence filter parsing with strategy.\n      assertPresent(change.filter, 'filter');\n      const filter = change.filter;\n      assertPresent(filter.targetId, 'filter.targetId');\n      const count = filter.count || 0;\n      const existenceFilter = new ExistenceFilter(count);\n      const targetId = filter.targetId;\n      watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n    } else {\n      return fail('Unknown change type ' + JSON.stringify(change));\n    }\n    return watchChange;\n  }\n\n  fromWatchTargetChangeState(\n    state: api.TargetChangeTargetChangeType\n  ): WatchTargetChangeState {\n    if (state === 'NO_CHANGE') {\n      return WatchTargetChangeState.NoChange;\n    } else if (state === 'ADD') {\n      return WatchTargetChangeState.Added;\n    } else if (state === 'REMOVE') {\n      return WatchTargetChangeState.Removed;\n    } else if (state === 'CURRENT') {\n      return WatchTargetChangeState.Current;\n    } else if (state === 'RESET') {\n      return WatchTargetChangeState.Reset;\n    } else {\n      return fail('Got unexpected TargetChange.state: ' + state);\n    }\n  }\n\n  versionFromListenResponse(change: api.ListenResponse): SnapshotVersion {\n    // We have only reached a consistent snapshot for the entire stream if there\n    // is a read_time set and it applies to all targets (i.e. the list of\n    // targets is empty). The backend is guaranteed to send such responses.\n    if (!('targetChange' in change)) {\n      return SnapshotVersion.min();\n    }\n    const targetChange = change.targetChange!;\n    if (targetChange.targetIds && targetChange.targetIds.length) {\n      return SnapshotVersion.min();\n    }\n    if (!targetChange.readTime) {\n      return SnapshotVersion.min();\n    }\n    return this.fromVersion(targetChange.readTime);\n  }\n\n  toMutation(mutation: Mutation): api.Write {\n    let result: api.Write;\n    if (mutation instanceof SetMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.value)\n      };\n    } else if (mutation instanceof DeleteMutation) {\n      result = { delete: this.toName(mutation.key) };\n    } else if (mutation instanceof PatchMutation) {\n      result = {\n        update: this.toMutationDocument(mutation.key, mutation.data),\n        updateMask: this.toDocumentMask(mutation.fieldMask)\n      };\n    } else if (mutation instanceof TransformMutation) {\n      result = {\n        transform: {\n          document: this.toName(mutation.key),\n          fieldTransforms: mutation.fieldTransforms.map(transform =>\n            this.toFieldTransform(transform)\n          )\n        }\n      };\n    } else if (mutation instanceof VerifyMutation) {\n      result = {\n        verify: this.toName(mutation.key)\n      };\n    } else {\n      return fail('Unknown mutation type ' + mutation.type);\n    }\n\n    if (!mutation.precondition.isNone) {\n      result.currentDocument = this.toPrecondition(mutation.precondition);\n    }\n\n    return result;\n  }\n\n  fromMutation(proto: api.Write): Mutation {\n    const precondition = proto.currentDocument\n      ? this.fromPrecondition(proto.currentDocument)\n      : Precondition.none();\n\n    if (proto.update) {\n      assertPresent(proto.update.name, 'name');\n      const key = this.fromName(proto.update.name);\n      const value = new ObjectValue({\n        mapValue: { fields: proto.update.fields }\n      });\n      if (proto.updateMask) {\n        const fieldMask = this.fromDocumentMask(proto.updateMask);\n        return new PatchMutation(key, value, fieldMask, precondition);\n      } else {\n        return new SetMutation(key, value, precondition);\n      }\n    } else if (proto.delete) {\n      const key = this.fromName(proto.delete);\n      return new DeleteMutation(key, precondition);\n    } else if (proto.transform) {\n      const key = this.fromName(proto.transform.document!);\n      const fieldTransforms = proto.transform.fieldTransforms!.map(transform =>\n        this.fromFieldTransform(transform)\n      );\n      hardAssert(\n        precondition.exists === true,\n        'Transforms only support precondition \"exists == true\"'\n      );\n      return new TransformMutation(key, fieldTransforms);\n    } else if (proto.verify) {\n      const key = this.fromName(proto.verify);\n      return new VerifyMutation(key, precondition);\n    } else {\n      return fail('unknown mutation proto: ' + JSON.stringify(proto));\n    }\n  }\n\n  private toPrecondition(precondition: Precondition): api.Precondition {\n    debugAssert(!precondition.isNone, \"Can't serialize an empty precondition\");\n    if (precondition.updateTime !== undefined) {\n      return {\n        updateTime: this.toVersion(precondition.updateTime)\n      };\n    } else if (precondition.exists !== undefined) {\n      return { exists: precondition.exists };\n    } else {\n      return fail('Unknown precondition');\n    }\n  }\n\n  private fromPrecondition(precondition: api.Precondition): Precondition {\n    if (precondition.updateTime !== undefined) {\n      return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n    } else if (precondition.exists !== undefined) {\n      return Precondition.exists(precondition.exists);\n    } else {\n      return Precondition.none();\n    }\n  }\n\n  private fromWriteResult(\n    proto: api.WriteResult,\n    commitTime: api.Timestamp\n  ): MutationResult {\n    // NOTE: Deletes don't have an updateTime.\n    let version = proto.updateTime\n      ? this.fromVersion(proto.updateTime)\n      : this.fromVersion(commitTime);\n\n    if (version.isEqual(SnapshotVersion.min())) {\n      // The Firestore Emulator currently returns an update time of 0 for\n      // deletes of non-existing documents (rather than null). This breaks the\n      // test \"get deleted doc while offline with source=cache\" as NoDocuments\n      // with version 0 are filtered by IndexedDb's RemoteDocumentCache.\n      // TODO(#2149): Remove this when Emulator is fixed\n      version = this.fromVersion(commitTime);\n    }\n\n    let transformResults: api.Value[] | null = null;\n    if (proto.transformResults && proto.transformResults.length > 0) {\n      transformResults = proto.transformResults;\n    }\n    return new MutationResult(version, transformResults);\n  }\n\n  fromWriteResults(\n    protos: api.WriteResult[] | undefined,\n    commitTime?: api.Timestamp\n  ): MutationResult[] {\n    if (protos && protos.length > 0) {\n      hardAssert(\n        commitTime !== undefined,\n        'Received a write result without a commit time'\n      );\n      return protos.map(proto => this.fromWriteResult(proto, commitTime));\n    } else {\n      return [];\n    }\n  }\n\n  private toFieldTransform(fieldTransform: FieldTransform): api.FieldTransform {\n    const transform = fieldTransform.transform;\n    if (transform instanceof ServerTimestampTransform) {\n      return {\n        fieldPath: fieldTransform.field.canonicalString(),\n        setToServerValue: 'REQUEST_TIME'\n      };\n    } else if (transform instanceof ArrayUnionTransformOperation) {\n      return {\n        fieldPath: fieldTransform.field.canonicalString(),\n        appendMissingElements: {\n          values: transform.elements\n        }\n      };\n    } else if (transform instanceof ArrayRemoveTransformOperation) {\n      return {\n        fieldPath: fieldTransform.field.canonicalString(),\n        removeAllFromArray: {\n          values: transform.elements\n        }\n      };\n    } else if (transform instanceof NumericIncrementTransformOperation) {\n      return {\n        fieldPath: fieldTransform.field.canonicalString(),\n        increment: transform.operand\n      };\n    } else {\n      throw fail('Unknown transform: ' + fieldTransform.transform);\n    }\n  }\n\n  private fromFieldTransform(proto: api.FieldTransform): FieldTransform {\n    let transform: TransformOperation | null = null;\n    if ('setToServerValue' in proto) {\n      hardAssert(\n        proto.setToServerValue === 'REQUEST_TIME',\n        'Unknown server value transform proto: ' + JSON.stringify(proto)\n      );\n      transform = ServerTimestampTransform.instance;\n    } else if ('appendMissingElements' in proto) {\n      const values = proto.appendMissingElements!.values || [];\n      transform = new ArrayUnionTransformOperation(values);\n    } else if ('removeAllFromArray' in proto) {\n      const values = proto.removeAllFromArray!.values || [];\n      transform = new ArrayRemoveTransformOperation(values);\n    } else if ('increment' in proto) {\n      transform = new NumericIncrementTransformOperation(\n        this,\n        proto.increment!\n      );\n    } else {\n      fail('Unknown transform proto: ' + JSON.stringify(proto));\n    }\n    const fieldPath = FieldPath.fromServerFormat(proto.fieldPath!);\n    return new FieldTransform(fieldPath, transform!);\n  }\n\n  toDocumentsTarget(target: Target): api.DocumentsTarget {\n    return { documents: [this.toQueryPath(target.path)] };\n  }\n\n  fromDocumentsTarget(documentsTarget: api.DocumentsTarget): Target {\n    const count = documentsTarget.documents!.length;\n    hardAssert(\n      count === 1,\n      'DocumentsTarget contained other than 1 document: ' + count\n    );\n    const name = documentsTarget.documents![0];\n    return Query.atPath(this.fromQueryPath(name)).toTarget();\n  }\n\n  toQueryTarget(target: Target): api.QueryTarget {\n    // Dissect the path into parent, collectionId, and optional key filter.\n    const result: api.QueryTarget = { structuredQuery: {} };\n    const path = target.path;\n    if (target.collectionGroup !== null) {\n      debugAssert(\n        path.length % 2 === 0,\n        'Collection Group queries should be within a document path or root.'\n      );\n      result.parent = this.toQueryPath(path);\n      result.structuredQuery!.from = [\n        {\n          collectionId: target.collectionGroup,\n          allDescendants: true\n        }\n      ];\n    } else {\n      debugAssert(\n        path.length % 2 !== 0,\n        'Document queries with filters are not supported.'\n      );\n      result.parent = this.toQueryPath(path.popLast());\n      result.structuredQuery!.from = [{ collectionId: path.lastSegment() }];\n    }\n\n    const where = this.toFilter(target.filters);\n    if (where) {\n      result.structuredQuery!.where = where;\n    }\n\n    const orderBy = this.toOrder(target.orderBy);\n    if (orderBy) {\n      result.structuredQuery!.orderBy = orderBy;\n    }\n\n    const limit = this.toInt32Proto(target.limit);\n    if (limit !== null) {\n      result.structuredQuery!.limit = limit;\n    }\n\n    if (target.startAt) {\n      result.structuredQuery!.startAt = this.toCursor(target.startAt);\n    }\n    if (target.endAt) {\n      result.structuredQuery!.endAt = this.toCursor(target.endAt);\n    }\n\n    return result;\n  }\n\n  fromQueryTarget(target: api.QueryTarget): Target {\n    let path = this.fromQueryPath(target.parent!);\n\n    const query = target.structuredQuery!;\n    const fromCount = query.from ? query.from.length : 0;\n    let collectionGroup: string | null = null;\n    if (fromCount > 0) {\n      hardAssert(\n        fromCount === 1,\n        'StructuredQuery.from with more than one collection is not supported.'\n      );\n      const from = query.from![0];\n      if (from.allDescendants) {\n        collectionGroup = from.collectionId!;\n      } else {\n        path = path.child(from.collectionId!);\n      }\n    }\n\n    let filterBy: Filter[] = [];\n    if (query.where) {\n      filterBy = this.fromFilter(query.where);\n    }\n\n    let orderBy: OrderBy[] = [];\n    if (query.orderBy) {\n      orderBy = this.fromOrder(query.orderBy);\n    }\n\n    let limit: number | null = null;\n    if (query.limit) {\n      limit = this.fromInt32Proto(query.limit);\n    }\n\n    let startAt: Bound | null = null;\n    if (query.startAt) {\n      startAt = this.fromCursor(query.startAt);\n    }\n\n    let endAt: Bound | null = null;\n    if (query.endAt) {\n      endAt = this.fromCursor(query.endAt);\n    }\n\n    return new Query(\n      path,\n      collectionGroup,\n      orderBy,\n      filterBy,\n      limit,\n      LimitType.First,\n      startAt,\n      endAt\n    ).toTarget();\n  }\n\n  toListenRequestLabels(\n    targetData: TargetData\n  ): api.ApiClientObjectMap<string> | null {\n    const value = this.toLabel(targetData.purpose);\n    if (value == null) {\n      return null;\n    } else {\n      return {\n        'goog-listen-tags': value\n      };\n    }\n  }\n\n  private toLabel(purpose: TargetPurpose): string | null {\n    switch (purpose) {\n      case TargetPurpose.Listen:\n        return null;\n      case TargetPurpose.ExistenceFilterMismatch:\n        return 'existence-filter-mismatch';\n      case TargetPurpose.LimboResolution:\n        return 'limbo-document';\n      default:\n        return fail('Unrecognized query purpose: ' + purpose);\n    }\n  }\n\n  toTarget(targetData: TargetData): api.Target {\n    let result: api.Target;\n    const target = targetData.target;\n\n    if (target.isDocumentQuery()) {\n      result = { documents: this.toDocumentsTarget(target) };\n    } else {\n      result = { query: this.toQueryTarget(target) };\n    }\n\n    result.targetId = targetData.targetId;\n\n    if (targetData.resumeToken.approximateByteSize() > 0) {\n      result.resumeToken = this.toBytes(targetData.resumeToken);\n    }\n\n    return result;\n  }\n\n  private toFilter(filters: Filter[]): api.Filter | undefined {\n    if (filters.length === 0) {\n      return;\n    }\n    const protos = filters.map(filter => {\n      if (filter instanceof FieldFilter) {\n        return this.toUnaryOrFieldFilter(filter);\n      } else {\n        return fail('Unrecognized filter: ' + JSON.stringify(filter));\n      }\n    });\n    if (protos.length === 1) {\n      return protos[0];\n    }\n    return { compositeFilter: { op: 'AND', filters: protos } };\n  }\n\n  private fromFilter(filter: api.Filter | undefined): Filter[] {\n    if (!filter) {\n      return [];\n    } else if (filter.unaryFilter !== undefined) {\n      return [this.fromUnaryFilter(filter)];\n    } else if (filter.fieldFilter !== undefined) {\n      return [this.fromFieldFilter(filter)];\n    } else if (filter.compositeFilter !== undefined) {\n      return filter.compositeFilter\n        .filters!.map(f => this.fromFilter(f))\n        .reduce((accum, current) => accum.concat(current));\n    } else {\n      return fail('Unknown filter: ' + JSON.stringify(filter));\n    }\n  }\n\n  private toOrder(orderBys: OrderBy[]): api.Order[] | undefined {\n    if (orderBys.length === 0) {\n      return;\n    }\n    return orderBys.map(order => this.toPropertyOrder(order));\n  }\n\n  private fromOrder(orderBys: api.Order[]): OrderBy[] {\n    return orderBys.map(order => this.fromPropertyOrder(order));\n  }\n\n  private toCursor(cursor: Bound): api.Cursor {\n    return {\n      before: cursor.before,\n      values: cursor.position\n    };\n  }\n\n  private fromCursor(cursor: api.Cursor): Bound {\n    const before = !!cursor.before;\n    const position = cursor.values || [];\n    return new Bound(position, before);\n  }\n\n  // visible for testing\n  toDirection(dir: Direction): api.OrderDirection {\n    return DIRECTIONS[dir];\n  }\n\n  // visible for testing\n  fromDirection(dir: api.OrderDirection | undefined): Direction | undefined {\n    switch (dir) {\n      case 'ASCENDING':\n        return Direction.ASCENDING;\n      case 'DESCENDING':\n        return Direction.DESCENDING;\n      default:\n        return undefined;\n    }\n  }\n\n  // visible for testing\n  toOperatorName(op: Operator): api.FieldFilterOp {\n    return OPERATORS[op];\n  }\n\n  fromOperatorName(op: api.FieldFilterOp): Operator {\n    switch (op) {\n      case 'EQUAL':\n        return Operator.EQUAL;\n      case 'GREATER_THAN':\n        return Operator.GREATER_THAN;\n      case 'GREATER_THAN_OR_EQUAL':\n        return Operator.GREATER_THAN_OR_EQUAL;\n      case 'LESS_THAN':\n        return Operator.LESS_THAN;\n      case 'LESS_THAN_OR_EQUAL':\n        return Operator.LESS_THAN_OR_EQUAL;\n      case 'ARRAY_CONTAINS':\n        return Operator.ARRAY_CONTAINS;\n      case 'IN':\n        return Operator.IN;\n      case 'ARRAY_CONTAINS_ANY':\n        return Operator.ARRAY_CONTAINS_ANY;\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified operator');\n      default:\n        return fail('Unknown operator');\n    }\n  }\n\n  toFieldPathReference(path: FieldPath): api.FieldReference {\n    return { fieldPath: path.canonicalString() };\n  }\n\n  fromFieldPathReference(fieldReference: api.FieldReference): FieldPath {\n    return FieldPath.fromServerFormat(fieldReference.fieldPath!);\n  }\n\n  // visible for testing\n  toPropertyOrder(orderBy: OrderBy): api.Order {\n    return {\n      field: this.toFieldPathReference(orderBy.field),\n      direction: this.toDirection(orderBy.dir)\n    };\n  }\n\n  fromPropertyOrder(orderBy: api.Order): OrderBy {\n    return new OrderBy(\n      this.fromFieldPathReference(orderBy.field!),\n      this.fromDirection(orderBy.direction)\n    );\n  }\n\n  fromFieldFilter(filter: api.Filter): Filter {\n    return FieldFilter.create(\n      this.fromFieldPathReference(filter.fieldFilter!.field!),\n      this.fromOperatorName(filter.fieldFilter!.op!),\n      filter.fieldFilter!.value!\n    );\n  }\n\n  // visible for testing\n  toUnaryOrFieldFilter(filter: FieldFilter): api.Filter {\n    if (filter.op === Operator.EQUAL) {\n      if (isNanValue(filter.value)) {\n        return {\n          unaryFilter: {\n            field: this.toFieldPathReference(filter.field),\n            op: 'IS_NAN'\n          }\n        };\n      } else if (isNullValue(filter.value)) {\n        return {\n          unaryFilter: {\n            field: this.toFieldPathReference(filter.field),\n            op: 'IS_NULL'\n          }\n        };\n      }\n    }\n    return {\n      fieldFilter: {\n        field: this.toFieldPathReference(filter.field),\n        op: this.toOperatorName(filter.op),\n        value: filter.value\n      }\n    };\n  }\n\n  fromUnaryFilter(filter: api.Filter): Filter {\n    switch (filter.unaryFilter!.op!) {\n      case 'IS_NAN':\n        const nanField = this.fromFieldPathReference(\n          filter.unaryFilter!.field!\n        );\n        return FieldFilter.create(nanField, Operator.EQUAL, {\n          doubleValue: NaN\n        });\n      case 'IS_NULL':\n        const nullField = this.fromFieldPathReference(\n          filter.unaryFilter!.field!\n        );\n        return FieldFilter.create(nullField, Operator.EQUAL, {\n          nullValue: 'NULL_VALUE'\n        });\n      case 'OPERATOR_UNSPECIFIED':\n        return fail('Unspecified filter');\n      default:\n        return fail('Unknown filter');\n    }\n  }\n\n  toDocumentMask(fieldMask: FieldMask): api.DocumentMask {\n    const canonicalFields: string[] = [];\n    fieldMask.fields.forEach(field =>\n      canonicalFields.push(field.canonicalString())\n    );\n    return {\n      fieldPaths: canonicalFields\n    };\n  }\n\n  fromDocumentMask(proto: api.DocumentMask): FieldMask {\n    const paths = proto.fieldPaths || [];\n    return new FieldMask(paths.map(path => FieldPath.fromServerFormat(path)));\n  }\n}\n\nexport function isValidResourceName(path: ResourcePath): boolean {\n  // Resource names have at least 4 components (project ID, database ID)\n  return (\n    path.length >= 4 &&\n    path.get(0) === 'projects' &&\n    path.get(2) === 'databases'\n  );\n}\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from '@firebase/firestore-types';\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { DocumentKeyReference } from './user_data_reader';\nimport { Blob } from './blob';\nimport { GeoPoint } from './geo_point';\nimport { Timestamp } from './timestamp';\nimport { DatabaseId } from '../core/database_info';\nimport { DocumentKey } from '../model/document_key';\nimport {\n  normalizeByteString,\n  normalizeNumber,\n  normalizeTimestamp,\n  typeOrder\n} from '../model/values';\nimport {\n  getLocalWriteTime,\n  getPreviousValue\n} from '../model/server_timestamps';\nimport { fail, hardAssert } from '../util/assert';\nimport { forEach } from '../util/obj';\nimport { TypeOrder } from '../model/object_value';\nimport { ResourcePath } from '../model/path';\nimport { isValidResourceName } from '../remote/serializer';\nimport { logError } from '../util/log';\n\nexport type ServerTimestampBehavior = 'estimate' | 'previous' | 'none';\n\n/**\n * Converts Firestore's internal types to the JavaScript types that we expose\n * to the user.\n */\nexport class UserDataWriter {\n  constructor(\n    private readonly databaseId: DatabaseId,\n    private readonly timestampsInSnapshots: boolean,\n    private readonly serverTimestampBehavior: ServerTimestampBehavior,\n    private readonly referenceFactory: (\n      key: DocumentKey\n    ) => DocumentKeyReference<firestore.DocumentData>\n  ) {}\n\n  convertValue(value: api.Value): unknown {\n    switch (typeOrder(value)) {\n      case TypeOrder.NullValue:\n        return null;\n      case TypeOrder.BooleanValue:\n        return value.booleanValue!;\n      case TypeOrder.NumberValue:\n        return normalizeNumber(value.integerValue || value.doubleValue);\n      case TypeOrder.TimestampValue:\n        return this.convertTimestamp(value.timestampValue!);\n      case TypeOrder.ServerTimestampValue:\n        return this.convertServerTimestamp(value);\n      case TypeOrder.StringValue:\n        return value.stringValue!;\n      case TypeOrder.BlobValue:\n        return new Blob(normalizeByteString(value.bytesValue!));\n      case TypeOrder.RefValue:\n        return this.convertReference(value.referenceValue!);\n      case TypeOrder.GeoPointValue:\n        return this.convertGeoPoint(value.geoPointValue!);\n      case TypeOrder.ArrayValue:\n        return this.convertArray(value.arrayValue!);\n      case TypeOrder.ObjectValue:\n        return this.convertObject(value.mapValue!);\n      default:\n        throw fail('Invalid value type: ' + JSON.stringify(value));\n    }\n  }\n\n  private convertObject(mapValue: api.MapValue): firestore.DocumentData {\n    const result: firestore.DocumentData = {};\n    forEach(mapValue.fields || {}, (key, value) => {\n      result[key] = this.convertValue(value);\n    });\n    return result;\n  }\n\n  private convertGeoPoint(value: api.LatLng): GeoPoint {\n    return new GeoPoint(\n      normalizeNumber(value.latitude),\n      normalizeNumber(value.longitude)\n    );\n  }\n\n  private convertArray(arrayValue: api.ArrayValue): unknown[] {\n    return (arrayValue.values || []).map(value => this.convertValue(value));\n  }\n\n  private convertServerTimestamp(value: api.Value): unknown {\n    switch (this.serverTimestampBehavior) {\n      case 'previous':\n        const previousValue = getPreviousValue(value);\n        if (previousValue == null) {\n          return null;\n        }\n        return this.convertValue(previousValue);\n      case 'estimate':\n        return this.convertTimestamp(getLocalWriteTime(value));\n      default:\n        return null;\n    }\n  }\n\n  private convertTimestamp(value: api.Timestamp): Timestamp | Date {\n    const normalizedValue = normalizeTimestamp(value);\n    const timestamp = new Timestamp(\n      normalizedValue.seconds,\n      normalizedValue.nanos\n    );\n    if (this.timestampsInSnapshots) {\n      return timestamp;\n    } else {\n      return timestamp.toDate();\n    }\n  }\n\n  private convertReference(\n    name: string\n  ): DocumentKeyReference<firestore.DocumentData> {\n    const resourcePath = ResourcePath.fromString(name);\n    hardAssert(\n      isValidResourceName(resourcePath),\n      'ReferenceValue is not valid ' + name\n    );\n    const databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));\n    const key = new DocumentKey(resourcePath.popFirst(5));\n\n    if (!databaseId.isEqual(this.databaseId)) {\n      // TODO(b/64130202): Somehow support foreign references.\n      logError(\n        `Document ${key} contains a document ` +\n          `reference within a different database (` +\n          `${databaseId.projectId}/${databaseId.database}) which is not ` +\n          `supported. It will be treated as a reference in the current ` +\n          `database (${this.databaseId.projectId}/${this.databaseId.database}) ` +\n          `instead.`\n      );\n    }\n\n    return this.referenceFactory(key);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as firestore from '@firebase/firestore-types';\n\nimport * as api from '../protos/firestore_proto_api';\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport { _FirebaseApp, FirebaseService } from '@firebase/app-types/private';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { ListenOptions } from '../core/event_manager';\nimport {\n  ComponentProvider,\n  MemoryComponentProvider\n} from '../core/component_provider';\nimport { FirestoreClient, PersistenceSettings } from '../core/firestore_client';\nimport {\n  Bound,\n  Direction,\n  FieldFilter,\n  Filter,\n  Operator,\n  OrderBy,\n  Query as InternalQuery\n} from '../core/query';\nimport { Transaction as InternalTransaction } from '../core/transaction';\nimport { ChangeType, ViewSnapshot } from '../core/view_snapshot';\nimport { LruParams } from '../local/lru_garbage_collector';\nimport { Document, MaybeDocument, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DeleteMutation, Mutation, Precondition } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { isServerTimestamp } from '../model/server_timestamps';\nimport { refValue } from '../model/values';\nimport { PlatformSupport } from '../platform/platform';\nimport { debugAssert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport {\n  invalidClassError,\n  validateArgType,\n  validateAtLeastNumberOfArgs,\n  validateBetweenNumberOfArgs,\n  validateDefined,\n  validateExactNumberOfArgs,\n  validateNamedOptionalPropertyEquals,\n  validateNamedOptionalType,\n  validateNamedType,\n  validateOptionalArgType,\n  validateOptionalArrayElements,\n  validateOptionNames,\n  validatePositiveNumber,\n  validateStringEnum,\n  valueDescription\n} from '../util/input_validation';\nimport { getLogLevel, logError, LogLevel, setLogLevel } from '../util/log';\nimport { AutoId } from '../util/misc';\nimport { Deferred, Rejecter, Resolver } from '../util/promise';\nimport { FieldPath as ExternalFieldPath } from './field_path';\n\nimport {\n  CredentialsProvider,\n  CredentialsSettings,\n  EmptyCredentialsProvider,\n  FirebaseCredentialsProvider,\n  makeCredentialsProvider\n} from './credentials';\nimport {\n  CompleteFn,\n  ErrorFn,\n  isPartialObserver,\n  NextFn,\n  PartialObserver,\n  Unsubscribe\n} from './observer';\nimport {\n  DocumentKeyReference,\n  fieldPathFromArgument,\n  UntypedFirestoreDataConverter,\n  UserDataReader\n} from './user_data_reader';\nimport { UserDataWriter } from './user_data_writer';\nimport { FirebaseAuthInternalName } from '@firebase/auth-interop-types';\nimport { Provider } from '@firebase/component';\n\n// settings() defaults:\nconst DEFAULT_HOST = 'firestore.googleapis.com';\nconst DEFAULT_SSL = true;\nconst DEFAULT_TIMESTAMPS_IN_SNAPSHOTS = true;\nconst DEFAULT_FORCE_LONG_POLLING = false;\nconst DEFAULT_IGNORE_UNDEFINED_PROPERTIES = false;\n\n/**\n * Constant used to indicate the LRU garbage collection should be disabled.\n * Set this value as the `cacheSizeBytes` on the settings passed to the\n * `Firestore` instance.\n */\nexport const CACHE_SIZE_UNLIMITED = LruParams.COLLECTION_DISABLED;\n\n// enablePersistence() defaults:\nconst DEFAULT_SYNCHRONIZE_TABS = false;\n\n/** Undocumented, private additional settings not exposed in our public API. */\ninterface PrivateSettings extends firestore.Settings {\n  // Can be a google-auth-library or gapi client.\n  credentials?: CredentialsSettings;\n}\n\n/**\n * Options that can be provided in the Firestore constructor when not using\n * Firebase (aka standalone mode).\n */\nexport interface FirestoreDatabase {\n  projectId: string;\n  database?: string;\n}\n\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nclass FirestoreSettings {\n  /** The hostname to connect to. */\n  readonly host: string;\n\n  /** Whether to use SSL when connecting. */\n  readonly ssl: boolean;\n\n  readonly timestampsInSnapshots: boolean;\n\n  readonly cacheSizeBytes: number;\n\n  readonly forceLongPolling: boolean;\n\n  readonly ignoreUndefinedProperties: boolean;\n\n  // Can be a google-auth-library or gapi client.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  credentials?: any;\n\n  constructor(settings: PrivateSettings) {\n    if (settings.host === undefined) {\n      if (settings.ssl !== undefined) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          \"Can't provide ssl option if host option is not set\"\n        );\n      }\n      this.host = DEFAULT_HOST;\n      this.ssl = DEFAULT_SSL;\n    } else {\n      validateNamedType('settings', 'non-empty string', 'host', settings.host);\n      this.host = settings.host;\n\n      validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n      this.ssl = settings.ssl ?? DEFAULT_SSL;\n    }\n    validateOptionNames('settings', settings, [\n      'host',\n      'ssl',\n      'credentials',\n      'timestampsInSnapshots',\n      'cacheSizeBytes',\n      'experimentalForceLongPolling',\n      'ignoreUndefinedProperties'\n    ]);\n\n    validateNamedOptionalType(\n      'settings',\n      'object',\n      'credentials',\n      settings.credentials\n    );\n    this.credentials = settings.credentials;\n\n    validateNamedOptionalType(\n      'settings',\n      'boolean',\n      'timestampsInSnapshots',\n      settings.timestampsInSnapshots\n    );\n\n    validateNamedOptionalType(\n      'settings',\n      'boolean',\n      'ignoreUndefinedProperties',\n      settings.ignoreUndefinedProperties\n    );\n\n    // Nobody should set timestampsInSnapshots anymore, but the error depends on\n    // whether they set it to true or false...\n    if (settings.timestampsInSnapshots === true) {\n      logError(\n        \"The setting 'timestampsInSnapshots: true' is no longer required \" +\n          'and should be removed.'\n      );\n    } else if (settings.timestampsInSnapshots === false) {\n      logError(\n        \"Support for 'timestampsInSnapshots: false' will be removed soon. \" +\n          'You must update your code to handle Timestamp objects.'\n      );\n    }\n    this.timestampsInSnapshots =\n      settings.timestampsInSnapshots ?? DEFAULT_TIMESTAMPS_IN_SNAPSHOTS;\n    this.ignoreUndefinedProperties =\n      settings.ignoreUndefinedProperties ?? DEFAULT_IGNORE_UNDEFINED_PROPERTIES;\n\n    validateNamedOptionalType(\n      'settings',\n      'number',\n      'cacheSizeBytes',\n      settings.cacheSizeBytes\n    );\n    if (settings.cacheSizeBytes === undefined) {\n      this.cacheSizeBytes = LruParams.DEFAULT_CACHE_SIZE_BYTES;\n    } else {\n      if (\n        settings.cacheSizeBytes !== CACHE_SIZE_UNLIMITED &&\n        settings.cacheSizeBytes < LruParams.MINIMUM_CACHE_SIZE_BYTES\n      ) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `cacheSizeBytes must be at least ${LruParams.MINIMUM_CACHE_SIZE_BYTES}`\n        );\n      } else {\n        this.cacheSizeBytes = settings.cacheSizeBytes;\n      }\n    }\n\n    validateNamedOptionalType(\n      'settings',\n      'boolean',\n      'experimentalForceLongPolling',\n      settings.experimentalForceLongPolling\n    );\n    this.forceLongPolling =\n      settings.experimentalForceLongPolling ?? DEFAULT_FORCE_LONG_POLLING;\n  }\n\n  isEqual(other: FirestoreSettings): boolean {\n    return (\n      this.host === other.host &&\n      this.ssl === other.ssl &&\n      this.timestampsInSnapshots === other.timestampsInSnapshots &&\n      this.credentials === other.credentials &&\n      this.cacheSizeBytes === other.cacheSizeBytes &&\n      this.forceLongPolling === other.forceLongPolling &&\n      this.ignoreUndefinedProperties === other.ignoreUndefinedProperties\n    );\n  }\n}\n\n/**\n * The root reference to the database.\n */\nexport class Firestore implements firestore.FirebaseFirestore, FirebaseService {\n  // The objects that are a part of this API are exposed to third-parties as\n  // compiled javascript so we want to flag our private members with a leading\n  // underscore to discourage their use.\n  readonly _databaseId: DatabaseId;\n  private readonly _persistenceKey: string;\n  private readonly _componentProvider: ComponentProvider;\n  private _credentials: CredentialsProvider;\n  private readonly _firebaseApp: FirebaseApp | null = null;\n  private _settings: FirestoreSettings;\n\n  // The firestore client instance. This will be available as soon as\n  // configureClient is called, but any calls against it will block until\n  // setup has completed.\n  //\n  // Operations on the _firestoreClient don't block on _firestoreReady. Those\n  // are already set to synchronize on the async queue.\n  private _firestoreClient: FirestoreClient | undefined;\n\n  // Public for use in tests.\n  // TODO(mikelehen): Use modularized initialization instead.\n  readonly _queue = new AsyncQueue();\n\n  _userDataReader: UserDataReader | undefined;\n\n  // Note: We are using `MemoryComponentProvider` as a default\n  // ComponentProvider to ensure backwards compatibility with the format\n  // expected by the console build.\n  constructor(\n    databaseIdOrApp: FirestoreDatabase | FirebaseApp,\n    authProvider: Provider<FirebaseAuthInternalName>,\n    componentProvider: ComponentProvider = new MemoryComponentProvider()\n  ) {\n    if (typeof (databaseIdOrApp as FirebaseApp).options === 'object') {\n      // This is very likely a Firebase app object\n      // TODO(b/34177605): Can we somehow use instanceof?\n      const app = databaseIdOrApp as FirebaseApp;\n      this._firebaseApp = app;\n      this._databaseId = Firestore.databaseIdFromApp(app);\n      this._persistenceKey = app.name;\n      this._credentials = new FirebaseCredentialsProvider(authProvider);\n    } else {\n      const external = databaseIdOrApp as FirestoreDatabase;\n      if (!external.projectId) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Must provide projectId'\n        );\n      }\n\n      this._databaseId = new DatabaseId(external.projectId, external.database);\n      // Use a default persistenceKey that lines up with FirebaseApp.\n      this._persistenceKey = '[DEFAULT]';\n      this._credentials = new EmptyCredentialsProvider();\n    }\n\n    this._componentProvider = componentProvider;\n    this._settings = new FirestoreSettings({});\n  }\n\n  get _dataReader(): UserDataReader {\n    debugAssert(\n      !!this._firestoreClient,\n      'Cannot obtain UserDataReader before instance is intitialized'\n    );\n    if (!this._userDataReader) {\n      // Lazy initialize UserDataReader once the settings are frozen\n      this._userDataReader = new UserDataReader(\n        this._databaseId,\n        this._settings.ignoreUndefinedProperties\n      );\n    }\n    return this._userDataReader;\n  }\n\n  settings(settingsLiteral: firestore.Settings): void {\n    validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n    validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n\n    const newSettings = new FirestoreSettings(settingsLiteral);\n    if (this._firestoreClient && !this._settings.isEqual(newSettings)) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Firestore has already been started and its settings can no longer ' +\n          'be changed. You can only call settings() before calling any other ' +\n          'methods on a Firestore object.'\n      );\n    }\n\n    this._settings = newSettings;\n    if (newSettings.credentials !== undefined) {\n      this._credentials = makeCredentialsProvider(newSettings.credentials);\n    }\n  }\n\n  enableNetwork(): Promise<void> {\n    this.ensureClientConfigured();\n    return this._firestoreClient!.enableNetwork();\n  }\n\n  disableNetwork(): Promise<void> {\n    this.ensureClientConfigured();\n    return this._firestoreClient!.disableNetwork();\n  }\n\n  enablePersistence(settings?: firestore.PersistenceSettings): Promise<void> {\n    if (this._firestoreClient) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Firestore has already been started and persistence can no longer ' +\n          'be enabled. You can only call enablePersistence() before calling ' +\n          'any other methods on a Firestore object.'\n      );\n    }\n\n    let synchronizeTabs = false;\n    let experimentalForceOwningTab = false;\n\n    if (settings) {\n      if (settings.experimentalTabSynchronization !== undefined) {\n        logError(\n          \"The 'experimentalTabSynchronization' setting will be removed. Use 'synchronizeTabs' instead.\"\n        );\n      }\n      synchronizeTabs =\n        settings.synchronizeTabs ??\n        settings.experimentalTabSynchronization ??\n        DEFAULT_SYNCHRONIZE_TABS;\n\n      experimentalForceOwningTab = settings.experimentalForceOwningTab\n        ? settings.experimentalForceOwningTab\n        : false;\n\n      if (synchronizeTabs && experimentalForceOwningTab) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          \"The 'experimentalForceOwningTab' setting cannot be used with 'synchronizeTabs'.\"\n        );\n      }\n    }\n\n    return this.configureClient(this._componentProvider, {\n      durable: true,\n      cacheSizeBytes: this._settings.cacheSizeBytes,\n      synchronizeTabs,\n      forceOwningTab: experimentalForceOwningTab\n    });\n  }\n\n  async clearPersistence(): Promise<void> {\n    if (\n      this._firestoreClient !== undefined &&\n      !this._firestoreClient.clientTerminated\n    ) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'Persistence cannot be cleared after this Firestore instance is initialized.'\n      );\n    }\n\n    const deferred = new Deferred<void>();\n    this._queue.enqueueAndForgetEvenAfterShutdown(async () => {\n      try {\n        const databaseInfo = this.makeDatabaseInfo();\n        await this._componentProvider.clearPersistence(databaseInfo);\n        deferred.resolve();\n      } catch (e) {\n        deferred.reject(e);\n      }\n    });\n    return deferred.promise;\n  }\n\n  terminate(): Promise<void> {\n    (this.app as _FirebaseApp)._removeServiceInstance('firestore');\n    return this.INTERNAL.delete();\n  }\n\n  get _isTerminated(): boolean {\n    this.ensureClientConfigured();\n    return this._firestoreClient!.clientTerminated;\n  }\n\n  waitForPendingWrites(): Promise<void> {\n    this.ensureClientConfigured();\n    return this._firestoreClient!.waitForPendingWrites();\n  }\n\n  onSnapshotsInSync(observer: PartialObserver<void>): Unsubscribe;\n  onSnapshotsInSync(onSync: () => void): Unsubscribe;\n  onSnapshotsInSync(arg: unknown): Unsubscribe {\n    this.ensureClientConfigured();\n\n    if (isPartialObserver(arg)) {\n      return this.onSnapshotsInSyncInternal(arg as PartialObserver<void>);\n    } else {\n      validateArgType('Firestore.onSnapshotsInSync', 'function', 1, arg);\n      const observer: PartialObserver<void> = {\n        next: arg as () => void\n      };\n      return this.onSnapshotsInSyncInternal(observer);\n    }\n  }\n\n  private onSnapshotsInSyncInternal(\n    observer: PartialObserver<void>\n  ): Unsubscribe {\n    const errHandler = (err: Error): void => {\n      throw fail('Uncaught Error in onSnapshotsInSync');\n    };\n    const asyncObserver = new AsyncObserver<void>({\n      next: () => {\n        if (observer.next) {\n          observer.next();\n        }\n      },\n      error: errHandler\n    });\n    this._firestoreClient!.addSnapshotsInSyncListener(asyncObserver);\n    return () => {\n      asyncObserver.mute();\n      this._firestoreClient!.removeSnapshotsInSyncListener(asyncObserver);\n    };\n  }\n\n  ensureClientConfigured(): FirestoreClient {\n    if (!this._firestoreClient) {\n      // Kick off starting the client but don't actually wait for it.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this.configureClient(new MemoryComponentProvider(), {\n        durable: false\n      });\n    }\n    return this._firestoreClient as FirestoreClient;\n  }\n\n  private makeDatabaseInfo(): DatabaseInfo {\n    return new DatabaseInfo(\n      this._databaseId,\n      this._persistenceKey,\n      this._settings.host,\n      this._settings.ssl,\n      this._settings.forceLongPolling\n    );\n  }\n\n  private configureClient(\n    componentProvider: ComponentProvider,\n    persistenceSettings: PersistenceSettings\n  ): Promise<void> {\n    debugAssert(!!this._settings.host, 'FirestoreSettings.host is not set');\n\n    debugAssert(\n      !this._firestoreClient,\n      'configureClient() called multiple times'\n    );\n\n    const databaseInfo = this.makeDatabaseInfo();\n\n    this._firestoreClient = new FirestoreClient(\n      PlatformSupport.getPlatform(),\n      databaseInfo,\n      this._credentials,\n      this._queue\n    );\n\n    return this._firestoreClient.start(componentProvider, persistenceSettings);\n  }\n\n  private static databaseIdFromApp(app: FirebaseApp): DatabaseId {\n    if (!contains(app.options, 'projectId')) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        '\"projectId\" not provided in firebase.initializeApp.'\n      );\n    }\n\n    const projectId = app.options.projectId;\n    if (!projectId || typeof projectId !== 'string') {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'projectId must be a string in FirebaseApp.options'\n      );\n    }\n    return new DatabaseId(projectId);\n  }\n\n  get app(): FirebaseApp {\n    if (!this._firebaseApp) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n          'not available'\n      );\n    }\n    return this._firebaseApp;\n  }\n\n  INTERNAL = {\n    delete: async (): Promise<void> => {\n      // The client must be initalized to ensure that all subsequent API usage\n      // throws an exception.\n      this.ensureClientConfigured();\n      await this._firestoreClient!.terminate();\n    }\n  };\n\n  collection(pathString: string): firestore.CollectionReference {\n    validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n    validateArgType('Firestore.collection', 'non-empty string', 1, pathString);\n    this.ensureClientConfigured();\n    return new CollectionReference(\n      ResourcePath.fromString(pathString),\n      this,\n      /* converter= */ null\n    );\n  }\n\n  doc(pathString: string): firestore.DocumentReference {\n    validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n    validateArgType('Firestore.doc', 'non-empty string', 1, pathString);\n    this.ensureClientConfigured();\n    return DocumentReference.forPath(\n      ResourcePath.fromString(pathString),\n      this,\n      /* converter= */ null\n    );\n  }\n\n  collectionGroup(collectionId: string): firestore.Query {\n    validateExactNumberOfArgs('Firestore.collectionGroup', arguments, 1);\n    validateArgType(\n      'Firestore.collectionGroup',\n      'non-empty string',\n      1,\n      collectionId\n    );\n    if (collectionId.indexOf('/') >= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid collection ID '${collectionId}' passed to function ` +\n          `Firestore.collectionGroup(). Collection IDs must not contain '/'.`\n      );\n    }\n    this.ensureClientConfigured();\n    return new Query(\n      new InternalQuery(ResourcePath.EMPTY_PATH, collectionId),\n      this,\n      /* converter= */ null\n    );\n  }\n\n  runTransaction<T>(\n    updateFunction: (transaction: firestore.Transaction) => Promise<T>\n  ): Promise<T> {\n    validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n    validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n    return this.ensureClientConfigured().transaction(\n      (transaction: InternalTransaction) => {\n        return updateFunction(new Transaction(this, transaction));\n      }\n    );\n  }\n\n  batch(): firestore.WriteBatch {\n    this.ensureClientConfigured();\n\n    return new WriteBatch(this);\n  }\n\n  static get logLevel(): firestore.LogLevel {\n    switch (getLogLevel()) {\n      case LogLevel.DEBUG:\n        return 'debug';\n      case LogLevel.ERROR:\n        return 'error';\n      case LogLevel.SILENT:\n        return 'silent';\n      case LogLevel.WARN:\n        return 'warn';\n      case LogLevel.INFO:\n        return 'info';\n      case LogLevel.VERBOSE:\n        return 'verbose';\n      default:\n        // The default log level is error\n        return 'error';\n    }\n  }\n\n  static setLogLevel(level: firestore.LogLevel): void {\n    validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n    validateStringEnum(\n      'setLogLevel',\n      ['debug', 'error', 'silent', 'warn', 'info', 'verbose'],\n      1,\n      level\n    );\n    setLogLevel(level);\n  }\n\n  // Note: this is not a property because the minifier can't work correctly with\n  // the way TypeScript compiler outputs properties.\n  _areTimestampsInSnapshotsEnabled(): boolean {\n    return this._settings.timestampsInSnapshots;\n  }\n}\n\n/**\n * A reference to a transaction.\n */\nexport class Transaction implements firestore.Transaction {\n  constructor(\n    private _firestore: Firestore,\n    private _transaction: InternalTransaction\n  ) {}\n\n  get<T>(\n    documentRef: firestore.DocumentReference<T>\n  ): Promise<firestore.DocumentSnapshot<T>> {\n    validateExactNumberOfArgs('Transaction.get', arguments, 1);\n    const ref = validateReference(\n      'Transaction.get',\n      documentRef,\n      this._firestore\n    );\n    return this._transaction\n      .lookup([ref._key])\n      .then((docs: MaybeDocument[]) => {\n        if (!docs || docs.length !== 1) {\n          return fail('Mismatch in docs returned from document lookup.');\n        }\n        const doc = docs[0];\n        if (doc instanceof NoDocument) {\n          return new DocumentSnapshot<T>(\n            this._firestore,\n            ref._key,\n            null,\n            /* fromCache= */ false,\n            /* hasPendingWrites= */ false,\n            ref._converter\n          );\n        } else if (doc instanceof Document) {\n          return new DocumentSnapshot<T>(\n            this._firestore,\n            ref._key,\n            doc,\n            /* fromCache= */ false,\n            /* hasPendingWrites= */ false,\n            ref._converter\n          );\n        } else {\n          throw fail(\n            `BatchGetDocumentsRequest returned unexpected document type: ${doc.constructor.name}`\n          );\n        }\n      });\n  }\n\n  set<T>(\n    documentRef: firestore.DocumentReference<T>,\n    value: T,\n    options?: firestore.SetOptions\n  ): Transaction {\n    validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n    const ref = validateReference(\n      'Transaction.set',\n      documentRef,\n      this._firestore\n    );\n    options = validateSetOptions('Transaction.set', options);\n    const [convertedValue, functionName] = applyFirestoreDataConverter(\n      ref._converter,\n      value,\n      'Transaction.set'\n    );\n    const parsed = this._firestore._dataReader.parseSetData(\n      functionName,\n      convertedValue,\n      options\n    );\n    this._transaction.set(ref._key, parsed);\n    return this;\n  }\n\n  update(\n    documentRef: firestore.DocumentReference<unknown>,\n    value: firestore.UpdateData\n  ): Transaction;\n  update(\n    documentRef: firestore.DocumentReference<unknown>,\n    field: string | ExternalFieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): Transaction;\n  update(\n    documentRef: firestore.DocumentReference<unknown>,\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): Transaction {\n    let ref;\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n      ref = validateReference(\n        'Transaction.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataReader.parseUpdateVarargs(\n        'Transaction.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('Transaction.update', arguments, 2);\n      ref = validateReference(\n        'Transaction.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataReader.parseUpdateData(\n        'Transaction.update',\n        fieldOrUpdateData\n      );\n    }\n\n    this._transaction.update(ref._key, parsed);\n    return this;\n  }\n\n  delete(documentRef: firestore.DocumentReference<unknown>): Transaction {\n    validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n    const ref = validateReference(\n      'Transaction.delete',\n      documentRef,\n      this._firestore\n    );\n    this._transaction.delete(ref._key);\n    return this;\n  }\n}\n\nexport class WriteBatch implements firestore.WriteBatch {\n  private _mutations = [] as Mutation[];\n  private _committed = false;\n\n  constructor(private _firestore: Firestore) {}\n\n  set<T>(\n    documentRef: firestore.DocumentReference<T>,\n    value: T,\n    options?: firestore.SetOptions\n  ): WriteBatch {\n    validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n    this.verifyNotCommitted();\n    const ref = validateReference(\n      'WriteBatch.set',\n      documentRef,\n      this._firestore\n    );\n    options = validateSetOptions('WriteBatch.set', options);\n    const [convertedValue, functionName] = applyFirestoreDataConverter(\n      ref._converter,\n      value,\n      'WriteBatch.set'\n    );\n    const parsed = this._firestore._dataReader.parseSetData(\n      functionName,\n      convertedValue,\n      options\n    );\n    this._mutations = this._mutations.concat(\n      parsed.toMutations(ref._key, Precondition.none())\n    );\n    return this;\n  }\n\n  update(\n    documentRef: firestore.DocumentReference<unknown>,\n    value: firestore.UpdateData\n  ): WriteBatch;\n  update(\n    documentRef: firestore.DocumentReference<unknown>,\n    field: string | ExternalFieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): WriteBatch;\n  update(\n    documentRef: firestore.DocumentReference<unknown>,\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): WriteBatch {\n    this.verifyNotCommitted();\n\n    let ref;\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n      ref = validateReference(\n        'WriteBatch.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataReader.parseUpdateVarargs(\n        'WriteBatch.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n      ref = validateReference(\n        'WriteBatch.update',\n        documentRef,\n        this._firestore\n      );\n      parsed = this._firestore._dataReader.parseUpdateData(\n        'WriteBatch.update',\n        fieldOrUpdateData\n      );\n    }\n\n    this._mutations = this._mutations.concat(\n      parsed.toMutations(ref._key, Precondition.exists(true))\n    );\n    return this;\n  }\n\n  delete(documentRef: firestore.DocumentReference<unknown>): WriteBatch {\n    validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n    this.verifyNotCommitted();\n    const ref = validateReference(\n      'WriteBatch.delete',\n      documentRef,\n      this._firestore\n    );\n    this._mutations = this._mutations.concat(\n      new DeleteMutation(ref._key, Precondition.none())\n    );\n    return this;\n  }\n\n  commit(): Promise<void> {\n    this.verifyNotCommitted();\n    this._committed = true;\n    if (this._mutations.length > 0) {\n      return this._firestore.ensureClientConfigured().write(this._mutations);\n    }\n\n    return Promise.resolve();\n  }\n\n  private verifyNotCommitted(): void {\n    if (this._committed) {\n      throw new FirestoreError(\n        Code.FAILED_PRECONDITION,\n        'A write batch can no longer be used after commit() ' +\n          'has been called.'\n      );\n    }\n  }\n}\n\n/**\n * A reference to a particular document in a collection in the database.\n */\nexport class DocumentReference<T = firestore.DocumentData>\n  extends DocumentKeyReference<T>\n  implements firestore.DocumentReference<T> {\n  private _firestoreClient: FirestoreClient;\n\n  constructor(\n    public _key: DocumentKey,\n    readonly firestore: Firestore,\n    readonly _converter: firestore.FirestoreDataConverter<T> | null\n  ) {\n    super(firestore._databaseId, _key, _converter);\n    this._firestoreClient = this.firestore.ensureClientConfigured();\n  }\n\n  static forPath<U>(\n    path: ResourcePath,\n    firestore: Firestore,\n    converter: firestore.FirestoreDataConverter<U> | null\n  ): DocumentReference<U> {\n    if (path.length % 2 !== 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid document reference. Document ' +\n          'references must have an even number of segments, but ' +\n          `${path.canonicalString()} has ${path.length}`\n      );\n    }\n    return new DocumentReference(new DocumentKey(path), firestore, converter);\n  }\n\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  get parent(): firestore.CollectionReference<T> {\n    return new CollectionReference(\n      this._key.path.popLast(),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  get path(): string {\n    return this._key.path.canonicalString();\n  }\n\n  collection(\n    pathString: string\n  ): firestore.CollectionReference<firestore.DocumentData> {\n    validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n    validateArgType(\n      'DocumentReference.collection',\n      'non-empty string',\n      1,\n      pathString\n    );\n    if (!pathString) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Must provide a non-empty collection name to collection()'\n      );\n    }\n    const path = ResourcePath.fromString(pathString);\n    return new CollectionReference(\n      this._key.path.child(path),\n      this.firestore,\n      /* converter= */ null\n    );\n  }\n\n  isEqual(other: firestore.DocumentReference<T>): boolean {\n    if (!(other instanceof DocumentReference)) {\n      throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n    }\n    return (\n      this.firestore === other.firestore &&\n      this._key.isEqual(other._key) &&\n      this._converter === other._converter\n    );\n  }\n\n  set(\n    value: firestore.DocumentData,\n    options?: firestore.SetOptions\n  ): Promise<void>;\n  set(value: T, options?: firestore.SetOptions): Promise<void> {\n    validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n    options = validateSetOptions('DocumentReference.set', options);\n    const [convertedValue, functionName] = applyFirestoreDataConverter(\n      this._converter,\n      value,\n      'DocumentReference.set'\n    );\n    const parsed = this.firestore._dataReader.parseSetData(\n      functionName,\n      convertedValue,\n      options\n    );\n    return this._firestoreClient.write(\n      parsed.toMutations(this._key, Precondition.none())\n    );\n  }\n\n  update(value: firestore.UpdateData): Promise<void>;\n  update(\n    field: string | ExternalFieldPath,\n    value: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): Promise<void>;\n  update(\n    fieldOrUpdateData: string | ExternalFieldPath | firestore.UpdateData,\n    value?: unknown,\n    ...moreFieldsAndValues: unknown[]\n  ): Promise<void> {\n    let parsed;\n\n    if (\n      typeof fieldOrUpdateData === 'string' ||\n      fieldOrUpdateData instanceof ExternalFieldPath\n    ) {\n      validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n      parsed = this.firestore._dataReader.parseUpdateVarargs(\n        'DocumentReference.update',\n        fieldOrUpdateData,\n        value,\n        moreFieldsAndValues\n      );\n    } else {\n      validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n      parsed = this.firestore._dataReader.parseUpdateData(\n        'DocumentReference.update',\n        fieldOrUpdateData\n      );\n    }\n\n    return this._firestoreClient.write(\n      parsed.toMutations(this._key, Precondition.exists(true))\n    );\n  }\n\n  delete(): Promise<void> {\n    validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n    return this._firestoreClient.write([\n      new DeleteMutation(this._key, Precondition.none())\n    ]);\n  }\n\n  onSnapshot(\n    observer: PartialObserver<firestore.DocumentSnapshot<T>>\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.SnapshotListenOptions,\n    observer: PartialObserver<firestore.DocumentSnapshot<T>>\n  ): Unsubscribe;\n  onSnapshot(\n    onNext: NextFn<firestore.DocumentSnapshot<T>>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.SnapshotListenOptions,\n    onNext: NextFn<firestore.DocumentSnapshot<T>>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n\n  onSnapshot(...args: unknown[]): Unsubscribe {\n    validateBetweenNumberOfArgs(\n      'DocumentReference.onSnapshot',\n      arguments,\n      1,\n      4\n    );\n    let options: firestore.SnapshotListenOptions = {\n      includeMetadataChanges: false\n    };\n    let observer: PartialObserver<firestore.DocumentSnapshot<T>>;\n    let currArg = 0;\n    if (\n      typeof args[currArg] === 'object' &&\n      !isPartialObserver(args[currArg])\n    ) {\n      options = args[currArg] as firestore.SnapshotListenOptions;\n      validateOptionNames('DocumentReference.onSnapshot', options, [\n        'includeMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'DocumentReference.onSnapshot',\n        'boolean',\n        'includeMetadataChanges',\n        options.includeMetadataChanges\n      );\n      currArg++;\n    }\n\n    const internalOptions = {\n      includeMetadataChanges: options.includeMetadataChanges\n    };\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg] as PartialObserver<\n        firestore.DocumentSnapshot<T>\n      >;\n    } else {\n      validateArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg,\n        args[currArg]\n      );\n      validateOptionalArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg + 1,\n        args[currArg + 1]\n      );\n      validateOptionalArgType(\n        'DocumentReference.onSnapshot',\n        'function',\n        currArg + 2,\n        args[currArg + 2]\n      );\n      observer = {\n        next: args[currArg] as NextFn<firestore.DocumentSnapshot<T>>,\n        error: args[currArg + 1] as ErrorFn,\n        complete: args[currArg + 2] as CompleteFn\n      };\n    }\n    return this.onSnapshotInternal(internalOptions, observer);\n  }\n\n  private onSnapshotInternal(\n    options: ListenOptions,\n    observer: PartialObserver<firestore.DocumentSnapshot<T>>\n  ): Unsubscribe {\n    let errHandler = (err: Error): void => {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    const asyncObserver = new AsyncObserver<ViewSnapshot>({\n      next: snapshot => {\n        if (observer.next) {\n          debugAssert(\n            snapshot.docs.size <= 1,\n            'Too many documents returned on a document query'\n          );\n          const doc = snapshot.docs.get(this._key);\n\n          observer.next(\n            new DocumentSnapshot(\n              this.firestore,\n              this._key,\n              doc,\n              snapshot.fromCache,\n              snapshot.hasPendingWrites,\n              this._converter\n            )\n          );\n        }\n      },\n      error: errHandler\n    });\n    const internalListener = this._firestoreClient.listen(\n      InternalQuery.atPath(this._key.path),\n      asyncObserver,\n      options\n    );\n\n    return () => {\n      asyncObserver.mute();\n      this._firestoreClient.unlisten(internalListener);\n    };\n  }\n\n  get(options?: firestore.GetOptions): Promise<firestore.DocumentSnapshot<T>> {\n    validateBetweenNumberOfArgs('DocumentReference.get', arguments, 0, 1);\n    validateGetOptions('DocumentReference.get', options);\n    return new Promise(\n      (resolve: Resolver<firestore.DocumentSnapshot<T>>, reject: Rejecter) => {\n        if (options && options.source === 'cache') {\n          this.firestore\n            .ensureClientConfigured()\n            .getDocumentFromLocalCache(this._key)\n            .then(doc => {\n              resolve(\n                new DocumentSnapshot(\n                  this.firestore,\n                  this._key,\n                  doc,\n                  /*fromCache=*/ true,\n                  doc instanceof Document ? doc.hasLocalMutations : false,\n                  this._converter\n                )\n              );\n            }, reject);\n        } else {\n          this.getViaSnapshotListener(resolve, reject, options);\n        }\n      }\n    );\n  }\n\n  private getViaSnapshotListener(\n    resolve: Resolver<firestore.DocumentSnapshot<T>>,\n    reject: Rejecter,\n    options?: firestore.GetOptions\n  ): void {\n    const unlisten = this.onSnapshotInternal(\n      {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n      },\n      {\n        next: (snap: firestore.DocumentSnapshot<T>) => {\n          // Remove query first before passing event to user to avoid\n          // user actions affecting the now stale query.\n          unlisten();\n\n          if (!snap.exists && snap.metadata.fromCache) {\n            // TODO(dimond): If we're online and the document doesn't\n            // exist then we resolve with a doc.exists set to false. If\n            // we're offline however, we reject the Promise in this\n            // case. Two options: 1) Cache the negative response from\n            // the server so we can deliver that even when you're\n            // offline 2) Actually reject the Promise in the online case\n            // if the document doesn't exist.\n            reject(\n              new FirestoreError(\n                Code.UNAVAILABLE,\n                'Failed to get document because the client is ' + 'offline.'\n              )\n            );\n          } else if (\n            snap.exists &&\n            snap.metadata.fromCache &&\n            options &&\n            options.source === 'server'\n          ) {\n            reject(\n              new FirestoreError(\n                Code.UNAVAILABLE,\n                'Failed to get document from server. (However, this ' +\n                  'document does exist in the local cache. Run again ' +\n                  'without setting source to \"server\" to ' +\n                  'retrieve the cached document.)'\n              )\n            );\n          } else {\n            resolve(snap);\n          }\n        },\n        error: reject\n      }\n    );\n  }\n\n  withConverter<U>(\n    converter: firestore.FirestoreDataConverter<U>\n  ): firestore.DocumentReference<U> {\n    return new DocumentReference<U>(this._key, this.firestore, converter);\n  }\n}\n\nclass SnapshotMetadata implements firestore.SnapshotMetadata {\n  constructor(\n    readonly hasPendingWrites: boolean,\n    readonly fromCache: boolean\n  ) {}\n\n  isEqual(other: firestore.SnapshotMetadata): boolean {\n    return (\n      this.hasPendingWrites === other.hasPendingWrites &&\n      this.fromCache === other.fromCache\n    );\n  }\n}\n\n/**\n * Options interface that can be provided to configure the deserialization of\n * DocumentSnapshots.\n */\nexport interface SnapshotOptions extends firestore.SnapshotOptions {}\n\nexport class DocumentSnapshot<T = firestore.DocumentData>\n  implements firestore.DocumentSnapshot<T> {\n  constructor(\n    private _firestore: Firestore,\n    private _key: DocumentKey,\n    public _document: Document | null,\n    private _fromCache: boolean,\n    private _hasPendingWrites: boolean,\n    private readonly _converter: firestore.FirestoreDataConverter<T> | null\n  ) {}\n\n  data(options?: firestore.SnapshotOptions): T | undefined {\n    validateBetweenNumberOfArgs('DocumentSnapshot.data', arguments, 0, 1);\n    options = validateSnapshotOptions('DocumentSnapshot.data', options);\n    if (!this._document) {\n      return undefined;\n    } else {\n      // We only want to use the converter and create a new DocumentSnapshot\n      // if a converter has been provided.\n      if (this._converter) {\n        const snapshot = new QueryDocumentSnapshot(\n          this._firestore,\n          this._key,\n          this._document,\n          this._fromCache,\n          this._hasPendingWrites,\n          /* converter= */ null\n        );\n        return this._converter.fromFirestore(snapshot, options);\n      } else {\n        const userDataWriter = new UserDataWriter(\n          this._firestore._databaseId,\n          this._firestore._areTimestampsInSnapshotsEnabled(),\n          options.serverTimestamps || 'none',\n          key =>\n            new DocumentReference(key, this._firestore, /* converter= */ null)\n        );\n        return userDataWriter.convertValue(this._document.toProto()) as T;\n      }\n    }\n  }\n\n  get(\n    fieldPath: string | ExternalFieldPath,\n    options?: firestore.SnapshotOptions\n  ): unknown {\n    validateBetweenNumberOfArgs('DocumentSnapshot.get', arguments, 1, 2);\n    options = validateSnapshotOptions('DocumentSnapshot.get', options);\n    if (this._document) {\n      const value = this._document\n        .data()\n        .field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n      if (value !== null) {\n        const userDataWriter = new UserDataWriter(\n          this._firestore._databaseId,\n          this._firestore._areTimestampsInSnapshotsEnabled(),\n          options.serverTimestamps || 'none',\n          key => new DocumentReference(key, this._firestore, this._converter)\n        );\n        return userDataWriter.convertValue(value);\n      }\n    }\n    return undefined;\n  }\n\n  get id(): string {\n    return this._key.path.lastSegment();\n  }\n\n  get ref(): firestore.DocumentReference<T> {\n    return new DocumentReference<T>(\n      this._key,\n      this._firestore,\n      this._converter\n    );\n  }\n\n  get exists(): boolean {\n    return this._document !== null;\n  }\n\n  get metadata(): firestore.SnapshotMetadata {\n    return new SnapshotMetadata(this._hasPendingWrites, this._fromCache);\n  }\n\n  isEqual(other: firestore.DocumentSnapshot<T>): boolean {\n    if (!(other instanceof DocumentSnapshot)) {\n      throw invalidClassError('isEqual', 'DocumentSnapshot', 1, other);\n    }\n    return (\n      this._firestore === other._firestore &&\n      this._fromCache === other._fromCache &&\n      this._key.isEqual(other._key) &&\n      (this._document === null\n        ? other._document === null\n        : this._document.isEqual(other._document)) &&\n      this._converter === other._converter\n    );\n  }\n}\n\nexport class QueryDocumentSnapshot<T = firestore.DocumentData>\n  extends DocumentSnapshot<T>\n  implements firestore.QueryDocumentSnapshot<T> {\n  data(options?: SnapshotOptions): T {\n    const data = super.data(options);\n    debugAssert(\n      data !== undefined,\n      'Document in a QueryDocumentSnapshot should exist'\n    );\n    return data;\n  }\n}\n\nexport class Query<T = firestore.DocumentData> implements firestore.Query<T> {\n  constructor(\n    public _query: InternalQuery,\n    readonly firestore: Firestore,\n    protected readonly _converter: firestore.FirestoreDataConverter<T> | null\n  ) {}\n\n  where(\n    field: string | ExternalFieldPath,\n    opStr: firestore.WhereFilterOp,\n    value: unknown\n  ): firestore.Query<T> {\n    validateExactNumberOfArgs('Query.where', arguments, 3);\n    validateDefined('Query.where', 3, value);\n\n    // Enumerated from the WhereFilterOp type in index.d.ts.\n    const whereFilterOpEnums = [\n      Operator.LESS_THAN,\n      Operator.LESS_THAN_OR_EQUAL,\n      Operator.EQUAL,\n      Operator.GREATER_THAN_OR_EQUAL,\n      Operator.GREATER_THAN,\n      Operator.ARRAY_CONTAINS,\n      Operator.IN,\n      Operator.ARRAY_CONTAINS_ANY\n    ];\n    const op = validateStringEnum('Query.where', whereFilterOpEnums, 2, opStr);\n\n    let fieldValue: api.Value;\n    const fieldPath = fieldPathFromArgument('Query.where', field);\n    if (fieldPath.isKeyField()) {\n      if (\n        op === Operator.ARRAY_CONTAINS ||\n        op === Operator.ARRAY_CONTAINS_ANY\n      ) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid Query. You can't perform '${op}' ` +\n            'queries on FieldPath.documentId().'\n        );\n      } else if (op === Operator.IN) {\n        this.validateDisjunctiveFilterElements(value, op);\n        const referenceList: api.Value[] = [];\n        for (const arrayValue of value as api.Value[]) {\n          referenceList.push(this.parseDocumentIdValue(arrayValue));\n        }\n        fieldValue = { arrayValue: { values: referenceList } };\n      } else {\n        fieldValue = this.parseDocumentIdValue(value);\n      }\n    } else {\n      if (op === Operator.IN || op === Operator.ARRAY_CONTAINS_ANY) {\n        this.validateDisjunctiveFilterElements(value, op);\n      }\n      fieldValue = this.firestore._dataReader.parseQueryValue(\n        'Query.where',\n        value,\n        // We only allow nested arrays for IN queries.\n        /** allowArrays = */ op === Operator.IN\n      );\n    }\n    const filter = FieldFilter.create(fieldPath, op, fieldValue);\n    this.validateNewFilter(filter);\n    return new Query(\n      this._query.addFilter(filter),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  orderBy(\n    field: string | ExternalFieldPath,\n    directionStr?: firestore.OrderByDirection\n  ): firestore.Query<T> {\n    validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n    validateOptionalArgType(\n      'Query.orderBy',\n      'non-empty string',\n      2,\n      directionStr\n    );\n    let direction: Direction;\n    if (directionStr === undefined || directionStr === 'asc') {\n      direction = Direction.ASCENDING;\n    } else if (directionStr === 'desc') {\n      direction = Direction.DESCENDING;\n    } else {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Function Query.orderBy() has unknown direction '${directionStr}', ` +\n          `expected 'asc' or 'desc'.`\n      );\n    }\n    if (this._query.startAt !== null) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You must not call Query.startAt() or ' +\n          'Query.startAfter() before calling Query.orderBy().'\n      );\n    }\n    if (this._query.endAt !== null) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid query. You must not call Query.endAt() or ' +\n          'Query.endBefore() before calling Query.orderBy().'\n      );\n    }\n    const fieldPath = fieldPathFromArgument('Query.orderBy', field);\n    const orderBy = new OrderBy(fieldPath, direction);\n    this.validateNewOrderBy(orderBy);\n    return new Query(\n      this._query.addOrderBy(orderBy),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  limit(n: number): firestore.Query<T> {\n    validateExactNumberOfArgs('Query.limit', arguments, 1);\n    validateArgType('Query.limit', 'number', 1, n);\n    validatePositiveNumber('Query.limit', 1, n);\n    return new Query(\n      this._query.withLimitToFirst(n),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  limitToLast(n: number): firestore.Query<T> {\n    validateExactNumberOfArgs('Query.limitToLast', arguments, 1);\n    validateArgType('Query.limitToLast', 'number', 1, n);\n    validatePositiveNumber('Query.limitToLast', 1, n);\n    return new Query(\n      this._query.withLimitToLast(n),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  startAt(\n    docOrField: unknown | firestore.DocumentSnapshot<unknown>,\n    ...fields: unknown[]\n  ): firestore.Query<T> {\n    validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.startAt',\n      docOrField,\n      fields,\n      /*before=*/ true\n    );\n    return new Query(\n      this._query.withStartAt(bound),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  startAfter(\n    docOrField: unknown | firestore.DocumentSnapshot<unknown>,\n    ...fields: unknown[]\n  ): firestore.Query<T> {\n    validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.startAfter',\n      docOrField,\n      fields,\n      /*before=*/ false\n    );\n    return new Query(\n      this._query.withStartAt(bound),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  endBefore(\n    docOrField: unknown | firestore.DocumentSnapshot<unknown>,\n    ...fields: unknown[]\n  ): firestore.Query<T> {\n    validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.endBefore',\n      docOrField,\n      fields,\n      /*before=*/ true\n    );\n    return new Query(\n      this._query.withEndAt(bound),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  endAt(\n    docOrField: unknown | firestore.DocumentSnapshot<unknown>,\n    ...fields: unknown[]\n  ): firestore.Query<T> {\n    validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n    const bound = this.boundFromDocOrFields(\n      'Query.endAt',\n      docOrField,\n      fields,\n      /*before=*/ false\n    );\n    return new Query(\n      this._query.withEndAt(bound),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  isEqual(other: firestore.Query<T>): boolean {\n    if (!(other instanceof Query)) {\n      throw invalidClassError('isEqual', 'Query', 1, other);\n    }\n    return (\n      this.firestore === other.firestore &&\n      this._query.isEqual(other._query) &&\n      this._converter === other._converter\n    );\n  }\n\n  withConverter<U>(\n    converter: firestore.FirestoreDataConverter<U>\n  ): firestore.Query<U> {\n    return new Query<U>(this._query, this.firestore, converter);\n  }\n\n  /** Helper function to create a bound from a document or fields */\n  private boundFromDocOrFields(\n    methodName: string,\n    docOrField: unknown | firestore.DocumentSnapshot<T>,\n    fields: unknown[],\n    before: boolean\n  ): Bound {\n    validateDefined(methodName, 1, docOrField);\n    if (docOrField instanceof DocumentSnapshot) {\n      if (fields.length > 0) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Too many arguments provided to ${methodName}().`\n        );\n      }\n      const snap = docOrField;\n      if (!snap.exists) {\n        throw new FirestoreError(\n          Code.NOT_FOUND,\n          `Can't use a DocumentSnapshot that doesn't exist for ` +\n            `${methodName}().`\n        );\n      }\n      return this.boundFromDocument(snap._document!, before);\n    } else {\n      const allFields = [docOrField].concat(fields);\n      return this.boundFromFields(methodName, allFields, before);\n    }\n  }\n\n  /**\n   * Create a Bound from a query and a document.\n   *\n   * Note that the Bound will always include the key of the document\n   * and so only the provided document will compare equal to the returned\n   * position.\n   *\n   * Will throw if the document does not contain all fields of the order by\n   * of the query or if any of the fields in the order by are an uncommitted\n   * server timestamp.\n   */\n  private boundFromDocument(doc: Document, before: boolean): Bound {\n    const components: api.Value[] = [];\n\n    // Because people expect to continue/end a query at the exact document\n    // provided, we need to use the implicit sort order rather than the explicit\n    // sort order, because it's guaranteed to contain the document key. That way\n    // the position becomes unambiguous and the query continues/ends exactly at\n    // the provided document. Without the key (by using the explicit sort\n    // orders), multiple documents could match the position, yielding duplicate\n    // results.\n    for (const orderBy of this._query.orderBy) {\n      if (orderBy.field.isKeyField()) {\n        components.push(refValue(this.firestore._databaseId, doc.key));\n      } else {\n        const value = doc.field(orderBy.field);\n        if (isServerTimestamp(value)) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Invalid query. You are trying to start or end a query using a ' +\n              'document for which the field \"' +\n              orderBy.field +\n              '\" is an uncommitted server timestamp. (Since the value of ' +\n              'this field is unknown, you cannot start/end a query with it.)'\n          );\n        } else if (value !== null) {\n          components.push(value);\n        } else {\n          const field = orderBy.field.canonicalString();\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. You are trying to start or end a query using a ` +\n              `document for which the field '${field}' (used as the ` +\n              `orderBy) does not exist.`\n          );\n        }\n      }\n    }\n    return new Bound(components, before);\n  }\n\n  /**\n   * Converts a list of field values to a Bound for the given query.\n   */\n  private boundFromFields(\n    methodName: string,\n    values: unknown[],\n    before: boolean\n  ): Bound {\n    // Use explicit order by's because it has to match the query the user made\n    const orderBy = this._query.explicitOrderBy;\n    if (values.length > orderBy.length) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Too many arguments provided to ${methodName}(). ` +\n          `The number of arguments must be less than or equal to the ` +\n          `number of Query.orderBy() clauses`\n      );\n    }\n\n    const components: api.Value[] = [];\n    for (let i = 0; i < values.length; i++) {\n      const rawValue = values[i];\n      const orderByComponent = orderBy[i];\n      if (orderByComponent.field.isKeyField()) {\n        if (typeof rawValue !== 'string') {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. Expected a string for document ID in ` +\n              `${methodName}(), but got a ${typeof rawValue}`\n          );\n        }\n        if (\n          !this._query.isCollectionGroupQuery() &&\n          rawValue.indexOf('/') !== -1\n        ) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. When querying a collection and ordering by FieldPath.documentId(), ` +\n              `the value passed to ${methodName}() must be a plain document ID, but ` +\n              `'${rawValue}' contains a slash.`\n          );\n        }\n        const path = this._query.path.child(ResourcePath.fromString(rawValue));\n        if (!DocumentKey.isDocumentKey(path)) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            `Invalid query. When querying a collection group and ordering by ` +\n              `FieldPath.documentId(), the value passed to ${methodName}() must result in a ` +\n              `valid document path, but '${path}' is not because it contains an odd number ` +\n              `of segments.`\n          );\n        }\n        const key = new DocumentKey(path);\n        components.push(refValue(this.firestore._databaseId, key));\n      } else {\n        const wrapped = this.firestore._dataReader.parseQueryValue(\n          methodName,\n          rawValue\n        );\n        components.push(wrapped);\n      }\n    }\n\n    return new Bound(components, before);\n  }\n\n  onSnapshot(\n    observer: PartialObserver<firestore.QuerySnapshot<T>>\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.SnapshotListenOptions,\n    observer: PartialObserver<firestore.QuerySnapshot<T>>\n  ): Unsubscribe;\n  onSnapshot(\n    onNext: NextFn<firestore.QuerySnapshot<T>>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n  onSnapshot(\n    options: firestore.SnapshotListenOptions,\n    onNext: NextFn<firestore.QuerySnapshot<T>>,\n    onError?: ErrorFn,\n    onCompletion?: CompleteFn\n  ): Unsubscribe;\n\n  onSnapshot(...args: unknown[]): Unsubscribe {\n    validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n    let options: firestore.SnapshotListenOptions = {};\n    let observer: PartialObserver<firestore.QuerySnapshot<T>>;\n    let currArg = 0;\n    if (\n      typeof args[currArg] === 'object' &&\n      !isPartialObserver(args[currArg])\n    ) {\n      options = args[currArg] as firestore.SnapshotListenOptions;\n      validateOptionNames('Query.onSnapshot', options, [\n        'includeMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'Query.onSnapshot',\n        'boolean',\n        'includeMetadataChanges',\n        options.includeMetadataChanges\n      );\n      currArg++;\n    }\n\n    if (isPartialObserver(args[currArg])) {\n      observer = args[currArg] as PartialObserver<firestore.QuerySnapshot<T>>;\n    } else {\n      validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n      validateOptionalArgType(\n        'Query.onSnapshot',\n        'function',\n        currArg + 1,\n        args[currArg + 1]\n      );\n      validateOptionalArgType(\n        'Query.onSnapshot',\n        'function',\n        currArg + 2,\n        args[currArg + 2]\n      );\n      observer = {\n        next: args[currArg] as NextFn<firestore.QuerySnapshot<T>>,\n        error: args[currArg + 1] as ErrorFn,\n        complete: args[currArg + 2] as CompleteFn\n      };\n    }\n    this.validateHasExplicitOrderByForLimitToLast(this._query);\n    return this.onSnapshotInternal(options, observer);\n  }\n\n  private onSnapshotInternal(\n    options: ListenOptions,\n    observer: PartialObserver<firestore.QuerySnapshot<T>>\n  ): Unsubscribe {\n    let errHandler = (err: Error): void => {\n      console.error('Uncaught Error in onSnapshot:', err);\n    };\n    if (observer.error) {\n      errHandler = observer.error.bind(observer);\n    }\n\n    const asyncObserver = new AsyncObserver<ViewSnapshot>({\n      next: (result: ViewSnapshot): void => {\n        if (observer.next) {\n          observer.next(\n            new QuerySnapshot(\n              this.firestore,\n              this._query,\n              result,\n              this._converter\n            )\n          );\n        }\n      },\n      error: errHandler\n    });\n\n    const firestoreClient = this.firestore.ensureClientConfigured();\n    const internalListener = firestoreClient.listen(\n      this._query,\n      asyncObserver,\n      options\n    );\n    return (): void => {\n      asyncObserver.mute();\n      firestoreClient.unlisten(internalListener);\n    };\n  }\n\n  private validateHasExplicitOrderByForLimitToLast(query: InternalQuery): void {\n    if (query.hasLimitToLast() && query.explicitOrderBy.length === 0) {\n      throw new FirestoreError(\n        Code.UNIMPLEMENTED,\n        'limitToLast() queries require specifying at least one orderBy() clause'\n      );\n    }\n  }\n\n  get(options?: firestore.GetOptions): Promise<firestore.QuerySnapshot<T>> {\n    validateBetweenNumberOfArgs('Query.get', arguments, 0, 1);\n    validateGetOptions('Query.get', options);\n    this.validateHasExplicitOrderByForLimitToLast(this._query);\n    return new Promise(\n      (resolve: Resolver<firestore.QuerySnapshot<T>>, reject: Rejecter) => {\n        if (options && options.source === 'cache') {\n          this.firestore\n            .ensureClientConfigured()\n            .getDocumentsFromLocalCache(this._query)\n            .then((viewSnap: ViewSnapshot) => {\n              resolve(\n                new QuerySnapshot(\n                  this.firestore,\n                  this._query,\n                  viewSnap,\n                  this._converter\n                )\n              );\n            }, reject);\n        } else {\n          this.getViaSnapshotListener(resolve, reject, options);\n        }\n      }\n    );\n  }\n\n  private getViaSnapshotListener(\n    resolve: Resolver<firestore.QuerySnapshot<T>>,\n    reject: Rejecter,\n    options?: firestore.GetOptions\n  ): void {\n    const unlisten = this.onSnapshotInternal(\n      {\n        includeMetadataChanges: true,\n        waitForSyncWhenOnline: true\n      },\n      {\n        next: (result: firestore.QuerySnapshot<T>) => {\n          // Remove query first before passing event to user to avoid\n          // user actions affecting the now stale query.\n          unlisten();\n\n          if (\n            result.metadata.fromCache &&\n            options &&\n            options.source === 'server'\n          ) {\n            reject(\n              new FirestoreError(\n                Code.UNAVAILABLE,\n                'Failed to get documents from server. (However, these ' +\n                  'documents may exist in the local cache. Run again ' +\n                  'without setting source to \"server\" to ' +\n                  'retrieve the cached documents.)'\n              )\n            );\n          } else {\n            resolve(result);\n          }\n        },\n        error: reject\n      }\n    );\n  }\n\n  /**\n   * Parses the given documentIdValue into a ReferenceValue, throwing\n   * appropriate errors if the value is anything other than a DocumentReference\n   * or String, or if the string is malformed.\n   */\n  private parseDocumentIdValue(documentIdValue: unknown): api.Value {\n    if (typeof documentIdValue === 'string') {\n      if (documentIdValue === '') {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          'Invalid query. When querying with FieldPath.documentId(), you ' +\n            'must provide a valid document ID, but it was an empty string.'\n        );\n      }\n      if (\n        !this._query.isCollectionGroupQuery() &&\n        documentIdValue.indexOf('/') !== -1\n      ) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. When querying a collection by ` +\n            `FieldPath.documentId(), you must provide a plain document ID, but ` +\n            `'${documentIdValue}' contains a '/' character.`\n        );\n      }\n      const path = this._query.path.child(\n        ResourcePath.fromString(documentIdValue)\n      );\n      if (!DocumentKey.isDocumentKey(path)) {\n        throw new FirestoreError(\n          Code.INVALID_ARGUMENT,\n          `Invalid query. When querying a collection group by ` +\n            `FieldPath.documentId(), the value provided must result in a valid document path, ` +\n            `but '${path}' is not because it has an odd number of segments (${path.length}).`\n        );\n      }\n      return refValue(this.firestore._databaseId, new DocumentKey(path));\n    } else if (documentIdValue instanceof DocumentReference) {\n      const ref = documentIdValue as DocumentReference<T>;\n      return refValue(this.firestore._databaseId, ref._key);\n    } else {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. When querying with FieldPath.documentId(), you must provide a valid ` +\n          `string or a DocumentReference, but it was: ` +\n          `${valueDescription(documentIdValue)}.`\n      );\n    }\n  }\n\n  /**\n   * Validates that the value passed into a disjunctrive filter satisfies all\n   * array requirements.\n   */\n  private validateDisjunctiveFilterElements(\n    value: unknown,\n    operator: Operator\n  ): void {\n    if (!Array.isArray(value) || value.length === 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid Query. A non-empty array is required for ' +\n          `'${operator.toString()}' filters.`\n      );\n    }\n    if (value.length > 10) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. '${operator.toString()}' filters support a ` +\n          'maximum of 10 elements in the value array.'\n      );\n    }\n    if (value.indexOf(null) >= 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. '${operator.toString()}' filters cannot contain 'null' ` +\n          'in the value array.'\n      );\n    }\n    if (value.filter(element => Number.isNaN(element)).length > 0) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid Query. '${operator.toString()}' filters cannot contain 'NaN' ` +\n          'in the value array.'\n      );\n    }\n  }\n\n  private validateNewFilter(filter: Filter): void {\n    if (filter instanceof FieldFilter) {\n      const arrayOps = [Operator.ARRAY_CONTAINS, Operator.ARRAY_CONTAINS_ANY];\n      const disjunctiveOps = [Operator.IN, Operator.ARRAY_CONTAINS_ANY];\n      const isArrayOp = arrayOps.indexOf(filter.op) >= 0;\n      const isDisjunctiveOp = disjunctiveOps.indexOf(filter.op) >= 0;\n\n      if (filter.isInequality()) {\n        const existingField = this._query.getInequalityFilterField();\n        if (existingField !== null && !existingField.isEqual(filter.field)) {\n          throw new FirestoreError(\n            Code.INVALID_ARGUMENT,\n            'Invalid query. All where filters with an inequality' +\n              ' (<, <=, >, or >=) must be on the same field. But you have' +\n              ` inequality filters on '${existingField.toString()}'` +\n              ` and '${filter.field.toString()}'`\n          );\n        }\n\n        const firstOrderByField = this._query.getFirstOrderByField();\n        if (firstOrderByField !== null) {\n          this.validateOrderByAndInequalityMatch(\n            filter.field,\n            firstOrderByField\n          );\n        }\n      } else if (isDisjunctiveOp || isArrayOp) {\n        // You can have at most 1 disjunctive filter and 1 array filter. Check if\n        // the new filter conflicts with an existing one.\n        let conflictingOp: Operator | null = null;\n        if (isDisjunctiveOp) {\n          conflictingOp = this._query.findFilterOperator(disjunctiveOps);\n        }\n        if (conflictingOp === null && isArrayOp) {\n          conflictingOp = this._query.findFilterOperator(arrayOps);\n        }\n        if (conflictingOp != null) {\n          // We special case when it's a duplicate op to give a slightly clearer error message.\n          if (conflictingOp === filter.op) {\n            throw new FirestoreError(\n              Code.INVALID_ARGUMENT,\n              'Invalid query. You cannot use more than one ' +\n                `'${filter.op.toString()}' filter.`\n            );\n          } else {\n            throw new FirestoreError(\n              Code.INVALID_ARGUMENT,\n              `Invalid query. You cannot use '${filter.op.toString()}' filters ` +\n                `with '${conflictingOp.toString()}' filters.`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  private validateNewOrderBy(orderBy: OrderBy): void {\n    if (this._query.getFirstOrderByField() === null) {\n      // This is the first order by. It must match any inequality.\n      const inequalityField = this._query.getInequalityFilterField();\n      if (inequalityField !== null) {\n        this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n      }\n    }\n  }\n\n  private validateOrderByAndInequalityMatch(\n    inequality: FieldPath,\n    orderBy: FieldPath\n  ): void {\n    if (!orderBy.isEqual(inequality)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid query. You have a where filter with an inequality ` +\n          `(<, <=, >, or >=) on field '${inequality.toString()}' ` +\n          `and so you must also use '${inequality.toString()}' ` +\n          `as your first Query.orderBy(), but your first Query.orderBy() ` +\n          `is on field '${orderBy.toString()}' instead.`\n      );\n    }\n  }\n}\n\nexport class QuerySnapshot<T = firestore.DocumentData>\n  implements firestore.QuerySnapshot<T> {\n  private _cachedChanges: Array<firestore.DocumentChange<T>> | null = null;\n  private _cachedChangesIncludeMetadataChanges: boolean | null = null;\n\n  readonly metadata: firestore.SnapshotMetadata;\n\n  constructor(\n    private readonly _firestore: Firestore,\n    private readonly _originalQuery: InternalQuery,\n    private readonly _snapshot: ViewSnapshot,\n    private readonly _converter: firestore.FirestoreDataConverter<T> | null\n  ) {\n    this.metadata = new SnapshotMetadata(\n      _snapshot.hasPendingWrites,\n      _snapshot.fromCache\n    );\n  }\n\n  get docs(): Array<firestore.QueryDocumentSnapshot<T>> {\n    const result: Array<firestore.QueryDocumentSnapshot<T>> = [];\n    this.forEach(doc => result.push(doc));\n    return result;\n  }\n\n  get empty(): boolean {\n    return this._snapshot.docs.isEmpty();\n  }\n\n  get size(): number {\n    return this._snapshot.docs.size;\n  }\n\n  forEach(\n    callback: (result: firestore.QueryDocumentSnapshot<T>) => void,\n    thisArg?: unknown\n  ): void {\n    validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n    validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n    this._snapshot.docs.forEach(doc => {\n      callback.call(thisArg, this.convertToDocumentImpl(doc));\n    });\n  }\n\n  get query(): firestore.Query<T> {\n    return new Query(this._originalQuery, this._firestore, this._converter);\n  }\n\n  docChanges(\n    options?: firestore.SnapshotListenOptions\n  ): Array<firestore.DocumentChange<T>> {\n    if (options) {\n      validateOptionNames('QuerySnapshot.docChanges', options, [\n        'includeMetadataChanges'\n      ]);\n      validateNamedOptionalType(\n        'QuerySnapshot.docChanges',\n        'boolean',\n        'includeMetadataChanges',\n        options.includeMetadataChanges\n      );\n    }\n\n    const includeMetadataChanges = !!(\n      options && options.includeMetadataChanges\n    );\n\n    if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'To include metadata changes with your document changes, you must ' +\n          'also pass { includeMetadataChanges:true } to onSnapshot().'\n      );\n    }\n\n    if (\n      !this._cachedChanges ||\n      this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges\n    ) {\n      this._cachedChanges = changesFromSnapshot<T>(\n        this._firestore,\n        includeMetadataChanges,\n        this._snapshot,\n        this._converter\n      );\n      this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;\n    }\n\n    return this._cachedChanges;\n  }\n\n  /** Check the equality. The call can be very expensive. */\n  isEqual(other: firestore.QuerySnapshot<T>): boolean {\n    if (!(other instanceof QuerySnapshot)) {\n      throw invalidClassError('isEqual', 'QuerySnapshot', 1, other);\n    }\n\n    return (\n      this._firestore === other._firestore &&\n      this._originalQuery.isEqual(other._originalQuery) &&\n      this._snapshot.isEqual(other._snapshot) &&\n      this._converter === other._converter\n    );\n  }\n\n  private convertToDocumentImpl(doc: Document): QueryDocumentSnapshot<T> {\n    return new QueryDocumentSnapshot(\n      this._firestore,\n      doc.key,\n      doc,\n      this.metadata.fromCache,\n      this._snapshot.mutatedKeys.has(doc.key),\n      this._converter\n    );\n  }\n}\n\nexport class CollectionReference<T = firestore.DocumentData> extends Query<T>\n  implements firestore.CollectionReference<T> {\n  constructor(\n    readonly _path: ResourcePath,\n    firestore: Firestore,\n    _converter: firestore.FirestoreDataConverter<T> | null\n  ) {\n    super(InternalQuery.atPath(_path), firestore, _converter);\n    if (_path.length % 2 !== 1) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Invalid collection reference. Collection ' +\n          'references must have an odd number of segments, but ' +\n          `${_path.canonicalString()} has ${_path.length}`\n      );\n    }\n  }\n\n  get id(): string {\n    return this._query.path.lastSegment();\n  }\n\n  get parent(): firestore.DocumentReference<firestore.DocumentData> | null {\n    const parentPath = this._query.path.popLast();\n    if (parentPath.isEmpty()) {\n      return null;\n    } else {\n      return new DocumentReference<firestore.DocumentData>(\n        new DocumentKey(parentPath),\n        this.firestore,\n        /* converter= */ null\n      );\n    }\n  }\n\n  get path(): string {\n    return this._query.path.canonicalString();\n  }\n\n  doc(pathString?: string): firestore.DocumentReference<T> {\n    validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n    // We allow omission of 'pathString' but explicitly prohibit passing in both\n    // 'undefined' and 'null'.\n    if (arguments.length === 0) {\n      pathString = AutoId.newId();\n    }\n    validateArgType(\n      'CollectionReference.doc',\n      'non-empty string',\n      1,\n      pathString\n    );\n    const path = ResourcePath.fromString(pathString!);\n    return DocumentReference.forPath<T>(\n      this._query.path.child(path),\n      this.firestore,\n      this._converter\n    );\n  }\n\n  add(value: T): Promise<firestore.DocumentReference<T>> {\n    validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n    const convertedValue = this._converter\n      ? this._converter.toFirestore(value)\n      : value;\n    validateArgType('CollectionReference.add', 'object', 1, convertedValue);\n    const docRef = this.doc();\n    return docRef.set(value).then(() => docRef);\n  }\n\n  withConverter<U>(\n    converter: firestore.FirestoreDataConverter<U>\n  ): firestore.CollectionReference<U> {\n    return new CollectionReference<U>(this._path, this.firestore, converter);\n  }\n}\n\nfunction validateSetOptions(\n  methodName: string,\n  options: firestore.SetOptions | undefined\n): firestore.SetOptions {\n  if (options === undefined) {\n    return {\n      merge: false\n    };\n  }\n\n  validateOptionNames(methodName, options, ['merge', 'mergeFields']);\n  validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n  validateOptionalArrayElements(\n    methodName,\n    'mergeFields',\n    'a string or a FieldPath',\n    options.mergeFields,\n    element =>\n      typeof element === 'string' || element instanceof ExternalFieldPath\n  );\n\n  if (options.mergeFields !== undefined && options.merge !== undefined) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      `Invalid options passed to function ${methodName}(): You cannot specify both \"merge\" ` +\n        `and \"mergeFields\".`\n    );\n  }\n\n  return options;\n}\n\nfunction validateSnapshotOptions(\n  methodName: string,\n  options: firestore.SnapshotOptions | undefined\n): firestore.SnapshotOptions {\n  if (options === undefined) {\n    return {};\n  }\n\n  validateOptionNames(methodName, options, ['serverTimestamps']);\n  validateNamedOptionalPropertyEquals(\n    methodName,\n    'options',\n    'serverTimestamps',\n    options.serverTimestamps,\n    ['estimate', 'previous', 'none']\n  );\n  return options;\n}\n\nfunction validateGetOptions(\n  methodName: string,\n  options: firestore.GetOptions | undefined\n): void {\n  validateOptionalArgType(methodName, 'object', 1, options);\n  if (options) {\n    validateOptionNames(methodName, options, ['source']);\n    validateNamedOptionalPropertyEquals(\n      methodName,\n      'options',\n      'source',\n      options.source,\n      ['default', 'server', 'cache']\n    );\n  }\n}\n\nfunction validateReference<T>(\n  methodName: string,\n  documentRef: firestore.DocumentReference<T>,\n  firestore: Firestore\n): DocumentKeyReference<T> {\n  if (!(documentRef instanceof DocumentKeyReference)) {\n    throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n  } else if (documentRef.firestore !== firestore) {\n    throw new FirestoreError(\n      Code.INVALID_ARGUMENT,\n      'Provided document reference is from a different Firestore instance.'\n    );\n  } else {\n    return documentRef;\n  }\n}\n\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nexport function changesFromSnapshot<T>(\n  firestore: Firestore,\n  includeMetadataChanges: boolean,\n  snapshot: ViewSnapshot,\n  converter: firestore.FirestoreDataConverter<T> | null\n): Array<firestore.DocumentChange<T>> {\n  if (snapshot.oldDocs.isEmpty()) {\n    // Special case the first snapshot because index calculation is easy and\n    // fast\n    let lastDoc: Document;\n    let index = 0;\n    return snapshot.docChanges.map(change => {\n      const doc = new QueryDocumentSnapshot<T>(\n        firestore,\n        change.doc.key,\n        change.doc,\n        snapshot.fromCache,\n        snapshot.mutatedKeys.has(change.doc.key),\n        converter\n      );\n      debugAssert(\n        change.type === ChangeType.Added,\n        'Invalid event type for first snapshot'\n      );\n      debugAssert(\n        !lastDoc || snapshot.query.docComparator(lastDoc, change.doc) < 0,\n        'Got added events in wrong order'\n      );\n      lastDoc = change.doc;\n      return {\n        type: 'added' as firestore.DocumentChangeType,\n        doc,\n        oldIndex: -1,\n        newIndex: index++\n      };\n    });\n  } else {\n    // A DocumentSet that is updated incrementally as changes are applied to use\n    // to lookup the index of a document.\n    let indexTracker = snapshot.oldDocs;\n    return snapshot.docChanges\n      .filter(\n        change => includeMetadataChanges || change.type !== ChangeType.Metadata\n      )\n      .map(change => {\n        const doc = new QueryDocumentSnapshot<T>(\n          firestore,\n          change.doc.key,\n          change.doc,\n          snapshot.fromCache,\n          snapshot.mutatedKeys.has(change.doc.key),\n          converter\n        );\n        let oldIndex = -1;\n        let newIndex = -1;\n        if (change.type !== ChangeType.Added) {\n          oldIndex = indexTracker.indexOf(change.doc.key);\n          debugAssert(oldIndex >= 0, 'Index for document not found');\n          indexTracker = indexTracker.delete(change.doc.key);\n        }\n        if (change.type !== ChangeType.Removed) {\n          indexTracker = indexTracker.add(change.doc);\n          newIndex = indexTracker.indexOf(change.doc.key);\n        }\n        return { type: resultChangeType(change.type), doc, oldIndex, newIndex };\n      });\n  }\n}\n\nfunction resultChangeType(type: ChangeType): firestore.DocumentChangeType {\n  switch (type) {\n    case ChangeType.Added:\n      return 'added';\n    case ChangeType.Modified:\n    case ChangeType.Metadata:\n      return 'modified';\n    case ChangeType.Removed:\n      return 'removed';\n    default:\n      return fail('Unknown change type: ' + type);\n  }\n}\n\n/**\n * Converts custom model object of type T into DocumentData by applying the\n * converter if it exists.\n *\n * This function is used when converting user objects to DocumentData\n * because we want to provide the user with a more specific error message if\n * their set() or fails due to invalid data originating from a toFirestore()\n * call.\n */\nexport function applyFirestoreDataConverter<T>(\n  converter: UntypedFirestoreDataConverter<T> | null,\n  value: T,\n  functionName: string\n): [firestore.DocumentData, string] {\n  let convertedValue;\n  if (converter) {\n    convertedValue = converter.toFirestore(value);\n    functionName = 'toFirestore() in ' + functionName;\n  } else {\n    convertedValue = value as firestore.DocumentData;\n  }\n  return [convertedValue, functionName];\n}\n\nfunction contains(obj: object, key: string): obj is { key: unknown } {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Code, FirestoreError } from './error';\n\n/**\n * Helper function to prevent instantiation through the constructor.\n *\n * This method creates a new constructor that throws when it's invoked.\n * The prototype of that constructor is then set to the prototype of the hidden\n * \"class\" to expose all the prototype methods and allow for instanceof\n * checks.\n *\n * To also make all the static methods available, all properties of the\n * original constructor are copied to the new constructor.\n */\nexport function makeConstructorPrivate<T extends Function>(\n  cls: T,\n  optionalMessage?: string\n): T {\n  function PublicConstructor(): never {\n    let error = 'This constructor is private.';\n    if (optionalMessage) {\n      error += ' ';\n      error += optionalMessage;\n    }\n    throw new FirestoreError(Code.INVALID_ARGUMENT, error);\n  }\n\n  // Make sure instanceof checks work and all methods are exposed on the public\n  // constructor\n  PublicConstructor.prototype = cls.prototype;\n\n  // Copy any static methods/members\n  Object.assign(PublicConstructor, cls);\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return PublicConstructor as any;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp, FirebaseNamespace } from '@firebase/app-types';\nimport { FirebaseAuthInternalName } from '@firebase/auth-interop-types';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport { Component, ComponentType, Provider } from '@firebase/component';\nimport {\n  CACHE_SIZE_UNLIMITED,\n  Firestore,\n  DocumentReference,\n  DocumentSnapshot,\n  QueryDocumentSnapshot,\n  Query,\n  QuerySnapshot,\n  CollectionReference,\n  Transaction,\n  WriteBatch\n} from '../api/database';\nimport { Blob } from '../api/blob';\nimport { FieldPath } from '../api/field_path';\nimport { GeoPoint } from '../api/geo_point';\nimport { Timestamp } from '../api/timestamp';\nimport { makeConstructorPrivate } from '../util/api';\nimport { FieldValue } from '../api/field_value';\n\n// Public instance that disallows construction at runtime. Note that this still\n// allows instanceof checks.\nexport const PublicFirestore = makeConstructorPrivate(\n  Firestore,\n  'Use firebase.firestore() instead.'\n);\nexport const PublicTransaction = makeConstructorPrivate(\n  Transaction,\n  'Use firebase.firestore().runTransaction() instead.'\n);\nexport const PublicWriteBatch = makeConstructorPrivate(\n  WriteBatch,\n  'Use firebase.firestore().batch() instead.'\n);\nexport const PublicDocumentReference = makeConstructorPrivate(\n  DocumentReference,\n  'Use firebase.firestore().doc() instead.'\n);\nexport const PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport const PublicQueryDocumentSnapshot = makeConstructorPrivate(\n  QueryDocumentSnapshot\n);\nexport const PublicQuery = makeConstructorPrivate(Query);\nexport const PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport const PublicCollectionReference = makeConstructorPrivate(\n  CollectionReference,\n  'Use firebase.firestore().collection() instead.'\n);\nexport const PublicFieldValue = makeConstructorPrivate(\n  FieldValue,\n  'Use FieldValue.<field>() instead.'\n);\nexport const PublicBlob = makeConstructorPrivate(\n  Blob,\n  'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.'\n);\n\nconst firestoreNamespace = {\n  Firestore: PublicFirestore,\n  GeoPoint,\n  Timestamp,\n  Blob: PublicBlob,\n  Transaction: PublicTransaction,\n  WriteBatch: PublicWriteBatch,\n  DocumentReference: PublicDocumentReference,\n  DocumentSnapshot: PublicDocumentSnapshot,\n  Query: PublicQuery,\n  QueryDocumentSnapshot: PublicQueryDocumentSnapshot,\n  QuerySnapshot: PublicQuerySnapshot,\n  CollectionReference: PublicCollectionReference,\n  FieldPath,\n  FieldValue: PublicFieldValue,\n  setLogLevel: Firestore.setLogLevel,\n  CACHE_SIZE_UNLIMITED\n};\n\n/**\n * Configures Firestore as part of the Firebase SDK by calling registerService.\n *\n * @param firebase The FirebaseNamespace to register Firestore with\n * @param firestoreFactory A factory function that returns a new Firestore\n *    instance.\n */\nexport function configureForFirebase(\n  firebase: FirebaseNamespace,\n  firestoreFactory: (\n    app: FirebaseApp,\n    auth: Provider<FirebaseAuthInternalName>\n  ) => Firestore\n): void {\n  (firebase as _FirebaseNamespace).INTERNAL.registerComponent(\n    new Component(\n      'firestore',\n      container => {\n        const app = container.getProvider('app').getImmediate()!;\n        return firestoreFactory(app, container.getProvider('auth-internal'));\n      },\n      ComponentType.PUBLIC\n    ).setServiceProps({ ...firestoreNamespace })\n  );\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ConnectivityMonitor, NetworkStatus } from './connectivity_monitor';\n\nexport class NoopConnectivityMonitor implements ConnectivityMonitor {\n  addCallback(callback: (status: NetworkStatus) => void): void {\n    // No-op.\n  }\n\n  shutdown(): void {\n    // No-op.\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { debugAssert } from '../util/assert';\nimport { FirestoreError } from '../util/error';\n\nimport { Stream } from './connection';\n\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nexport class StreamBridge<I, O> implements Stream<I, O> {\n  private wrappedOnOpen: (() => void) | undefined;\n  private wrappedOnClose: ((err?: FirestoreError) => void) | undefined;\n  private wrappedOnMessage: ((msg: O) => void) | undefined;\n\n  private sendFn: (msg: I) => void;\n  private closeFn: () => void;\n\n  constructor(args: { sendFn: (msg: I) => void; closeFn: () => void }) {\n    this.sendFn = args.sendFn;\n    this.closeFn = args.closeFn;\n  }\n\n  onOpen(callback: () => void): void {\n    debugAssert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');\n    this.wrappedOnOpen = callback;\n  }\n\n  onClose(callback: (err?: FirestoreError) => void): void {\n    debugAssert(!this.wrappedOnClose, 'Called onClose on stream twice!');\n    this.wrappedOnClose = callback;\n  }\n\n  onMessage(callback: (msg: O) => void): void {\n    debugAssert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');\n    this.wrappedOnMessage = callback;\n  }\n\n  close(): void {\n    this.closeFn();\n  }\n\n  send(msg: I): void {\n    this.sendFn(msg);\n  }\n\n  callOnOpen(): void {\n    debugAssert(\n      this.wrappedOnOpen !== undefined,\n      'Cannot call onOpen because no callback was set'\n    );\n    this.wrappedOnOpen();\n  }\n\n  callOnClose(err?: FirestoreError): void {\n    debugAssert(\n      this.wrappedOnClose !== undefined,\n      'Cannot call onClose because no callback was set'\n    );\n    this.wrappedOnClose(err);\n  }\n\n  callOnMessage(msg: O): void {\n    debugAssert(\n      this.wrappedOnMessage !== undefined,\n      'Cannot call onMessage because no callback was set'\n    );\n    this.wrappedOnMessage(msg);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * Utilities for dealing with node.js-style APIs. See nodePromise for more\n * details.\n */\n\n/**\n * Creates a node-style callback that resolves or rejects a new Promise. The\n * callback is passed to the given action which can then use the callback as\n * a parameter to a node-style function.\n *\n * The intent is to directly bridge a node-style function (which takes a\n * callback) into a Promise without manually converting between the node-style\n * callback and the promise at each call.\n *\n * In effect it allows you to convert:\n *\n * @example\n * new Promise((resolve: (value?: fs.Stats) => void,\n *              reject: (error?: any) => void) => {\n *   fs.stat(path, (error?: any, stat?: fs.Stats) => {\n *     if (error) {\n *       reject(error);\n *     } else {\n *       resolve(stat);\n *     }\n *   });\n * });\n *\n * Into\n * @example\n * nodePromise((callback: NodeCallback<fs.Stats>) => {\n *   fs.stat(path, callback);\n * });\n *\n * @param action a function that takes a node-style callback as an argument and\n *     then uses that callback to invoke some node-style API.\n * @return a new Promise which will be rejected if the callback is given the\n *     first Error parameter or will resolve to the value given otherwise.\n */\nexport function nodePromise<R>(\n  action: (callback: NodeCallback<R>) => void\n): Promise<R> {\n  return new Promise(\n    (resolve: (value?: R) => void, reject: (error?: unknown) => void) => {\n      action((error?: unknown, value?: R) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(value);\n        }\n      });\n    }\n  );\n}\n\n/**\n * A node-style callback which passes an Error as the first argument if there\n * was an error, or passes null and a proper value\n */\nexport interface NodeCallback<R> {\n  (error?: unknown, value?: R): void;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Metadata,\n  GrpcObject,\n  credentials as GrpcCredentials,\n  ServiceError\n} from '@grpc/grpc-js';\nimport * as grpcPkgJson from '@grpc/grpc-js/package.json';\n\nimport firebase from '@firebase/app';\nconst SDK_VERSION = firebase.SDK_VERSION;\n\nconst grpcVersion = grpcPkgJson.version;\n\nimport { Token } from '../api/credentials';\nimport { DatabaseInfo } from '../core/database_info';\nimport { Connection, Stream } from '../remote/connection';\nimport { mapCodeFromRpcCode } from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { hardAssert } from '../util/assert';\nimport { FirestoreError } from '../util/error';\nimport { logError, logDebug, logWarn } from '../util/log';\nimport { NodeCallback, nodePromise } from '../util/node_api';\nimport { Deferred } from '../util/promise';\n\nconst LOG_TAG = 'Connection';\n\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nconst X_GOOG_API_CLIENT_VALUE = `gl-node/${process.versions.node} fire/${SDK_VERSION} grpc/${grpcVersion}`;\n\nfunction createMetadata(\n  databaseInfo: DatabaseInfo,\n  token: Token | null\n): Metadata {\n  hardAssert(\n    token === null || token.type === 'OAuth',\n    'If provided, token must be OAuth'\n  );\n\n  const metadata = new Metadata();\n  if (token) {\n    for (const header in token.authHeaders) {\n      if (token.authHeaders.hasOwnProperty(header)) {\n        metadata.set(header, token.authHeaders[header]);\n      }\n    }\n  }\n  metadata.set('x-goog-api-client', X_GOOG_API_CLIENT_VALUE);\n  // This header is used to improve routing and project isolation by the\n  // backend.\n  metadata.set(\n    'google-cloud-resource-prefix',\n    `projects/${databaseInfo.databaseId.projectId}/` +\n      `databases/${databaseInfo.databaseId.database}`\n  );\n  return metadata;\n}\n\n// The type of these stubs is dynamically generated by the GRPC runtime\n// from the protocol buffer.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype GeneratedGrpcStub = any;\n\n/**\n * A Connection implemented by GRPC-Node.\n */\nexport class GrpcConnection implements Connection {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private firestore: any;\n\n  // We cache stubs for the most-recently-used token.\n  private cachedStub: GeneratedGrpcStub | null = null;\n\n  constructor(protos: GrpcObject, private databaseInfo: DatabaseInfo) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.firestore = (protos as any)['google']['firestore']['v1'];\n  }\n\n  private ensureActiveStub(): GeneratedGrpcStub {\n    if (!this.cachedStub) {\n      logDebug(LOG_TAG, 'Creating Firestore stub.');\n      const credentials = this.databaseInfo.ssl\n        ? GrpcCredentials.createSsl()\n        : GrpcCredentials.createInsecure();\n      this.cachedStub = new this.firestore.Firestore(\n        this.databaseInfo.host,\n        credentials\n      );\n    }\n    return this.cachedStub;\n  }\n\n  invokeRPC<Req, Resp>(\n    rpcName: string,\n    request: Req,\n    token: Token | null\n  ): Promise<Resp> {\n    const stub = this.ensureActiveStub();\n    const metadata = createMetadata(this.databaseInfo, token);\n\n    return nodePromise((callback: NodeCallback<Resp>) => {\n      logDebug(LOG_TAG, `RPC '${rpcName}' invoked with request:`, request);\n      return stub[rpcName](\n        request,\n        metadata,\n        (grpcError?: ServiceError, value?: Resp) => {\n          if (grpcError) {\n            logDebug(LOG_TAG, `RPC '${rpcName}' failed with error:`, grpcError);\n            callback(\n              new FirestoreError(\n                mapCodeFromRpcCode(grpcError.code),\n                grpcError.message\n              )\n            );\n          } else {\n            logDebug(\n              LOG_TAG,\n              `RPC '${rpcName}' completed with response:`,\n              value\n            );\n            callback(undefined, value);\n          }\n        }\n      );\n    });\n  }\n\n  invokeStreamingRPC<Req, Resp>(\n    rpcName: string,\n    request: Req,\n    token: Token | null\n  ): Promise<Resp[]> {\n    const results: Resp[] = [];\n    const responseDeferred = new Deferred<Resp[]>();\n\n    logDebug(\n      LOG_TAG,\n      `RPC '${rpcName}' invoked (streaming) with request:`,\n      request\n    );\n    const stub = this.ensureActiveStub();\n    const metadata = createMetadata(this.databaseInfo, token);\n    const stream = stub[rpcName](request, metadata);\n    stream.on('data', (response: Resp) => {\n      logDebug(LOG_TAG, `RPC ${rpcName} received result:`, response);\n      results.push(response);\n    });\n    stream.on('end', () => {\n      logDebug(LOG_TAG, `RPC '${rpcName}' completed.`);\n      responseDeferred.resolve(results);\n    });\n    stream.on('error', (grpcError: ServiceError) => {\n      logDebug(LOG_TAG, `RPC '${rpcName}' failed with error:`, grpcError);\n      const code = mapCodeFromRpcCode(grpcError.code);\n      responseDeferred.reject(new FirestoreError(code, grpcError.message));\n    });\n\n    return responseDeferred.promise;\n  }\n\n  // TODO(mikelehen): This \"method\" is a monster. Should be refactored.\n  openStream<Req, Resp>(\n    rpcName: string,\n    token: Token | null\n  ): Stream<Req, Resp> {\n    const stub = this.ensureActiveStub();\n    const metadata = createMetadata(this.databaseInfo, token);\n    const grpcStream = stub[rpcName](metadata);\n\n    let closed = false;\n    const close = (err?: FirestoreError): void => {\n      if (!closed) {\n        closed = true;\n        stream.callOnClose(err);\n        grpcStream.end();\n      }\n    };\n\n    const stream = new StreamBridge<Req, Resp>({\n      sendFn: (msg: Req) => {\n        if (!closed) {\n          logDebug(LOG_TAG, 'GRPC stream sending:', msg);\n          try {\n            grpcStream.write(msg);\n          } catch (e) {\n            // This probably means we didn't conform to the proto.  Make sure to\n            // log the message we sent.\n            logError('Failure sending:', msg);\n            logError('Error:', e);\n            throw e;\n          }\n        } else {\n          logDebug(LOG_TAG, 'Not sending because gRPC stream is closed:', msg);\n        }\n      },\n      closeFn: () => {\n        logDebug(LOG_TAG, 'GRPC stream closed locally via close().');\n        close();\n      }\n    });\n\n    grpcStream.on('data', (msg: Resp) => {\n      if (!closed) {\n        logDebug(LOG_TAG, 'GRPC stream received:', msg);\n        stream.callOnMessage(msg);\n      }\n    });\n\n    grpcStream.on('end', () => {\n      logDebug(LOG_TAG, 'GRPC stream ended.');\n      close();\n    });\n\n    grpcStream.on('error', (grpcError: ServiceError) => {\n      logWarn(\n        LOG_TAG,\n        'GRPC stream error. Code:',\n        grpcError.code,\n        'Message:',\n        grpcError.message\n      );\n      const code = mapCodeFromRpcCode(grpcError.code);\n      close(new FirestoreError(code, grpcError.message));\n    });\n\n    logDebug(LOG_TAG, 'Opening GRPC stream');\n    // TODO(dimond): Since grpc has no explicit open status (or does it?) we\n    // simulate an onOpen in the next loop after the stream had it's listeners\n    // registered\n    setTimeout(() => {\n      stream.callOnOpen();\n    }, 0);\n\n    return stream;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { loadSync } from '@grpc/proto-loader';\nimport { loadPackageDefinition, GrpcObject } from '@grpc/grpc-js';\nimport { join, resolve, isAbsolute } from 'path';\n// only used in tests\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { IConversionOptions, Root } from 'protobufjs';\n\n/** Used by tests so we can match @grpc/proto-loader behavior. */\nexport const protoLoaderOptions: IConversionOptions = {\n  longs: String,\n  enums: String,\n  defaults: true,\n  oneofs: false\n};\n\n/**\n * Loads the protocol buffer definitions for Firestore.\n *\n * @returns The GrpcObject representing our protos.\n */\nexport function loadProtos(): GrpcObject {\n  const root = resolve(\n    __dirname,\n    process.env.FIRESTORE_PROTO_ROOT || '../protos'\n  );\n  const firestoreProtoFile = join(root, 'google/firestore/v1/firestore.proto');\n\n  const packageDefinition = loadSync(firestoreProtoFile, {\n    ...protoLoaderOptions,\n    includeDirs: [root]\n  });\n\n  return loadPackageDefinition(packageDefinition);\n}\n\n/** Used by tests so we can directly create ProtobufJS proto message objects from JSON protos. */\nexport function loadRawProtos(): Root {\n  const root = resolve(\n    __dirname,\n    process.env.FIRESTORE_PROTO_ROOT || '../protos'\n  );\n  const firestoreProtoFile = join(root, 'google/firestore/v1/firestore.proto');\n\n  const protoRoot = new Root();\n  // Override the resolvePath function to look for protos in the 'root'\n  // directory.\n  protoRoot.resolvePath = (origin: string, target: string) => {\n    if (isAbsolute(target)) {\n      return target;\n    }\n    return join(root, target);\n  };\n\n  protoRoot.loadSync(firestoreProtoFile);\n  protoRoot.resolveAll();\n  return protoRoot;\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { randomBytes } from 'crypto';\nimport { inspect } from 'util';\n\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { Platform } from '../platform/platform';\nimport { Connection } from '../remote/connection';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { Code, FirestoreError } from '../util/error';\nimport { ConnectivityMonitor } from './../remote/connectivity_monitor';\nimport { NoopConnectivityMonitor } from './../remote/connectivity_monitor_noop';\n\nimport { GrpcConnection } from './grpc_connection';\nimport { loadProtos } from './load_protos';\nimport { debugAssert } from '../util/assert';\n\nexport class NodePlatform implements Platform {\n  readonly base64Available = true;\n\n  readonly document = null;\n\n  get window(): Window | null {\n    if (process.env.USE_MOCK_PERSISTENCE === 'YES') {\n      // eslint-disable-next-line no-restricted-globals\n      return window;\n    }\n\n    return null;\n  }\n\n  loadConnection(databaseInfo: DatabaseInfo): Promise<Connection> {\n    const protos = loadProtos();\n    return Promise.resolve(new GrpcConnection(protos, databaseInfo));\n  }\n\n  newConnectivityMonitor(): ConnectivityMonitor {\n    return new NoopConnectivityMonitor();\n  }\n\n  newSerializer(partitionId: DatabaseId): JsonProtoSerializer {\n    return new JsonProtoSerializer(partitionId, { useProto3Json: false });\n  }\n\n  formatJSON(value: unknown): string {\n    // util.inspect() results in much more readable output than JSON.stringify()\n    return inspect(value, { depth: 100 });\n  }\n\n  atob(encoded: string): string {\n    // Node actually doesn't validate base64 strings.\n    // A quick sanity check that is not a fool-proof validation\n    if (/[^-A-Za-z0-9+/=]/.test(encoded)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        'Not a valid Base64 string: ' + encoded\n      );\n    }\n    return new Buffer(encoded, 'base64').toString('binary');\n  }\n\n  btoa(raw: string): string {\n    return new Buffer(raw, 'binary').toString('base64');\n  }\n\n  randomBytes(nBytes: number): Uint8Array {\n    debugAssert(nBytes >= 0, `Expecting non-negative nBytes, got: ${nBytes}`);\n\n    return randomBytes(nBytes);\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PlatformSupport } from '../platform/platform';\nimport { NodePlatform } from './node_platform';\n\n/**\n * This code needs to run before Firestore is used. This can be achieved in\n * several ways:\n *   1) Through the JSCompiler compiling this code and then (automatically)\n *      executing it before exporting the Firestore symbols.\n *   2) Through importing this module first in a Firestore main module\n */\nPlatformSupport.setPlatform(new NodePlatform());\n","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport { FirebaseNamespace } from '@firebase/app-types';\n\nimport { Firestore } from './src/api/database';\nimport { MemoryComponentProvider } from './src/core/component_provider';\nimport { configureForFirebase } from './src/platform/config';\nimport './register-module';\nimport './src/platform_node/node_init';\n\nimport { name, version } from './package.json';\n\n/**\n * Registers the memory-only Firestore build for Node with the components\n * framework.\n */\nexport function registerFirestore(instance: FirebaseNamespace): void {\n  configureForFirebase(\n    instance,\n    (app, auth) => new Firestore(app, auth, new MemoryComponentProvider())\n  );\n  instance.registerVersion(name, version);\n}\n\nregisterFirestore(firebase);\n"],"names":["Logger","LogLevel","__extends","LOG_TAG","InternalFieldPath","FieldPath","Query","InternalQuery","Transaction","ExternalFieldPath","Component","SDK_VERSION","grpcPkgJson.version","Metadata","credentials","GrpcCredentials","resolve","join","loadSync","loadPackageDefinition","inspect","randomBytes"],"mappings":"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"}